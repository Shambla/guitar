<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link type="text/css" rel="stylesheet" href="style/montserrat.css">
		<link type="text/css" rel="stylesheet" href="style/font-awesome.css">
		<link type="text/css" rel="stylesheet" href="style/index.css">
		<link rel="shortcut icon" href="img/favico.ico" type="image/x-icon">
		<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="https://js.stripe.com/v3/"></script>
		<title>Trading Signals - Live Feed</title>
		<style>
			/* ============================================
			   SYNTHWAVE THEME - Background & Base Styles - Dev Access - brianstreckfus.com/signals.html?dev=dev_access_2024
			   ============================================ */
			
			/* Synthwave gradient background */
			html, body {
				background: linear-gradient(135deg, #0a0e27 0%, #1a0d2e 25%, #16213e 50%, #0f3460 75%, #0a0e27 100%) !important;
				background-attachment: fixed !important;
				background-size: 400% 400% !important;
				animation: synthwaveGradient 15s ease infinite !important;
				min-height: 100vh !important;
				position: relative !important;
			}
			
			/* Animated gradient background */
			@keyframes synthwaveGradient {
				0% { background-position: 0% 50%; }
				50% { background-position: 100% 50%; }
				100% { background-position: 0% 50%; }
			}
			
			/* Grid overlay pattern (synthwave aesthetic) */
			body::before {
				content: '';
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-image: 
					linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
					linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
				background-size: 50px 50px;
				pointer-events: none;
				z-index: 0;
			}
			
			/* Horizon line effect (classic synthwave) */
			body::after {
				content: '';
				position: fixed;
				bottom: 0;
				left: 0;
				width: 100%;
				height: 200px;
				background: linear-gradient(to top, 
					rgba(255, 0, 255, 0.15) 0%,
					rgba(0, 255, 255, 0.1) 50%,
					transparent 100%);
				pointer-events: none;
				z-index: 0;
			}
			
			/* Ensure content is above background layers */
			body > * {
				position: relative;
				z-index: 1;
			}
			
			/* Emoji font support - ensure emojis use system emoji fonts */
			/* Use font-family with emoji fallbacks for proper emoji rendering */
			body, html {
				font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif, 
					'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji';
			}
			
			/* Ensure emoji characters specifically use emoji fonts */
			.asset-name, .symbol-display {
				font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif, 
					'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji';
			}
			
			/* Unicode range for emoji - ensures emoji characters use emoji fonts */
			@font-face {
				font-family: 'EmojiFallback';
				src: local('Apple Color Emoji'), local('Segoe UI Emoji'), local('Segoe UI Symbol'), 
					local('Noto Color Emoji'), local('EmojiOne Color'), local('Android Emoji');
				unicode-range: U+1F300-1F9FF, U+1FA00-1FAFF, U+2600-26FF, U+2700-27BF;
			}
			
			/* Neon glow text effect */
			@keyframes neonGlow {
				0%, 100% {
					text-shadow: 
						0 0 5px currentColor,
						0 0 10px currentColor,
						0 0 15px currentColor,
						0 0 20px currentColor;
				}
				50% {
					text-shadow: 
						0 0 2px currentColor,
						0 0 5px currentColor,
						0 0 8px currentColor,
						0 0 12px currentColor;
				}
			}
			
			/* Animated ROI colors - cycling through vibrant colors */
			@keyframes roiColorCycle {
				0% { color: #ff0080; }
				16.66% { color: #ff4000; }
				33.33% { color: #ffaa00; }
				50% { color: #ffff00; }
				66.66% { color: #00ff00; }
				83.33% { color: #00ffff; }
				100% { color: #ff0080; }
			}
			
			/* Pulsing glow effect for ROI */
			@keyframes roiPulse {
				0%, 100% {
					filter: drop-shadow(0 0 10px rgba(255, 0, 128, 0.8)) 
					        drop-shadow(0 0 20px rgba(255, 64, 0, 0.6)) 
					        drop-shadow(0 0 30px rgba(255, 170, 0, 0.4));
					transform: scale(1);
				}
				50% {
					filter: drop-shadow(0 0 20px rgba(255, 0, 128, 1)) 
					        drop-shadow(0 0 40px rgba(255, 64, 0, 0.8)) 
					        drop-shadow(0 0 60px rgba(255, 170, 0, 0.6))
					        drop-shadow(0 0 80px rgba(0, 255, 0, 0.4));
					transform: scale(1.05);
				}
			}
			
			/* ROI styling - animated and eye-catching */
			.roi-animated {
				display: inline-block;
				font-size: 28px !important;
				font-weight: 900 !important;
				letter-spacing: 1px;
				background: linear-gradient(135deg, #ff0080, #ff4000, #ffaa00, #ffff00, #00ff00, #00ffff, #ff0080);
				background-size: 300% 300%;
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
				background-clip: text;
				animation: 
					roiGradientShift 3s ease infinite,
					roiPulse 2s ease-in-out infinite;
				position: relative;
			}
			
			/* Sparkle highlight for "ACTUALLY MACHINE LEARNING" */
			@keyframes mlShimmer {
				0%, 100% {
					text-shadow:
						0 0 6px rgba(255, 235, 59, 0.8),
						0 0 14px rgba(255, 193, 7, 0.7),
						0 0 24px rgba(255, 193, 7, 0.5);
				}
				50% {
					text-shadow:
						0 0 10px rgba(255, 255, 255, 0.95),
						0 0 18px rgba(255, 193, 7, 0.9),
						0 0 32px rgba(255, 193, 7, 0.7);
				}
			}
			.sparkle-ml {
				color: #ffeb3b !important;
				font-weight: 900 !important;
				letter-spacing: 0.5px;
				text-shadow:
					0 0 6px rgba(255, 235, 59, 0.8),
					0 0 14px rgba(255, 193, 7, 0.7),
					0 0 24px rgba(255, 193, 7, 0.5);
				animation: mlShimmer 1.8s ease-in-out infinite;
			}
			
			/* Gradient shift animation for background */
			@keyframes roiGradientShift {
				0% { background-position: 0% 50%; }
				50% { background-position: 100% 50%; }
				100% { background-position: 0% 50%; }
			}
			
			/* Money emoji animation */
			.roi-money-emoji {
				display: inline-block;
				font-size: 32px;
				animation: moneyBounce 1.5s ease-in-out infinite;
				filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
			}
			
			@keyframes moneyBounce {
				0%, 100% {
					transform: translateY(0) rotate(0deg) scale(1);
				}
				25% {
					transform: translateY(-5px) rotate(-10deg) scale(1.1);
				}
				50% {
					transform: translateY(-8px) rotate(0deg) scale(1.15);
				}
				75% {
					transform: translateY(-5px) rotate(10deg) scale(1.1);
				}
			}
			
			.signals-container {
				margin-top: 100px;
				padding: 20px;
			}
			.signals-header {
				text-align: center;
				margin-bottom: 30px;
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				background: rgba(10, 14, 39, 0.95);
				backdrop-filter: blur(10px);
				padding: 20px;
				z-index: 1000;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
				overflow: visible; /* Allow bull image to be visible */
			}
			
			/* Angry Bull image - clickable for music - positioned below header */
			.bull-image {
				position: fixed !important;
				top: 100px !important;
				left: 50% !important;
				transform: translateX(-50%) !important;
				width: 150px !important;
				height: 150px !important;
				cursor: pointer !important;
				z-index: 99999 !important;
				transition: all 0.3s ease !important;
				border-radius: 12px !important;
				background: rgba(255, 193, 7, 0.5) !important;
				border: 4px solid #ffc107 !important;
				padding: 10px !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				margin: 0 !important;
				box-shadow: 0 0 40px rgba(255, 193, 7, 1), inset 0 0 20px rgba(255, 193, 7, 0.3) !important;
				opacity: 1 !important;
				visibility: visible !important;
			}
			
			.bull-image img {
				width: 100% !important;
				height: 100% !important;
				object-fit: contain !important;
				opacity: 1 !important;
				display: block !important;
				visibility: visible !important;
			}
			
			.bull-image:hover {
				transform: translateX(-50%) scale(1.1) !important;
				background: rgba(255, 193, 7, 0.7) !important;
				border-color: #ffc107 !important;
				box-shadow: 0 0 50px rgba(255, 193, 7, 1) !important;
			}
			
			/* Bull image above navigation - non-fixed, scrolls with page */
			.bull-image-nav {
				display: inline-block !important;
				width: 100px !important;
				height: 100px !important;
				cursor: pointer !important;
				transition: all 0.3s ease !important;
				border-radius: 12px !important;
				background: rgba(255, 193, 7, 0.2) !important;
				border: 2px solid rgba(255, 193, 7, 0.6) !important;
				padding: 8px !important;
				box-shadow: 0 0 15px rgba(255, 193, 7, 0.5) !important;
				opacity: 1 !important;
				visibility: visible !important;
				position: relative !important;
				z-index: 150 !important;
			}
			
			.bull-image-nav img {
				width: 100% !important;
				height: 100% !important;
				object-fit: contain !important;
				opacity: 1 !important;
				display: block !important;
				visibility: visible !important;
			}
			
			.bull-image-nav:hover {
				transform: scale(1.1);
				background: rgba(255, 193, 7, 0.4);
				border-color: rgba(255, 193, 7, 1);
				box-shadow: 0 0 25px rgba(255, 193, 7, 0.8);
			}
			
			/* Bull image inside Bitcoin dominance box */
			.bull-image-inline {
				width: 120px !important;
				height: 120px !important;
				cursor: pointer !important;
				transition: all 0.3s ease !important;
				border-radius: 12px !important;
				background: rgba(255, 193, 7, 0.3) !important;
				border: 3px solid #ffc107 !important;
				padding: 8px !important;
				display: inline-flex !important;
				align-items: center !important;
				justify-content: center !important;
				box-shadow: 0 0 20px rgba(255, 193, 7, 0.8) !important;
				opacity: 1 !important;
				visibility: visible !important;
				vertical-align: middle !important;
				margin-left: 15px !important;
			}
			
			.bull-image-inline img {
				width: 100% !important;
				height: 100% !important;
				object-fit: contain !important;
				opacity: 1 !important;
				display: block !important;
				visibility: visible !important;
			}
			
			.bull-image-inline:hover {
				transform: scale(1.1) !important;
				background: rgba(255, 193, 7, 0.5) !important;
				box-shadow: 0 0 30px rgba(255, 193, 7, 1) !important;
			}
			.signals-header h1 {
				color: var(--primary-color);
				font-size: 28px;
				text-align: center;
				font-weight: bold;
			}
			.signals-header p {
				color: rgba(255, 255, 255, 0.9);
				text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
			}
			
			/* Floating Right-Side Navigation */
			.floating-nav {
				position: fixed !important;
				right: 20px !important;
				top: 50% !important;
				transform: translateY(-50%) !important;
				z-index: 10000 !important;
				display: flex !important;
				flex-direction: column;
				gap: 12px;
				background: rgba(10, 14, 39, 0.3) !important;
				backdrop-filter: blur(5px);
				padding: 20px 15px;
				border-radius: 12px;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 255, 255, 0.1);
				border: 2px solid rgba(0, 255, 255, 0.2);
				visibility: visible !important;
				opacity: 1 !important;
				transition: all 0.3s ease;
			}
			
			/* Minimized state - hide menu content, show only toggle button */
			.floating-nav.minimized {
				padding: 8px !important;
				gap: 0 !important;
			}
			
			.floating-nav.minimized .floating-nav-content {
				display: none !important;
			}
			
			.floating-nav.minimized .floating-nav-close {
				display: none !important;
			}
			
			.floating-nav.minimized .floating-nav-toggle {
				display: flex !important;
			}
			
			/* Close/Minimize button */
			.floating-nav-close {
				position: absolute;
				top: 8px;
				right: 8px;
				width: 28px;
				height: 28px;
				background: rgba(255, 0, 0, 0.6) !important;
				border: 2px solid rgba(255, 0, 0, 0.8) !important;
				border-radius: 50%;
				color: #fff !important;
				font-size: 18px;
				font-weight: bold;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				line-height: 1;
				transition: all 0.3s ease;
				z-index: 10001;
				opacity: 0.8;
			}
			
			.floating-nav-close:hover {
				background: rgba(255, 0, 0, 0.9) !important;
				border-color: rgba(255, 0, 0, 1) !important;
				opacity: 1;
				transform: scale(1.1);
				box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
			}
			
			/* Toggle button to reopen minimized menu */
			.floating-nav-toggle {
				display: none;
				width: 40px;
				height: 40px;
				background: rgba(0, 255, 255, 0.3) !important;
				border: 2px solid rgba(0, 255, 255, 0.5) !important;
				border-radius: 8px;
				color: #fff !important;
				font-size: 20px;
				font-weight: bold;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.3s ease;
			}
			
			.floating-nav-toggle:hover {
				background: rgba(0, 255, 255, 0.5) !important;
				border-color: rgba(0, 255, 255, 0.8) !important;
				transform: scale(1.1);
				box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
			}
			
			.floating-nav-content {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			
			.floating-nav:hover {
				background: rgba(10, 14, 39, 0.95) !important;
				backdrop-filter: blur(10px);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 255, 0.3);
				border: 2px solid rgba(0, 255, 255, 0.5);
			}
			
			.floating-nav a {
				display: block;
				color: rgba(255, 255, 255, 0.6) !important;
				text-decoration: none;
				padding: 12px 20px;
				background: rgba(0, 255, 255, 0.1);
				border: 1px solid rgba(0, 255, 255, 0.2);
				border-radius: 8px;
				font-weight: bold;
				font-size: 14px;
				text-align: center;
				transition: all 0.3s ease;
				white-space: nowrap;
			}
			
			.floating-nav:hover a {
				color: #fff !important;
				background: rgba(0, 255, 255, 0.2);
				border-color: rgba(0, 255, 255, 0.4);
			}
			
			.floating-nav a:hover {
				background: rgba(0, 255, 255, 0.4) !important;
				border-color: rgba(0, 255, 255, 0.8) !important;
				transform: translateX(-5px);
				box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
				color: #fff !important;
			}
			
			.floating-nav .bull-nav-link {
				padding: 8px !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				min-height: 56px;
			}
			
			.floating-nav .bull-nav-link img {
				width: 40px !important;
				height: 40px !important;
				object-fit: contain !important;
				display: block !important;
				filter: brightness(0.9);
				transition: all 0.3s ease;
			}
			
			.floating-nav .bull-nav-link:hover img {
				filter: brightness(1.2);
				transform: scale(1.1);
			}
			
			/* Animated Subscribe Button - Applied to both nav and floating menu */
			.subscribe-nav-link,
			nav .subscribe-nav-link {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%) !important;
				background-size: 200% 200% !important;
				border: 2px solid rgba(255, 255, 255, 0.4) !important;
				box-shadow: 
					0 0 20px rgba(102, 126, 234, 0.6),
					0 0 40px rgba(118, 75, 162, 0.4),
					inset 0 0 20px rgba(255, 255, 255, 0.1) !important;
				animation: subscribeGradient 3s ease infinite, subscribePulse 2s ease-in-out infinite !important;
				position: relative;
				overflow: hidden;
				color: #fff !important;
				text-decoration: none !important;
			}
			
			.subscribe-nav-link::before,
			nav .subscribe-nav-link::before {
				content: '';
				position: absolute;
				top: -50%;
				left: -50%;
				width: 200%;
				height: 200%;
				background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
				animation: subscribeShimmer 3s infinite;
			}
			
			/* Hover behavior:
			   - floating menu: slide left a bit
			   - top nav: lift up slightly (avoid shifting the whole nav row) */
			.floating-nav .subscribe-nav-link:hover {
				transform: translateX(-5px) scale(1.05) !important;
				box-shadow: 
					0 0 30px rgba(102, 126, 234, 0.9),
					0 0 60px rgba(118, 75, 162, 0.6),
					0 0 80px rgba(240, 147, 251, 0.4),
					inset 0 0 30px rgba(255, 255, 255, 0.2) !important;
				border-color: rgba(255, 255, 255, 0.7) !important;
			}

			nav .subscribe-nav-link:hover {
				transform: translateY(-2px) scale(1.05) !important;
				box-shadow: 
					0 0 30px rgba(102, 126, 234, 0.9),
					0 0 60px rgba(118, 75, 162, 0.6),
					0 0 80px rgba(240, 147, 251, 0.4),
					inset 0 0 30px rgba(255, 255, 255, 0.2) !important;
				border-color: rgba(255, 255, 255, 0.7) !important;
			}
			
			
			@keyframes subscribeGradient {
				0% { background-position: 0% 50%; }
				50% { background-position: 100% 50%; }
				100% { background-position: 0% 50%; }
			}
			
			@keyframes subscribePulse {
				0%, 100% {
					box-shadow: 
						0 0 20px rgba(102, 126, 234, 0.6),
						0 0 40px rgba(118, 75, 162, 0.4),
						inset 0 0 20px rgba(255, 255, 255, 0.1);
				}
				50% {
					box-shadow: 
						0 0 30px rgba(102, 126, 234, 0.9),
						0 0 60px rgba(118, 75, 162, 0.6),
						0 0 80px rgba(240, 147, 251, 0.5),
						inset 0 0 30px rgba(255, 255, 255, 0.15);
				}
			}
			
			@keyframes subscribeShimmer {
				0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
				100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
			}
			
			/* Bull image with text */
			.floating-nav .bull-nav-link {
				padding: 12px 16px !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				gap: 10px !important;
				min-height: 56px;
				flex-direction: row !important;
			}
			
			.floating-nav .bull-nav-link .bull-text {
				color: rgba(255, 255, 255, 0.7) !important;
				font-size: 12px !important;
				font-weight: bold !important;
				white-space: nowrap !important;
				transition: all 0.3s ease;
			}
			
			.floating-nav:hover .bull-nav-link .bull-text {
				color: #fff !important;
			}
			
			@media (max-width: 768px) {
				.floating-nav {
					right: 10px;
					padding: 15px 10px;
				}
				.floating-nav.minimized {
					padding: 6px !important;
				}
				.floating-nav a {
					padding: 10px 15px;
					font-size: 12px;
				}
				.floating-nav .bull-nav-link {
					flex-direction: column !important;
					gap: 6px !important;
					padding: 10px 12px !important;
				}
				.floating-nav .bull-nav-link .bull-text {
					font-size: 10px !important;
					text-align: center;
				}
				.floating-nav-close {
					width: 24px;
					height: 24px;
					font-size: 16px;
					top: 6px;
					right: 6px;
				}
				.floating-nav-toggle {
					width: 36px;
					height: 36px;
					font-size: 18px;
				}
			}
			.status-indicator {
				display: inline-block;
				width: 12px;
				height: 12px;
				border-radius: 50%;
				margin-right: 8px;
				animation: pulse 2s infinite;
			}
			.status-indicator.active {
				background-color: #00ff88;
				box-shadow: 0 0 10px rgba(0, 255, 136, 0.8), 0 0 20px rgba(0, 255, 136, 0.4);
			}
			.status-indicator.inactive {
				background-color: #ff0080;
				box-shadow: 0 0 10px rgba(255, 0, 128, 0.8), 0 0 20px rgba(255, 0, 128, 0.4);
			}
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: 0.5; }
			}
			.signals-grid {
				display: grid !important;
				grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
				gap: 20px;
				margin-top: 20px;
				visibility: visible !important;
				opacity: 1 !important;
				min-height: 200px;
			}
			
			/* Mobile responsive styles */
			@media (max-width: 768px) {
				/* Navigation - stack vertically on mobile */
				nav {
					padding: 15px 0 !important;
					transition: padding 0.3s ease, font-size 0.3s ease;
				}
				
				/* When scrolled on mobile - make nav MUCH smaller */
				nav.scrolled {
					padding: 5px 0 !important;
				}
				
				nav .content {
					display: flex !important;
					flex-direction: column !important;
					align-items: center !important;
					gap: 10px !important;
					padding: 10px 0 !important;
					transition: gap 0.3s ease;
				}
				
				/* When scrolled - reduce gap between nav items */
				nav.scrolled .content {
					gap: 3px !important;
					padding: 0 !important;
				}
				
				nav a {
					margin: 5px 0 !important;
					font-size: 0.9em !important;
					padding: 8px !important;
					display: block !important;
					transition: font-size 0.3s ease, padding 0.3s ease, margin 0.3s ease;
				}
				
				/* When scrolled - make nav links much smaller */
				nav.scrolled a {
					font-size: 0.7em !important;
					padding: 3px 8px !important;
					margin: 2px 0 !important;
					line-height: 1.2 !important;
				}
				
				/* Content adjustments */
				.content {
					width: 100% !important;
					padding: 0 15px !important;
				}
				
				.signals-container {
					margin-top: 120px !important;
					padding: 15px !important;
				}
				
				/* Signals grid - single column on mobile */
				.signals-grid {
					grid-template-columns: 1fr !important;
					gap: 15px !important;
				}
				
				.signal-card {
					margin: 0 !important;
					padding: 15px !important;
				}
				
				.signal-symbol {
					font-size: 20px !important;
				}
				
				.signal-action {
					font-size: 14px !important;
					padding: 4px 10px !important;
				}
				
				/* Live signals navigation - stack vertically */
				#live-signals-nav {
					flex-direction: column !important;
					gap: 15px !important;
					padding: 15px !important;
				}
				
				#live-signals-nav button {
					width: 100% !important;
					padding: 12px !important;
					text-align: center !important;
					font-size: 14px !important;
				}
				
				/* Page navigation buttons - stack vertically */
				#page-navigation {
					flex-direction: column !important;
					gap: 10px !important;
					padding: 15px !important;
				}
				
				#page-navigation a {
					width: 100% !important;
					padding: 12px !important;
					text-align: center !important;
				}
				
				/* Headings */
				h1 {
					font-size: 1.8em !important;
				}
				
				h2 {
					font-size: 1.5em !important;
				}
				
				/* Disclaimer modal - full width on mobile */
				.disclaimer-modal {
					max-width: 95% !important;
					padding: 20px !important;
					max-height: 90vh !important;
				}
				
				.disclaimer-modal h2 {
					font-size: 20px !important;
				}
				
				.disclaimer-content {
					font-size: 14px !important;
					line-height: 1.6 !important;
				}
				
				/* Indicator sections */
				.indicators-section {
					padding: 20px 15px !important;
				}
				
				.indicators-header h2 {
					font-size: 24px !important;
				}
				
				.indicator-category {
					padding: 15px !important;
				}
				
				.indicator-category h3 {
					font-size: 20px !important;
				}
				
				/* Summary stats grid - single column */
				.summary-stats ul {
					grid-template-columns: 1fr !important;
				}
				
				/* Asset list grid - single column on mobile */
				.asset-list-grid {
					grid-template-columns: 1fr !important;
					gap: 12px !important;
				}
				
				.asset-list-item {
					padding: 15px !important;
					flex-direction: column !important;
					align-items: flex-start !important;
					gap: 10px !important;
				}
				
				.asset-signal {
					align-items: flex-start !important;
					width: 100%;
				}
				
				/* Backtest image - responsive */
				.backtest-section img {
					width: 100% !important;
					height: auto !important;
				}
			}
			
			/* Tablet adjustments */
			@media (min-width: 769px) and (max-width: 1024px) {
				.signals-grid {
					grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)) !important;
				}
				
				#page-navigation {
					flex-wrap: wrap !important;
				}
				
				#page-navigation a {
					flex: 1 1 calc(50% - 10px) !important;
				}
			}
			.signal-card {
				background: rgba(10, 14, 39, 0.6) !important;
				border: 2px solid rgba(0, 255, 255, 0.3) !important;
				border-radius: 8px;
				padding: 20px;
				transition: all 0.3s ease;
				animation: fadeInUp 0.5s ease;
				display: block !important;
				visibility: visible !important;
				opacity: 1 !important;
				color: #ffffff !important;
				margin: 10px;
				/* Synthwave glass effect */
				background-color: rgba(10, 14, 39, 0.7) !important;
				backdrop-filter: blur(8px);
				box-shadow: 
					0 0 10px rgba(0, 255, 255, 0.2),
					0 0 20px rgba(255, 0, 255, 0.1),
					inset 0 0 20px rgba(0, 255, 255, 0.05);
				/* Elevate above any overlays */
				position: relative;
				z-index: 1;
				/* Prevent any accidental hiding */
				mix-blend-mode: normal !important;
				pointer-events: auto !important;
			}
			.signal-card:hover {
				transform: translateY(-5px);
				box-shadow: 
					0 0 20px rgba(0, 255, 255, 0.4),
					0 0 40px rgba(255, 0, 255, 0.3),
					0 8px 32px rgba(0, 0, 0, 0.5);
				border-color: rgba(0, 255, 255, 0.6);
			}
			.signal-card.buy {
				border-left: 4px solid #00ff88;
				box-shadow: 
					0 0 10px rgba(0, 255, 136, 0.3),
					0 0 20px rgba(0, 255, 136, 0.2),
					inset 0 0 20px rgba(0, 255, 136, 0.05);
			}
			.signal-card.buy:hover {
				border-left-color: #00ff88;
				box-shadow: 
					0 0 20px rgba(0, 255, 136, 0.5),
					0 0 40px rgba(0, 255, 136, 0.3),
					0 8px 32px rgba(0, 0, 0, 0.5);
			}
			.signal-card.sell {
				border-left: 4px solid #ff0080;
				box-shadow: 
					0 0 10px rgba(255, 0, 128, 0.3),
					0 0 20px rgba(255, 0, 128, 0.2),
					inset 0 0 20px rgba(255, 0, 128, 0.05);
			}
			.signal-card.sell:hover {
				border-left-color: #ff0080;
				box-shadow: 
					0 0 20px rgba(255, 0, 128, 0.5),
					0 0 40px rgba(255, 0, 128, 0.3),
					0 8px 32px rgba(0, 0, 0, 0.5);
			}
			.confluence-badge {
				display: inline-block;
				padding: 5px 10px;
				border-radius: 6px;
				font-size: 11px;
				font-weight: bold;
				margin-left: 8px;
			}
			.confluence-pure {
				background-color: rgba(0, 255, 255, 0.25);
				color: #00ffff;
				border: 1px solid rgba(0, 255, 255, 0.5);
				text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
				box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
			}
			.confluence-ema {
				background-color: rgba(255, 165, 0, 0.25);
				color: #ffa500;
				border: 1px solid rgba(255, 165, 0, 0.5);
				text-shadow: 0 0 8px rgba(255, 165, 0, 0.8);
				box-shadow: 0 0 10px rgba(255, 165, 0, 0.3);
			}
			.confluence-hmm {
				background-color: rgba(255, 0, 255, 0.25);
				color: #ff00ff;
				border: 1px solid rgba(255, 0, 255, 0.5);
				text-shadow: 0 0 8px rgba(255, 0, 255, 0.8);
				box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
			}
			.confluence-extreme {
				background-color: rgba(255, 0, 128, 0.35);
				color: #ff0080;
				border: 1px solid rgba(255, 0, 128, 0.6);
				text-shadow: 0 0 10px rgba(255, 0, 128, 1), 0 0 20px rgba(255, 0, 128, 0.6);
				box-shadow: 0 0 15px rgba(255, 0, 128, 0.5);
			}
			.note-highlight {
				font-weight: 600;
				color: #fff !important;
				margin-top: 10px;
				padding: 8px;
				background: rgba(255, 255, 255, 0.08);
				border-radius: 4px;
				border-left: 3px solid rgba(255,255,255,0.6);
			}
			.signal-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 15px;
			}
			.signal-header > div {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			.signal-action {
				font-size: 18px;
				font-weight: bold;
				text-transform: uppercase;
				padding: 5px 15px;
				border-radius: 4px;
			}
			.signal-action.buy {
				background-color: rgba(0, 255, 136, 0.2);
				color: #00ff88;
				text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
				border: 1px solid rgba(0, 255, 136, 0.4);
			}
			.signal-action.sell {
				background-color: rgba(255, 0, 128, 0.2);
				color: #ff0080;
				text-shadow: 0 0 10px rgba(255, 0, 128, 0.8);
				border: 1px solid rgba(255, 0, 128, 0.4);
			}
			.signal-symbol {
				font-size: 24px;
				font-weight: bold;
				color: #ffffff !important; /* force visible on dark bg */
			}
			.signal-details {
				margin-top: 15px;
			}
			.signal-detail-row {
				display: flex;
				justify-content: space-between;
				padding: 8px 0;
				border-bottom: 1px solid rgba(255, 255, 255, 0.1);
			}
			.signal-detail-row:last-child {
				border-bottom: none;
			}
			.signal-detail-label {
				color: rgba(255, 255, 255, 0.85) !important; /* more visible */
				font-size: 14px;
			}
			.signal-detail-value {
				color: #ffffff !important;
				font-weight: 600;
			}
			.signal-timestamp {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.75) !important;
				margin-top: 10px;
			}
			.empty-state {
				text-align: center;
				padding: 60px 20px;
				color: rgba(255, 255, 255, 0.6);
			}
			.refresh-info {
				text-align: center;
				margin-top: 5px;
				margin-bottom: 5px;
				color: rgba(255, 255, 255, 0.5);
				font-size: 14px;
			}
			.loading {
				text-align: center;
				padding: 40px;
				color: rgba(255, 255, 255, 0.6) !important;
				visibility: visible !important;
				display: block !important;
			}
			.empty-state {
				text-align: center;
				padding: 60px 20px;
				color: rgba(255, 255, 255, 0.6) !important;
				visibility: visible !important;
				display: block !important;
			}
			.disclaimer-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.95);
				z-index: 10000;
				display: flex;
				justify-content: center;
				align-items: center;
				padding: 20px;
			}
			.disclaimer-modal {
				background: var(--bg-color);
				border: 2px solid var(--primary-color);
				border-radius: 12px;
				padding: 30px;
				max-width: 700px;
				max-height: 80vh;
				overflow-y: auto;
				box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
			}
			.disclaimer-modal h2 {
				color: var(--primary-color);
				margin-top: 0;
				margin-bottom: 20px;
				text-align: center;
				font-size: 24px;
			}
			.disclaimer-content {
				color: rgba(255, 255, 255, 0.9);
				line-height: 1.8;
				margin-bottom: 25px;
			}
			.disclaimer-content p {
				margin-bottom: 15px;
			}
			.disclaimer-content strong {
				color: var(--primary-color);
				font-weight: bold;
			}
			.disclaimer-content ul {
				margin-left: 20px;
				margin-bottom: 15px;
			}
			.disclaimer-content li {
				margin-bottom: 10px;
			}
			.disclaimer-warning {
				background: rgba(244, 67, 54, 0.2);
				border-left: 4px solid #f44336;
				padding: 15px;
				margin: 20px 0;
				border-radius: 4px;
			}
			.disclaimer-accept {
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 12px;
				margin: 25px 0;
			}
			.disclaimer-checkbox {
				width: 20px;
				height: 20px;
				cursor: pointer;
			}
			.disclaimer-checkbox-label {
				color: rgba(255, 255, 255, 0.9);
				cursor: pointer;
				user-select: none;
			}
			.disclaimer-button {
				width: 100%;
				padding: 15px;
				background: var(--primary-color);
				color: var(--bg-color);
				border: none;
				border-radius: 6px;
				font-size: 16px;
				font-weight: bold;
				cursor: pointer;
				transition: all 0.3s ease;
				opacity: 0.5;
				pointer-events: none;
			}
			.disclaimer-button:enabled {
				opacity: 1;
				pointer-events: auto;
			}
			.disclaimer-button:enabled:hover {
				background: #d4b896;
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(241, 207, 171, 0.4);
			}
			.disclaimer-hidden {
				display: none !important;
			}
			#page-navigation {
				display: flex !important;
				visibility: visible !important;
				opacity: 1 !important;
			}
			#page-navigation a {
				display: inline-block !important;
				visibility: visible !important;
				opacity: 1 !important;
				color: #fff !important;
			}
			.indicators-section {
				margin-top: 60px;
				padding: 40px 20px;
				background: rgba(0, 0, 0, 0.3);
				border-radius: 12px;
				border: 1px solid rgba(255, 255, 255, 0.1);
				display: block !important;
				visibility: visible !important;
				opacity: 1 !important;
			}
			.indicators-header {
				text-align: center;
				margin-bottom: 40px;
			}
			.indicators-header h2 {
				color: #00ffff;
				font-size: 32px;
				margin-bottom: 10px;
				text-shadow: 
					0 0 10px rgba(0, 255, 255, 0.8),
					0 0 20px rgba(0, 255, 255, 0.6),
					0 0 30px rgba(0, 255, 255, 0.4);
			}
			.indicators-header p {
				color: rgba(255, 255, 255, 0.7);
				font-size: 16px;
				max-width: 800px;
				margin: 0 auto;
			}
			.indicators-content {
				max-width: 1200px;
				margin: 0 auto;
			}
			.indicator-category {
				margin-bottom: 40px;
				background: rgba(255, 255, 255, 0.03);
				border-radius: 8px;
				padding: 25px;
				border-left: 4px solid var(--primary-color);
			}
			.indicator-category h3 {
				color: #00ffff;
				font-size: 24px;
				margin-bottom: 20px;
				border-bottom: 2px solid rgba(0, 255, 255, 0.4);
				padding-bottom: 10px;
				text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
			}
			.indicator-category h4 {
				color: rgba(255, 255, 255, 0.9);
				font-size: 18px;
				margin-top: 20px;
				margin-bottom: 12px;
			}
			.indicator-category ul {
				list-style: none;
				padding-left: 0;
				margin: 0;
			}
			.indicator-category li {
				color: rgba(255, 255, 255, 0.8);
				padding: 8px 0;
				padding-left: 20px;
				position: relative;
				line-height: 1.6;
			}
			.indicator-category li:before {
				content: "‚ñ∏";
				position: absolute;
				left: 0;
				color: var(--primary-color);
			}
			.indicator-category strong {
				color: var(--primary-color);
				font-weight: bold;
			}
			.summary-stats {
				background: rgba(241, 207, 171, 0.1);
				border: 2px solid var(--primary-color);
				border-radius: 8px;
				padding: 30px;
				margin-top: 40px;
				text-align: center;
			}
			.summary-stats h3 {
				color: #00ffff;
				font-size: 28px;
				margin-bottom: 20px;
				text-shadow: 
					0 0 10px rgba(0, 255, 255, 0.8),
					0 0 20px rgba(0, 255, 255, 0.6);
			}
			.summary-stats ul {
				list-style: none;
				padding: 0;
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 15px;
				margin: 20px 0;
			}
			.summary-stats li {
				color: rgba(255, 255, 255, 0.9);
				font-size: 16px;
				padding: 10px;
				background: rgba(0, 0, 0, 0.2);
				border-radius: 4px;
			}
			.philosophy-box {
				background: rgba(76, 175, 80, 0.1);
				border-left: 4px solid #4caf50;
				padding: 25px;
				margin-top: 30px;
				border-radius: 4px;
			}
			.philosophy-box h4 {
				color: #4caf50;
				margin-top: 0;
				margin-bottom: 15px;
			}
			.philosophy-box ol {
				margin-left: 20px;
				color: rgba(255, 255, 255, 0.9);
			}
			.philosophy-box li {
				margin-bottom: 10px;
				line-height: 1.6;
			}
			.asset-list-item {
				background: rgba(10, 14, 39, 0.6);
				border: 2px solid rgba(0, 255, 255, 0.3);
				border-radius: 8px;
				padding: 20px;
				transition: all 0.3s ease;
				display: flex;
				justify-content: space-between;
				align-items: center;
				backdrop-filter: blur(8px);
				box-shadow: 
					0 0 10px rgba(0, 255, 255, 0.2),
					inset 0 0 20px rgba(0, 255, 255, 0.05);
			}
			.asset-list-item:hover {
				transform: translateY(-3px);
				box-shadow: 
					0 0 20px rgba(0, 255, 255, 0.4),
					0 0 40px rgba(255, 0, 255, 0.2),
					0 6px 20px rgba(0, 0, 0, 0.5);
				border-color: rgba(0, 255, 255, 0.6);
			}
			.asset-list-item.buy {
				border-left: 4px solid #00ff88;
				box-shadow: 
					0 0 10px rgba(0, 255, 136, 0.3),
					inset 0 0 20px rgba(0, 255, 136, 0.05);
			}
			.asset-list-item.sell {
				border-left: 4px solid #ff0080;
				box-shadow: 
					0 0 10px rgba(255, 0, 128, 0.3),
					inset 0 0 20px rgba(255, 0, 128, 0.05);
			}
			.asset-name {
				font-size: 20px;
				font-weight: bold;
				color: #00ffff;
				text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
			}
			.asset-signal {
				display: flex;
				flex-direction: column;
				align-items: flex-end;
				gap: 5px;
			}
			.asset-signal-action {
				font-size: 16px;
				font-weight: bold;
				text-transform: uppercase;
				padding: 6px 12px;
				border-radius: 4px;
			}
			.asset-signal-action.buy {
				background-color: rgba(0, 255, 136, 0.2);
				color: #00ff88;
				text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
				border: 1px solid rgba(0, 255, 136, 0.4);
			}
			.asset-signal-action.sell {
				background-color: rgba(255, 0, 128, 0.2);
				color: #ff0080;
				text-shadow: 0 0 10px rgba(255, 0, 128, 0.8);
				border: 1px solid rgba(255, 0, 128, 0.4);
			}
			.asset-signal-time {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.5);
			}
			.asset-signal-price {
				font-size: 14px;
				color: rgba(255, 255, 255, 0.7);
			}
			.subscribe-button {
				background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
				color: #fff;
				border: 2px solid rgba(255, 255, 255, 0.3);
				padding: 12px 24px;
				border-radius: 6px;
				font-weight: bold;
				font-size: 16px;
				cursor: pointer;
				transition: all 0.3s ease;
				box-shadow: 
					0 0 15px rgba(255, 0, 255, 0.5),
					0 0 30px rgba(0, 255, 255, 0.3),
					0 4px 12px rgba(0, 0, 0, 0.4);
				text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
			}
			.subscribe-button:hover {
				transform: translateY(-2px);
				box-shadow: 
					0 0 25px rgba(255, 0, 255, 0.7),
					0 0 50px rgba(0, 255, 255, 0.5),
					0 6px 20px rgba(0, 0, 0, 0.5);
				border-color: rgba(255, 255, 255, 0.6);
			}
			.subscribe-button:disabled {
				opacity: 0.6;
				cursor: not-allowed;
				transform: none;
			}
			
			/* Signal status indicators for asset list */
			.asset-signal-status {
				display: inline-block;
				margin-left: 12px;
				padding: 4px 10px;
				border-radius: 6px;
				font-size: 12px;
				font-weight: bold;
				text-transform: uppercase;
				letter-spacing: 0.5px;
				transition: all 0.3s ease;
			}
			
			.asset-signal-status.buy {
				background: rgba(76, 175, 80, 0.2);
				border: 1px solid rgba(76, 175, 80, 0.6);
				color: #4caf50;
				box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
			}
			
			.asset-signal-status.sell {
				background: rgba(244, 67, 54, 0.2);
				border: 1px solid rgba(244, 67, 54, 0.6);
				color: #f44336;
				box-shadow: 0 0 8px rgba(244, 67, 54, 0.4);
			}
			
			.asset-signal-status.neutral {
				background: rgba(158, 158, 158, 0.2);
				border: 1px solid rgba(158, 158, 158, 0.6);
				color: #9e9e9e;
				box-shadow: 0 0 8px rgba(158, 158, 158, 0.3);
			}
			
			.asset-signal-status.locked {
				background: rgba(102, 126, 234, 0.2);
				border: 1px solid rgba(102, 126, 234, 0.6);
				color: #667eea;
			}
			
			.asset-signal-status .time-ago {
				font-size: 10px;
				opacity: 0.8;
				margin-left: 4px;
				text-transform: none;
			}
			
			.asset-signal-status .subscribe-mini-btn {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				border: none;
				padding: 4px 10px;
				border-radius: 4px;
				font-size: 11px;
				font-weight: bold;
				cursor: pointer;
				text-decoration: none;
				display: inline-block;
				transition: all 0.3s ease;
			}
			
			.asset-signal-status .subscribe-mini-btn:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
			}
			
			.subscription-badge {
				display: inline-block;
				padding: 4px 12px;
				background: rgba(76, 175, 80, 0.2);
				color: #4caf50;
				border: 1px solid #4caf50;
				border-radius: 12px;
				font-size: 12px;
				font-weight: bold;
				margin-left: 10px;
			}
			.subscription-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.95);
				z-index: 10001;
				display: none;
				justify-content: center;
				align-items: center;
				padding: 20px;
			}
			.subscription-modal-content {
				background: var(--bg-color);
				border: 2px solid var(--primary-color);
				border-radius: 12px;
				padding: 40px;
				max-width: 500px;
				text-align: center;
				box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
			}
			.subscription-modal-content h2 {
				color: var(--primary-color);
				margin-top: 0;
				margin-bottom: 20px;
				font-size: 28px;
			}
			.subscription-modal-content p {
				color: rgba(255, 255, 255, 0.9);
				line-height: 1.8;
				margin-bottom: 15px;
			}
			.subscription-features {
				text-align: left;
				margin: 25px 0;
				padding: 20px;
				background: rgba(255, 255, 255, 0.05);
				border-radius: 8px;
			}
			.subscription-features ul {
				list-style: none;
				padding: 0;
				margin: 0;
			}
			.subscription-features li {
				color: rgba(255, 255, 255, 0.9);
				padding: 8px 0;
				padding-left: 25px;
				position: relative;
			}
			.subscription-features li:before {
				content: "‚úì";
				position: absolute;
				left: 0;
				color: #4caf50;
				font-weight: bold;
				font-size: 18px;
			}
			.subscription-pricing {
				background: rgba(76, 175, 80, 0.1);
				border: 2px solid #4caf50;
				border-radius: 8px;
				padding: 20px;
				margin: 25px 0;
			}
			.subscription-pricing .price {
				font-size: 36px;
				font-weight: bold;
				color: #4caf50;
				margin: 10px 0;
			}
			.subscription-pricing .trial {
				color: rgba(255, 255, 255, 0.8);
				font-size: 14px;
				margin-top: 10px;
			}

			/* --- Hard overrides to ensure signals are visible --- */
			.signals-container {
				display: block !important;
				visibility: visible !important;
				opacity: 1 !important;
			}
			
			#bitcoin-dominance-section {
				display: block !important;
				visibility: visible !important;
				opacity: 1 !important;
				pointer-events: auto !important;
				z-index: 200 !important;
				position: relative !important;
				background: rgba(247, 147, 26, 0.3) !important;
				border: 3px solid rgba(247, 147, 26, 1) !important;
				min-height: 600px !important;
				margin: 30px 0 !important;
				padding: 25px !important;
			}
			
			#bitcoin-dominance-section * {
				opacity: 1 !important;
				visibility: visible !important;
			}
			
			#bitcoin-dominance-section h3,
			#bitcoin-dominance-section div {
				color: rgba(255, 255, 255, 1) !important;
			}
			
			#crypto-signals-container,
			#stock-signals-container,
			#signals-grid,
			#stock-signals-grid,
			#old-signals-grid,
			#stock-historical-grid,
			.asset-list-grid {
				visibility: visible !important;
				opacity: 1 !important;
				display: grid !important;
				pointer-events: auto !important;
				z-index: 1;
			}

			/* If a grid is meant to be hidden by JS, JS will set display:none explicitly */
			.signal-card,
			.signal-card * {
				color: #ffffff !important;
				opacity: 1 !important;
				mix-blend-mode: normal !important;
				text-shadow: 0 0 1px rgba(0,0,0,0.4);
			}

			.signal-card {
				background-color: rgba(20, 20, 20, 0.8) !important;
				backdrop-filter: blur(2px);
				position: relative;
				z-index: 2;
			}
		</style>
	</head>
	<body>
		<!-- Disclaimer Modal -->
		<div id="disclaimer-overlay" class="disclaimer-overlay">
			<div class="disclaimer-modal">
				<h2>‚ö†Ô∏è Important Disclaimer</h2>
				<div class="disclaimer-content">
					<div class="disclaimer-warning">
						<strong>NOT FINANCIAL ADVICE:</strong> I am not a certified financial advisor, registered investment advisor, or licensed financial professional. The trading signals displayed on this website are for informational and educational purposes only.
					</div>
					
					<p><strong>Seek Professional Advice:</strong> Before making any investment decisions, you should consult with a qualified financial advisor, accountant, or other professional who can provide advice tailored to your individual circumstances.</p>
					
					<p><strong>Cryptocurrency Volatility:</strong> Cryptocurrencies are among the most volatile assets in the world. Prices can experience extreme fluctuations and may decline by 99% or more. You could lose your entire investment.</p>
					
					<p><strong>SEC & CFTC Disclaimers:</strong></p>
					<ul>
						<li>Past performance does not guarantee future results.</li>
						<li>All investments carry risk of loss, including the potential loss of principal.</li>
						<li>Cryptocurrency markets are largely unregulated and may be subject to manipulation.</li>
						<li>Trading cryptocurrencies involves substantial risk of loss and is not suitable for all investors.</li>
						<li>You should only invest money you can afford to lose.</li>
					</ul>
					
					<p><strong>Risk Management:</strong> Manage your risk accordingly. Never invest more than you can afford to lose. Use proper position sizing, stop-loss orders, and risk management techniques.</p>
					
					<div class="disclaimer-warning">
						<strong>Security Warnings:</strong>
						<ul>
							<li><strong>Hold Your Own Keys:</strong> Always maintain control of your private keys and seed phrases. Never share them with anyone, including this website or any service.</li>
							<li><strong>Website Permissions:</strong> Be extremely careful when granting websites or applications permission to access your cryptocurrency wallets or funds. Only connect to trusted, verified services.</li>
							<li><strong>Phishing Scams:</strong> Be vigilant against phishing scams. Always verify website URLs, never click suspicious links, and never enter your private keys or seed phrases on any website.</li>
							<li><strong>No Liability:</strong> This website and its operators are not responsible for any losses, damages, or security breaches that may occur from using the information displayed here.</li>
						</ul>
					</div>
					
					<p><strong>No Guarantees:</strong> Trading signals are not guarantees of profit. Market conditions can change rapidly, and past signals do not predict future performance.</p>
				</div>
				
				<div class="disclaimer-accept">
					<input type="checkbox" id="disclaimer-checkbox" class="disclaimer-checkbox">
					<label for="disclaimer-checkbox" class="disclaimer-checkbox-label">
						I have read and understand the risks. I agree that I am solely responsible for my investment decisions and will not hold this website or its operators liable for any losses.
					</label>
				</div>
				
				<button id="disclaimer-accept-btn" class="disclaimer-button" disabled>
					Accept & Continue
				</button>
			</div>
		</div>
		
		<!-- Subscription Modal -->
		<div id="subscription-modal" class="subscription-modal">
			<div class="subscription-modal-content">
				<h2>üöÄ Premium Trading Signals</h2>
				<p>Get unlimited access to all trading signals with our premium subscription.</p>
				
				<div class="subscription-pricing">
					<div class="price">$9.99<span style="font-size: 16px; color: rgba(255, 255, 255, 0.7); display: block; margin-top: 4px; font-weight: normal;">One-Time Payment</span><span style="font-size: 14px; color: rgba(255, 193, 7, 0.9); display: block; margin-top: 4px; font-weight: bold;">‚ö†Ô∏è Limited Time Offer</span></div>
					<div class="trial">‚ú® 7-Day Free Trial ‚Ä¢ No Credit Card Required</div>
				</div>
				
				<div class="subscription-features">
					<ul>
						<li>Unlimited access to all trading signals</li>
						<li>Real-time crypto and stock signals</li>
						<li>Historical signal analysis</li>
						<li>Asset list with latest signals</li>
						<li>Priority support</li>
					</ul>
				</div>
				
				<button id="start-subscription-btn" class="subscribe-button" onclick="startSubscription()">
					Start 7-Day Free Trial
				</button>
				<a
					id="pay-with-crypto-btn"
					href="#"
					class="subscribe-button"
					onclick="event.preventDefault(); startCryptoPayment(); return false;"
					style="display: inline-block; margin-top: 12px; background: linear-gradient(135deg, rgba(0, 200, 120, 0.90) 0%, rgba(0, 140, 255, 0.90) 100%); border: 2px solid rgba(255, 255, 255, 0.55); text-decoration: none;"
					onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 0 25px rgba(0, 200, 120, 0.55), 0 0 45px rgba(0, 140, 255, 0.35), 0 6px 20px rgba(0, 0, 0, 0.5)'; this.style.borderColor='rgba(255, 255, 255, 0.75)';"
					onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 0 15px rgba(0, 200, 120, 0.35), 0 0 30px rgba(0, 140, 255, 0.25), 0 4px 12px rgba(0, 0, 0, 0.4)'; this.style.borderColor='rgba(255, 255, 255, 0.55)';"
				>
					‚Çø Pay with Crypto (Coinbase)
				</a>
				<button onclick="closeSubscriptionModal()" style="background: transparent; border: 1px solid rgba(255, 255, 255, 0.3); color: rgba(255, 255, 255, 0.7); padding: 10px 20px; border-radius: 6px; margin-top: 15px; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.borderColor='rgba(255, 255, 255, 0.5)'; this.style.color='#fff';" onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.3)'; this.style.color='rgba(255, 255, 255, 0.7)';">
					Maybe Later
				</button>
				<div id="subscription-error" style="color: #f44336; margin-top: 15px; display: none;"></div>
			</div>
		</div>
		
		<nav>
			<div id="backing"></div>
			<div class="content">
				<a href="index.html">HOME</a>
				<a href="catalog.html">üéµ CATALOG</a>
				<a href="signals.html">üöÄ Crypto Signals</a>
				<a href="#" onclick="event.preventDefault(); showStockSignals(); return false;">üìà Stock Signals</a>
				<a href="#" onclick="event.preventDefault(); showHistoricalSignals(); return false;">üìú Historical Signals</a>
				<a href="#" onclick="event.preventDefault(); showSubscriptionModal(); return false;" class="subscribe-nav-link" style="border-radius: 6px; padding: 8px 16px; margin-left: 10px;">
					üí≥ Subscribe
				</a>
			</div>
		</nav>
		
		<!-- Floating Right-Side Navigation -->
		<div class="floating-nav" id="floating-nav">
			<button class="floating-nav-close" onclick="toggleFloatingNav()" title="Minimize menu" aria-label="Minimize menu">√ó</button>
			<button class="floating-nav-toggle" onclick="toggleFloatingNav()" title="Show menu" aria-label="Show menu">‚ò∞</button>
			<div class="floating-nav-content">
				<a href="#" onclick="event.preventDefault(); switchToCrypto(); return false;">üöÄ Crypto</a>
				<a href="#" onclick="event.preventDefault(); showStockSignals(); return false;">üìà Stocks</a>
				<a href="#" onclick="event.preventDefault(); showHistoricalSignals(); return false;">üìú Historical</a>
				<a href="#asset-list" onclick="event.preventDefault(); showAssetList(); return false;">üìã Assets</a>
				<a href="#" onclick="event.preventDefault(); showSubscriptionModal(); return false;" class="subscribe-nav-link">üí≥ Subscribe</a>
				<a href="#" onclick="event.preventDefault(); toggleBullAudio(); return false;" class="bull-nav-link" title="Click to play music">
					<img src="img/Angry Bull 3.png" alt="Click to play music" />
					<span class="bull-text">Get Pumped for the Pump!</span>
				</a>
			</div>
		</div>
		
		<div class="content signals-container" id="signals-content">
			<!-- Trial Status Banner -->
			<div id="trial-status-banner" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(33, 150, 243, 0.2) 100%); border: 2px solid rgba(76, 175, 80, 0.5); border-radius: 12px; padding: 20px; margin-bottom: 30px; text-align: center;">
				<div id="trial-status-message" style="color: #fff; font-size: 16px; font-weight: bold; line-height: 1.6;">
					<!-- Will be populated by JavaScript -->
				</div>
			</div>
			<!-- Email capture (non-blocking, freemium) -->
			<div id="email-capture-banner" style="display: none; background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%); border: 2px solid rgba(255, 193, 7, 0.6); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
				<div style="color: #fff; font-weight: bold; margin-bottom: 8px;">Stay in the loop</div>
				<div style="color: rgba(255,255,255,0.85); font-size: 14px; margin-bottom: 8px;">Enter your email so we can keep your trial consistent across devices.</div>
				<div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
					<input id="email-capture-input" type="email" placeholder="you@example.com" style="flex: 1 1 240px; min-width: 180px; padding: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.4); color: #fff;" />
					<button id="email-capture-btn" class="subscribe-button" style="padding: 10px 18px;">Save Email</button>
				</div>
				<div id="email-capture-status" style="color: #4caf50; font-size: 13px; margin-top: 6px; display: none;"></div>
			</div>
			
			<div class="signals-header">
				<h1>üöÄ Crypto Signals</h1>
				<p>Live feed of buy and sell signals from trading strategies</p>
				<div style="margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 12px; flex-wrap: wrap;">
					<span class="status-indicator active" id="status-indicator"></span>
					<span id="status-text">Connected</span>
					<span style="margin-left: 20px;" id="last-update"></span>
					<button id="refresh-prices-btn" onclick="manualRefreshPrices(); return false;" style="background: rgba(255, 255, 255, 0.10); border: 1px solid rgba(255, 255, 255, 0.5); color: #fff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 700; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.16)'; this.style.transform='translateY(-1px)';" onmouseout="this.style.background='rgba(255,255,255,0.10)'; this.style.transform='translateY(0)';" title="Force refresh prices (cached prices still show immediately)">üîÑ Refresh Prices</button>
					<span id="price-refresh-status" style="color: rgba(255, 255, 255, 0.6); font-size: 13px;"></span>
				</div>
			</div>
			
			<!-- Bull Image Above Navigation -->
			<div style="text-align: center; margin: 30px 0 20px; position: relative; z-index: 150;">
				<div class="bull-image-nav" id="bull-image-nav" title="Click to play music" style="display: inline-block !important; width: 100px !important; height: 100px !important; cursor: pointer !important; transition: all 0.3s ease !important; border-radius: 12px !important; background: rgba(255, 193, 7, 0.2) !important; border: 2px solid rgba(255, 193, 7, 0.6) !important; padding: 8px !important; box-shadow: 0 0 15px rgba(255, 193, 7, 0.5) !important; opacity: 1 !important; visibility: visible !important; position: relative !important; z-index: 150 !important;">
					<img src="img/Angry Bull 3.png" alt="Angry Bull - Click to play music" style="opacity: 1 !important; display: block !important; width: 100% !important; height: 100% !important; object-fit: contain !important; visibility: visible !important;" />
				</div>
			</div>
			
			<!-- Page Navigation -->
			<div id="page-navigation" style="display: flex !important; visibility: visible !important; opacity: 1 !important; justify-content: center; gap: 15px; margin: 30px 0 20px; padding: 20px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; flex-wrap: wrap; z-index: 100;">
				<a href="#asset-list" onclick="event.preventDefault(); showAssetList(); return false;" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(255, 193, 7, 0.8) !important; border: 2px solid #ffc107; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(255, 193, 7, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 193, 7, 0.8)'; this.style.transform='translateY(0)'">
					üìã List of Assets
				</a>
				<a href="#backtest" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(76, 175, 80, 0.8) !important; border: 2px solid #4caf50; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(76, 175, 80, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(76, 175, 80, 0.8)'; this.style.transform='translateY(0)'">
					üìà Backtesting
				</a>
				<a href="#trading-education" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(255, 152, 0, 0.8) !important; border: 2px solid #ffa726; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(255, 152, 0, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 152, 0, 0.8)'; this.style.transform='translateY(0)'">
					üí° Trading Education
				</a>
				<a href="#comprehensive-indicator-analysis" onclick="event.preventDefault(); showCodeExplanation(); return false;" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(156, 39, 176, 0.8) !important; border: 2px solid #ab47bc; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(156, 39, 176, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(156, 39, 176, 0.8)'; this.style.transform='translateY(0)'">
					üîß Code Explanation
				</a>
				<a href="#code-download-section" onclick="event.preventDefault(); showCodeForSale(); return false;" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(33, 150, 243, 0.8) !important; border: 2px solid #2196f3; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(33, 150, 243, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(33, 150, 243, 0.8)'; this.style.transform='translateY(0)'">
					üí∞ Optional Code for Sale
				</a>
				<a href="#other-tips-tricks" onclick="event.preventDefault(); showMiscellaneousTips(); return false;" style="display: inline-block !important; visibility: visible !important; opacity: 1 !important; color: #fff !important; text-decoration: none; padding: 12px 24px; background: rgba(233, 30, 99, 0.8) !important; border: 2px solid #e91e63; border-radius: 6px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(233, 30, 99, 1)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(233, 30, 99, 0.8)'; this.style.transform='translateY(0)'">
					üí° Miscellaneous Tips
				</a>
			</div>
			
			<!-- Bitcoin Dominance Indicator -->
			<div id="bitcoin-dominance-section" style="display: block !important; visibility: visible !important; opacity: 1 !important; margin: 30px auto !important; padding: 20px !important; background: rgba(247, 147, 26, 0.3) !important; border: 3px solid #f7931a !important; border-radius: 12px; position: relative !important; z-index: 200 !important; width: calc(100% - 40px) !important; max-width: 1400px !important; box-shadow: 0 4px 20px rgba(247, 147, 26, 0.4) !important;">
				<!-- Compact Header -->
				<div style="margin-bottom: 15px; display: flex; align-items: center; flex-wrap: wrap; gap: 10px;">
					<div>
						<h3 style="color: #f7931a !important; font-size: 20px; margin: 0 0 5px 0; opacity: 1 !important; visibility: visible !important; display: inline-block;">‚Çø Bitcoin Dominance</h3>
						<span style="color: rgba(255, 255, 255, 0.8) !important; font-size: 13px; opacity: 1 !important; visibility: visible !important; margin-left: 10px;">
							Bitcoin's market cap as % of total crypto market cap
						</span>
					</div>
				</div>
				
				<!-- Bitcoin Dominance Explanation with Image -->
				<div style="background: rgba(247, 147, 26, 0.15); border-left: 4px solid #f7931a; padding: 15px; margin-bottom: 20px; border-radius: 8px; position: relative;">
					<div style="display: flex; gap: 20px; align-items: flex-start;">
						<div style="flex: 1; min-width: 0;">
							<h4 style="color: #f7931a; font-size: 16px; margin: 0 0 12px 0; font-weight: bold;">üìä Understanding Bitcoin Dominance</h4>
							<ul style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.7; margin: 0; padding-left: 20px;">
								<li style="margin-bottom: 8px;">
									<strong>What it measures:</strong> Bitcoin dominance shows how much of the total cryptocurrency market cap belongs to Bitcoin. When it's high (e.g., 60%+), Bitcoin controls most of the market.
								</li>
								<li style="margin-bottom: 8px;">
									<strong>Rising dominance (above 2 EMA):</strong> Capital is flowing from altcoins into Bitcoin. This is typically <strong style="color: #f44336;">bearish for altcoins</strong> - they tend to underperform or decline. The bot <strong>blocks buy signals</strong> during rising dominance to protect you from poor entry timing.
								</li>
								<li style="margin-bottom: 8px;">
									<strong>Falling dominance (below 2 EMA):</strong> Capital is flowing from Bitcoin into altcoins. This is typically <strong style="color: #4caf50;">bullish for altcoins</strong> - they tend to outperform. The bot <strong>allows buy signals</strong> during falling dominance when conditions are favorable.
								</li>
								<li style="margin-bottom: 8px;">
									<strong>Why it matters:</strong> Bitcoin dominance reflects market risk appetite. When investors are risk-averse, they flock to Bitcoin (the "safe haven" of crypto). When they're risk-on, they chase altcoin gains.
								</li>
								<li style="margin-bottom: 0;">
									<strong>How the bot uses it:</strong> The bot calculates a 2-period EMA of Bitcoin dominance and compares it to the current value. This filter helps avoid buying altcoins when Bitcoin is likely to outperform, improving your entry timing.
								</li>
							</ul>
						</div>
						<div style="flex-shrink: 0; align-self: flex-start;">
							<img src="img/Bitcoin Dominance image.png" alt="Bitcoin Dominance" style="max-width: 180px; max-height: 400px; width: auto; height: auto; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);">
						</div>
					</div>
				</div>
				
				<!-- TradingView Bitcoin Dominance Widget -->
				<div class="tradingview-widget-container" style="height: 500px; width: 100%; margin-bottom: 20px;">
					<div class="tradingview-widget-container__widget" style="height: 100%; width: 100%;"></div>
					<script type="application/json" id="tv-btc-d-widget-config">
					{
						"autosize": true,
						"symbol": "CRYPTOCAP:BTC.D",
						"interval": "60",
						"timezone": "Etc/UTC",
						"theme": "dark",
						"style": "1",
						"locale": "en",
						"backgroundColor": "rgba(0, 0, 0, 0.3)",
						"gridColor": "rgba(255, 255, 255, 0.1)",
						"hide_top_toolbar": false,
						"hide_legend": false,
						"save_image": false,
						"support_host": "https://www.tradingview.com",
						"studies": [
							{
								"id": "MASimple@tv-basicstudies",
								"inputs": {
									"length": 21,
									"source": "close"
								},
								"overrides": {
									"plot_0.style": 1,
									"plot_0.color": "#ff9800",
									"plot_0.plottype": 2
								}
							}
						]
					}
					</script>
					<script>
						(function () {
							// Keep the TradingView config as pure JSON (not JS) to avoid editor/linter issues,
							// then dynamically create the exact script-tag TradingView expects.
							const container = document.currentScript && document.currentScript.parentElement;
							const cfgEl = document.getElementById('tv-btc-d-widget-config');
							if (!container || !cfgEl) return;

							const s = document.createElement('script');
							s.type = 'text/javascript';
							s.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
							s.async = true;
							s.text = cfgEl.textContent || '';
							container.appendChild(s);
						})();
					</script>
				</div>
				
				<!-- Bitcoin Dominance Warning -->
				<div id="btc-dominance-warning" style="display: none; background: rgba(244, 67, 54, 0.2); border: 2px solid #f44336; padding: 20px; border-radius: 8px; margin-top: 15px;">
					<div style="color: #f44336; font-weight: bold; font-size: 18px; margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
						<span>üö® RISING BITCOIN DOMINANCE WARNING</span>
					</div>
					<div style="color: rgba(255, 255, 255, 0.95); font-size: 16px; line-height: 1.6;">
						Bitcoin dominance is <strong>trending upwards</strong>, which typically indicates that capital is flowing from altcoins back into Bitcoin.
					</div>
					<div style="color: rgba(255, 255, 255, 0.9); font-size: 15px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
						‚ö†Ô∏è <strong>Exercise extreme caution when taking altcoin long positions</strong> during rising Bitcoin dominance. Consider:
						<ul style="margin: 10px 0 0 20px; padding-left: 10px;">
							<li>Avoiding or reducing altcoin long positions when dominance is rising</li>
							<li>Waiting for Bitcoin dominance to stabilize or decline before entering altcoin longs</li>
							<li>Using tighter stop-losses on any existing altcoin positions</li>
							<li>Focusing on Bitcoin or stablecoins during dominance uptrends</li>
							<li>Remember: When Bitcoin dominance rises, altcoins typically underperform or decline</li>
						</ul>
					</div>
				</div>
				
				<!-- Bitcoin Dominance Info (dynamically updated based on trend) -->
				<div id="btc-dominance-info" style="display: none; background: rgba(76, 175, 80, 0.15); border: 2px solid rgba(76, 175, 80, 0.5); padding: 15px; border-radius: 8px; margin-top: 15px;">
					<!-- Content will be dynamically updated by JavaScript -->
					<div style="color: #9e9e9e; font-weight: bold; font-size: 16px; margin-bottom: 8px;">
						‚è≥ Collecting Data
					</div>
					<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.6;">
						Collecting Bitcoin dominance data to determine trend. Check back in a few minutes.
					</div>
				</div>
			</div>
			
			<div id="live-signals"></div>
			
			<!-- Crypto Signals (Recent - Last 1 Day) -->
			<div id="crypto-signals-container" style="display: block;">
				<h2 style="color: var(--primary-color); font-size: 28px; margin: 40px 0 20px; text-align: center;">üöÄ Crypto Signals</h2>
			<div id="signals-grid" class="signals-grid" style="background: rgba(255,0,0,0.1); border: 2px dashed rgba(255,255,255,0.3); padding: 20px; min-height: 50px; margin-bottom: 0 !important;">
				<div class="loading">‚è≥ Waiting for signals...</div>
				</div>
			</div>
			
			<!-- Stock Signals (Recent - Last 7 Days) - Hidden by default -->
			<div id="stock-signals-container" style="margin: 40px 0; padding: 0; display: none;">
				<h2 style="color: var(--primary-color); font-size: 28px; margin: 40px 0 20px; text-align: center;">üìä Stock Signals</h2>
				<p style="color: rgba(255, 255, 255, 0.6); font-size: 14px; text-align: center; margin-bottom: 20px; max-width: 800px; margin-left: auto; margin-right: auto;">
					Stocks and ETFs are long-term plays, so signals remain valid for extended periods. Recent stock signals from the past week are shown below.
				</p>
				
				<!-- Watchlist Section -->
				<div id="watchlist-section" style="margin: 30px 0; padding: 25px; background: rgba(255, 193, 7, 0.1); border: 2px solid rgba(255, 193, 7, 0.5); border-radius: 12px;">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
						<h3 style="color: #ffc107; font-size: 24px; margin: 0;">‚≠ê My Watchlist</h3>
						<button id="request-notification-btn" style="display: none; background: rgba(255, 193, 7, 0.2); border: 1px solid #ffc107; color: #ffc107; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
							üîî Enable Notifications
						</button>
					</div>
					<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-bottom: 15px;">
						Get browser notifications and sound alerts when your watched symbols change signals. Click the ‚≠ê button on any signal card to add it to your watchlist.
					</p>
					<div id="watchlist-items" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; min-height: 50px;">
						<div style="color: rgba(255, 255, 255, 0.5); text-align: center; padding: 20px; font-style: italic;">
							No symbols in watchlist yet. Add symbols using the ‚≠ê button on signal cards.
						</div>
					</div>
				</div>
				
			<!-- Market Breadth Indicator -->
			<div id="market-breadth-section" style="margin: 30px 0; padding: 25px; background: rgba(156, 39, 176, 0.1); border: 2px solid rgba(156, 39, 176, 0.5); border-radius: 12px;">
				<div style="text-align: center; margin-bottom: 15px;">
					<h3 style="color: #9c27b0; font-size: 24px; margin-bottom: 10px;">üìä Market Breadth Indicator</h3>
					<div style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-bottom: 15px;">
						Percentage of scanned assets showing BUY vs SELL signals based on multi-indicator analysis
					</div>
				</div>
				<div id="market-breadth-content" style="min-height: 80px;">
					<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Loading market breadth...</div>
				</div>
			</div>
			
			<!-- Top 3 Signals Section with Thresholds -->
			<div id="top-signals-section" style="margin: 30px 0; padding: 25px; background: rgba(33, 150, 243, 0.1); border: 2px solid rgba(33, 150, 243, 0.5); border-radius: 12px;">
					<div style="text-align: center; margin-bottom: 20px;">
						<h3 style="color: var(--primary-color); font-size: 24px; margin-bottom: 15px;">üèÜ Top 3 Stock Signals (Best of the Day)</h3>
						<div style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #ffc107;">
							<div style="color: #ffc107; font-weight: bold; font-size: 16px; margin-bottom: 8px;">üìä Signal Thresholds Explained</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.6;">
								<strong>BUY Threshold:</strong> ‚â•16/38 indicators (‚âà42%) must agree<br>
								<strong>SELL Threshold:</strong> ‚â•13/37 indicators (‚âà35%) must agree<br>
								<span style="color: rgba(255, 255, 255, 0.7); font-size: 13px; display: block; margin-top: 8px;">
									üí° These are the <strong>best signals</strong> from today's scan, even if they don't meet the full threshold. 
									On quiet market days, these represent the strongest setups available. Ideally, you would want to be patient and only act on signals that meet the thresholds, which have been backtested for maximum efficiency: not too afraid to act, but also not over-trading.
								</span>
							</div>
						</div>
					</div>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
						<!-- Top 3 BUY Signals -->
						<div style="background: rgba(76, 175, 80, 0.15); border: 2px solid rgba(76, 175, 80, 0.5); border-radius: 8px; padding: 20px;">
							<h4 style="color: #4caf50; font-size: 20px; margin-bottom: 15px; text-align: center;">üü¢ Top 3 BUY Signals</h4>
							<div id="weekend-warning-buy" style="display: none; background: rgba(255, 165, 0, 0.2); border: 1px solid rgba(255, 165, 0, 0.5); border-radius: 6px; padding: 8px; margin-bottom: 10px;">
								<div style="color: #ffa500; text-align: center; font-size: 12px; font-weight: bold;">‚ö†Ô∏è It is the weekend, stock market closed. Data may be stale from last trading day.</div>
							</div>
							<div id="top-buy-signals" style="min-height: 100px;">
								<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Loading...</div>
							</div>
						</div>
						
						<!-- Top 3 SELL Signals -->
						<div style="background: rgba(244, 67, 54, 0.15); border: 2px solid rgba(244, 67, 54, 0.5); border-radius: 8px; padding: 20px;">
							<h4 style="color: #f44336; font-size: 20px; margin-bottom: 15px; text-align: center;">üî¥ Top 3 SELL Signals</h4>
							<div id="weekend-warning-sell" style="display: none; background: rgba(255, 165, 0, 0.2); border: 1px solid rgba(255, 165, 0, 0.5); border-radius: 6px; padding: 8px; margin-bottom: 10px;">
								<div style="color: #ffa500; text-align: center; font-size: 12px; font-weight: bold;">‚ö†Ô∏è It is the weekend, stock market closed. Data may be stale from last trading day.</div>
							</div>
							<div id="top-sell-signals" style="min-height: 100px;">
								<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Loading...</div>
							</div>
						</div>
					</div>
				</div>
				
				<div id="stock-signals-grid" class="signals-grid" style="background: rgba(76, 175, 80, 0.1); border: 2px solid rgba(76, 175, 80, 0.3); padding: 20px; min-height: 50px;">
					<div class="loading">‚è≥ Loading stock signals...</div>
				</div>
			</div>
			
			<!-- Asset List Section - Hidden by default -->
			<div id="asset-list"></div>
			<div id="asset-list-container" style="margin: 40px 0; padding: 0; display: none;">
				<h2 style="color: var(--primary-color); font-size: 28px; margin: 40px 0 20px; text-align: center;">üìã Asset List - Latest Signals</h2>
				<p style="color: rgba(255, 255, 255, 0.6); font-size: 14px; text-align: center; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
					Find your favorite asset below to see its most recent trading signal. This view shows the latest signal for each asset, making it easy to check the current status of any asset you're tracking.
				</p>
				
				<!-- Crypto Assets List -->
				<div style="margin-bottom: 40px;">
					<h3 style="color: var(--primary-color); font-size: 24px; margin-bottom: 20px; text-align: center;">üíé Cryptocurrencies</h3>
					<div id="crypto-asset-list" class="asset-list-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; margin-bottom: 30px;">
						<div class="loading">‚è≥ Loading crypto assets...</div>
					</div>
				</div>
				
				<!-- Stock Assets List -->
				<div>
					<h3 style="color: var(--primary-color); font-size: 24px; margin-bottom: 20px; text-align: center;">üìà Stocks & ETFs</h3>
					<div id="stock-asset-list" class="asset-list-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
						<div class="loading">‚è≥ Loading stock assets...</div>
					</div>
				</div>
			</div>
			
			<!-- Backtest Results Section -->
			<div id="backtest"></div>
			<div class="backtest-section" style="display: block !important; visibility: visible !important; opacity: 1 !important; margin: 10px 0 0px 0 !important; padding: 40px 20px; background: rgba(76, 175, 80, 0.15); border-radius: 12px; border: 3px solid #4caf50;">
				<h2 style="color: #f1cfab; font-size: 32px; margin-bottom: 15px; text-align: center; display: block !important; visibility: visible !important;">
					üìà Backtest Performance
				</h2>
				
				<div style="display: block !important; visibility: visible !important; margin: 30px auto; max-width: 1200px; background: rgba(255, 0, 0, 0.1); padding: 20px;">
					<img src="img/Best%20backtest%2030m.png" 
					     alt="Best Backtest Results - 30 Minute Timeframe" 
					     style="display: block !important; visibility: visible !important; opacity: 1 !important; width: 100%; height: auto; border-radius: 8px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4); border: 3px solid #4caf50;"
					     onerror="console.error('Image failed to load:', this.src); this.style.border='5px solid red'; this.style.background='yellow'; alert('IMAGE LOAD ERROR: ' + this.src);">
				</div>
				
				<!-- Detailed Explanation -->
				<div style="display: block !important; visibility: visible !important; opacity: 1 !important; margin-top: 30px; text-align: left; max-width: 1000px; margin-left: auto; margin-right: auto; background: rgba(0, 0, 0, 0.5); padding: 30px; border-radius: 8px; border-left: 4px solid #f1cfab;">
					<p style="display: block !important; visibility: visible !important; color: rgba(255, 255, 255, 0.95); font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
						Now I could <strong>lie to you</strong> and tell you that this is real. Unfortunately this is overly optimistic because of repainting. 
						<strong>HOWEVER</strong>, I started to ponder how I could solve the problem.
					</p>
					
					<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
						<strong style="color: #4caf50;">The solution:</strong> Delay the bot intentionally to have it look back in time to see if the signal was <strong>REAL</strong> and to crunch the numbers on historical data that can <strong>NO LONGER BE CHANGED</strong>. On the backend, I have preliminary signals that fire, but they will only be shown on this website once enough time has passed by, and once enough signal confluence becomes true. 
					</p>
					
					<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
						This is a big reason that led to the <strong style="color: var(--primary-color);">double filtering strategy</strong>‚Äîfirst TradingView, then have Python code to help watch the trade to make sure everything is going to plan and it is not a repainting volatile fake-out. The other big reason for Python code? <strong style="color: #ab47bc;">Sophisticated AI algorithms that are not possible in TradingView.</strong>
					</p>
					
					<div style="background: rgba(244, 67, 54, 0.15); border: 2px solid #ef5350; padding: 25px; border-radius: 8px; margin: 20px 0;">
						<p style="color: rgba(255, 255, 255, 0.95); font-size: 18px; line-height: 1.8; margin: 0; font-weight: bold;">
							That being said, <span class="roi-animated">447,623,973,008% ROI</span><span class="roi-money-emoji">üí∞</span> with 
							<span style="color: #4caf50;">83.87% accuracy</span>, 
							<span style="color: #ffa726;">14.362 Profit Factor</span> is <strong>INSANE</strong>, and I am <strong>INSANE</strong> for giving this away for FREE. 
							When Blackrock finds out about this, they'll certainly make me "sleep with the fishes." üêüüíÄ
							Even if I am an idiot that's bad at math: the bot performing 10x WORSE than this IS STILL turning ONE DOLLAR into $44,700,000 ü§Ø. Broker commissions INCLUDED at 0.07%.
						</p>
					</div>
					
					<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
						<strong>Still need more proof?</strong> I ran <strong style="color: #42a5f5;">Monte Carlo tests</strong>. That means I even ran the bot through <em>alternate versions of history</em>. What if Bitcoin was at $2 right now, would the bot still have made money? <strong style="color: #4caf50;">Yes</strong>, the bot is still successful in alternate versions of history, so I didn't shoot the arrow first and then draw a bullseye around it. This helps to avoid future knowledge or over-fitting hard-coded bias.
					</p>
					
					<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; line-height: 1.8; margin-bottom: 0;">
						<strong>In fact, the backtests were so good that I caused TradingView to have errors</strong> and I had to start putting the starting capital at <strong style="color: var(--primary-color);">$1.00</strong>. 
						If I put $1,000 starting capital, <span style="color: #f44336; font-weight: bold;">TradingView's UI would break!</span> 
						<span style="background: rgba(255, 193, 7, 0.2); padding: 2px 8px; border-radius: 4px; font-weight: bold;">Also, that backtest image is from 3 years ago, we are now up to 350,000+ lines of code and we have created a monster. Imagine what I can do now!</span> üöÄ
					</p>
				</div>
				
				<p style="color: rgba(255, 255, 255, 0.6); font-size: 14px; margin-top: 30px; font-style: italic; text-align: center;">
					Past performance does not guarantee future results. All trading involves risk. 
					See full disclaimer for important risk information.
				</p>
			</div>
			
			<!-- Signal Timing & Repainting Explanation -->
			<div id="trading-education"></div> <!-- Manual edit to trading education. double check my work to make sure I didn't break anything.-->
			<div class="indicators-section" style="margin-top: 0px !important; background: rgba(76, 175, 80, 0.1); border: 2px solid #4caf50;">
				<div class="indicators-header">
					<h2>üí° How to Use These Signals</h2>
				</div>
				
				<div class="indicators-content">
					<div class="indicator-category" style="background: rgba(76, 175, 80, 0.05);">
						<h3 style="color: #4caf50;">üìä Understanding Multiple Signals</h3>
						<div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196f3; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 15px; line-height: 1.6;">
								<strong>You may notice multiple signals appearing at the same time for a given ticker. This is a feature, not a bug.</strong>
							</p>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 15px; line-height: 1.6;">
								The System uses <strong>built-in position sizing</strong> based on how many indicators are confirming the signal. When multiple indicators align, it indicates stronger conviction, and the system automatically scales position size accordingly.
							</p>
							<ul style="color: rgba(255, 255, 255, 0.85); line-height: 1.8;">
								<li><strong>Buy positions can be pyramided up to 3 times</strong> - As more indicators confirm the signal, additional buy signals may appear, allowing you to scale into the position with increasing confidence. The different tickers all trading is position sizing even more. If multiple signals fire on different assets, that scales in even more. A perfect dollar-cost-average strategy.</li>
								<li><strong>Sells are always 100% of the position</strong> - When a sell signal appears, it represents a complete exit of the position, regardless of how many buy signals were used to build it</li>
								<li><strong>More signals = Higher conviction</strong> - Multiple simultaneous signals indicate stronger confluence and higher probability setups</li>
							</ul>
							
							<div style="background: rgba(255, 165, 0, 0.15); border-left: 4px solid rgba(255, 165, 0, 0.8); padding: 20px; margin-top: 20px; border-radius: 4px;">
								<h4 style="color: rgba(255, 165, 0, 0.9); margin-top: 0;">üõ°Ô∏è Understanding Stop Losses (Risk Management, Not Bearish Signals)</h4>
								<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 15px; line-height: 1.6;">
									<strong>Important:</strong> If you see a sell signal with a -3% loss, this is <strong>NOT</strong> because the bot is bearish on the asset. This is our <strong>fixed stop loss protection</strong> - a "guardian angel" that prevents large losses.
								</p>
								<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 15px; line-height: 1.6;">
									<strong>How it works:</strong> The bot uses multiple stop loss systems working together to protect your capital:
								</p>
								<ul style="color: rgba(255, 255, 255, 0.85); line-height: 1.8; margin-bottom: 15px;">
									<li><strong>Fixed 3% Stop Loss</strong> - Hard floor that never allows more than 3% loss per trade. This is checked FIRST and acts as your ultimate safety net.</li>
									<li><strong>ATR Trailing Stop</strong> - Dynamically adjusts based on volatility, protecting profits as they develop while allowing trends to run.</li>
									<li><strong>Trend Exhaustion Detection</strong> - Exits when parabola patterns break or trend strength (ADX) weakens significantly.</li>
								</ul>
								<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.6;">
									<strong>Why this matters:</strong> Professional traders use stop losses not because they're bearish, but because <strong>capital preservation is more important than being right</strong>. A -3% loss is much better than a -10% or -20% loss. This is capital efficiency and risk management, not a bearish signal. The bot is protecting you from catastrophic losses so you can live to trade another day.
								</p>
							</div>
						</div>
						
						<h3 style="color: #4caf50;">üéØ Signal Timing Philosophy</h3>
						
						<h4>Wait for Confirmation (Recommended)</h4>
						<ul>
							<li><strong>Don't rush the entry</strong> - Give signals a few hours to confirm the move is real. Consider starting with a smaller position (25-50% of your intended size) and adding to it as the move confirms through price action, additional indicators, or time. This scaling approach lets you participate while managing risk.
							<br><br>
							Being 3-12 hours late on the signal is actually a good thing, and is the sweet spot IF the directional bias seems to be playing out correctly. The more time passes by, the more the massive suite of indicators get carved into stone and can't be undone.
							<br><br>
							<strong>Understanding "Repainting":</strong> There's a phenomenon called repainting, which is when live prices are moving so fast that the signal "changes its mind." In order to mitigate repainting, consider slowly scaling in as you feel the move gets more and more confirmed. Of course, the market is filled with manipulation and "short squeezes," so this thinking helps mitigate that risk. 
							<br><br>
							<strong>Reality check:</strong> It's next to impossible to completely eliminate this‚Äîit's just the nature of trading. An asset can have a +50% move and then take it all back in the SAME candle. That's part of the game. This is why we emphasize position sizing and scaling, not all-or-nothing entries.</li>
							<li><strong>Avoid fake-outs</strong> - Extreme volatility can create false signals that reverse quickly</li>
							<li><strong>Let the move develop</strong> - The best traders don't try to catch the perfect bottom or top</li>
							<li><strong>Patience pays</strong> - A confirmed trend is worth more than catching the first tick</li>
						</ul>
						
						<h4>Anti-Repainting Proof</h4>
						<p style="color: rgba(255, 255, 255, 0.8); margin-bottom: 15px;">
							<strong>Repainting</strong> is when trading systems retroactively change or delete past signals to make their performance look better. 
							We explicitly prevent this through transparency:
						</p>
						<ul>
							<li><strong>Permanent timestamps</strong> - Every signal gets an immutable ISO 8601 timestamp the moment it's generated</li>
							<li><strong>Never deleted</strong> - Signals are archived (not removed) after 4 days, providing long-term proof</li>
							<li><strong>The longer signals age</strong> - The more proof they provide that we haven't edited or manipulated them</li>
							<li><strong>GitHub commit history</strong> - Every update to signals.json is version-controlled with commit timestamps</li>
							<li><strong>What you see is what was generated</strong> - No cherry-picking, no editing, no hiding bad calls</li>
						</ul>
						
						<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 20px; margin-top: 20px; border-radius: 4px;">
							<h4 style="color: #ffc107; margin-top: 0;">üí° Professional Trader Mindset</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">
								The best traders understand that:
							</p>
							<ul style="margin-bottom: 0;">
								<li><strong>Not every signal will be profitable</strong> - That's trading. Even 55-60% win rate with proper risk management is excellent</li>
								<li><strong>Confirmation > Speed</strong> - Missing the first 2% of a move to gain 80% confidence is a good trade-off</li>
								<li><strong>Risk management matters most</strong> - The bot uses multiple stop losses (fixed 3% hard floor, ATR trailing stops, trend exhaustion detection) to protect capital. A -3% loss is not a bearish signal - it's capital efficiency and protection.</li>
								<li><strong>The trend is your friend</strong> - Signals work best when aligned with higher timeframe trends</li>
								<li><strong>Patience wins</strong> - Let high-probability setups come to you rather than forcing trades</li>
							</ul>
						</div>
					</div>
				</div>
			</div>
			
			<!-- Stock vs Crypto Strategy Advice -->
			<div class="indicators-section" style="margin-top: 40px; background: rgba(156, 39, 176, 0.1); border: 2px solid rgba(156, 39, 176, 0.5);">
				<div class="indicators-header">
					<h2>üìà Stock Strategy vs Crypto Strategy</h2>
				</div>
				
				<div class="indicators-content">
					<div class="indicator-category" style="background: rgba(156, 39, 176, 0.05);">
						<div style="background: rgba(156, 39, 176, 0.1); border-left: 4px solid #9c27b0; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 15px; line-height: 1.6;">
								<strong>The stock strategy is different code than crypto. The stock strategy emphasizes trend while the crypto strategy is much more of a mean reversion strategy.</strong>
							</p>
							<ul style="color: rgba(255, 255, 255, 0.85); line-height: 1.8;">
								<li><strong>Buy into strength for stocks</strong> - Stocks mostly trend forever. When you see a strong uptrend signal, the momentum is likely to continue. Follow the trend and add to positions as they move in your favor.</li>
								<li><strong>Buy into weakness for crypto</strong> - Crypto is much more of a roller coaster ride. Mean reversion strategies work better here. When crypto drops significantly, that's often the best time to buy, as it tends to bounce back.</li>
								<li><strong>Different mindsets</strong> - Stocks reward trend-following patience. Crypto rewards contrarian thinking and buying the dip.</li>
							</ul>
						</div>
					</div>
				</div>
			</div>
			
			<!-- Benefits Section -->
			<div class="indicators-section" style="margin-top: 40px;">
				<div class="indicators-header">
					<h2>üöÄ Why This Is Different</h2>
				</div>
				
				<div class="indicators-content">
					<div class="indicator-category" style="background: rgba(76, 175, 80, 0.1); border: 2px solid rgba(76, 175, 80, 0.3); padding: 25px; border-radius: 12px;">
						<h3 style="color: #4caf50; margin-top: 0;">üí∞ Become a Quant Trader Without the Complexity</h3>
						<ul style="color: rgba(255, 255, 255, 0.9); font-size: 18px; line-height: 1.8; margin-bottom: 20px; padding-left: 25px;">
							<li><strong>Access institutional-grade trading signals</strong> in the most lucrative asset class in human history</li>
							<li><strong>Large funds don't trade crypto</strong> - creating a huge opportunity for retail traders</li>
							<li><strong>No math or coding experience required</strong> - only $9.99</li>
							<li><strong>Massive opportunity cost</strong> of manually staring at charts all day instead of focusing on family, friends, and your career</li>
							<li><strong>Human emotions are your enemy:</strong> Can you really stay emotionless after losing $5,000 in a month? Will you avoid revenge trading?</li>
							<li><strong>AI outperforms human traders:</strong> Can you buy when crypto drops -50% even when analysis says you should? Can you sell when everyone's bragging about gains?</li>
							<li><strong>Chart > News:</strong> The chart tells the story, not the news. Big players use news to make you buy tops and sell bottoms</li>
							<li><strong>AI is revealing Wall Street's secrets:</strong> This secretive industry is finally being democratized</li>
						</ul>
						
						<div style="background: rgba(244, 67, 54, 0.1); border-left: 4px solid #f44336; padding: 20px; margin: 20px 0; border-radius: 4px;">
							<h4 style="color: #f44336; margin-top: 0;">‚ö†Ô∏è Stay Safe: Watch Out for Scams</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">
								<strong>Be careful of the scams that say you can make 2 ETH a day with arbitrage.</strong> 99% of them are scams trying to trick you into downloading their wallet drainer. These malicious programs can drain your entire crypto wallet the moment you connect it.
							</p>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 0;">
								<strong>No sketchy code to download or install that can drain your account.</strong> Simply visit this page to take advantage of institutional hedge fund grade code tirelessly hunting down the best trades for you.
							</p>
						</div>
						
						<div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196f3; padding: 20px; margin-top: 20px; border-radius: 4px;">
							<h4 style="color: #2196f3; margin-top: 0;">‚úÖ What Makes This Safe and Legitimate</h4>
							<ul style="color: rgba(255, 255, 255, 0.9); margin-bottom: 0;">
								<li><strong>No downloads required</strong> - Just visit this page, no software to install. I will never ask for passwords/seed phrase. Never share these to anyone. Pro tip: Have a separate device with only $100 of crypto with a fresh seed phrase for "exploring".</li>
								<li><strong>No wallet connections</strong> - We never ask you to connect your wallet</li>
								<li><strong>Transparent signals</strong> - All signals are publicly visible with permanent timestamps</li>
								<li><strong>Institutional-grade code</strong> - Professional trading algorithms working 24/7</li>
								<li><strong>Simple one-time payment</strong> - Just $9.99 one-time payment (limited time offer) for permanent access to all signals through secure https payment with Stripe. (crypto payments coming soon!). I'm not hiding behind an alias Moonboy777, I'm using my legal name. Bloomberg Terminal costs $2,500 a month, Refinitiv $2,200 a month, Motley Fool $2,000 a year, TrendSpider $1,500 a year, TradingView Premium $599 a year, Trading courses are often $3,000+. You'll spend more on coffee this month than this costs. </li>
							</ul>
						</div>
					</div>
				</div>
			</div>
			
			<!-- Ticker Symbols Section -->
			<div id="code-explanation"></div>
			<div id="assets-traded-section" class="indicators-section" style="margin-top: 40px;">
				<div class="indicators-header">
					<h2>Assets Traded</h2>
					<p>We focus on a curated selection of assets to ensure quality analysis and signal generation. Below are the specific ticker symbols we actively monitor and trade.</p>
				</div>
				
				<div class="indicators-content">
					<div class="indicator-category">
						<h3>CRYPTOCURRENCIES</h3>
						<p style="color: rgba(255, 255, 255, 0.8); margin-bottom: 15px;">Cryptocurrency selection is based on extensive backtesting analysis. These tokens have demonstrated the strongest historical performance and signal reliability in the trading system:</p>
						<ul>
							<li data-symbol="BTC/USD"><strong>BTC/USD</strong> - Bitcoin: The original and largest cryptocurrency, serving as digital gold and a store of value with the highest market capitalization <span class="asset-signal-status"></span></li>
							<li data-symbol="ETH/USD"><strong>ETH/USD</strong> - Ethereum: The second-largest cryptocurrency and leading smart contract platform, powering the majority of DeFi and NFT ecosystems <span class="asset-signal-status"></span></li>
							<li data-symbol="SOL/USD"><strong>SOL/USD</strong> - Solana: High-performance blockchain with fast transaction speeds and low fees, popular for DeFi and NFT applications <span class="asset-signal-status"></span></li>
							<li data-symbol="DASH/USD"><strong>DASH/USD</strong> - Dash: Privacy-focused cryptocurrency with instant transactions, decentralized governance, and optional private send features <span class="asset-signal-status"></span></li>
							<li data-symbol="TAO/USD"><strong>TAO/USD</strong> - Bittensor: Decentralized AI network token powering machine learning models and neural networks through distributed computing <span class="asset-signal-status"></span></li>
							<li data-symbol="BONK/USD"><strong>BONK/USD</strong> - Bonk: Meme coin on the Solana blockchain with strong community engagement and high volatility <span class="asset-signal-status"></span></li>
							<li data-symbol="CRV/USD"><strong>CRV/USD</strong> - Curve DAO Token: Governance token for Curve Finance, a leading DeFi protocol specializing in stablecoin swaps and liquidity pools <span class="asset-signal-status"></span></li>
							<li data-symbol="SUI/USD"><strong>SUI/USD</strong> - Sui: Next-generation blockchain platform designed for high throughput and low latency, focusing on gaming and DeFi applications <span class="asset-signal-status"></span></li>
							<li data-symbol="AERO/USD"><strong>AERO/USD</strong> - Aerodrome: DeFi protocol token on Base blockchain, providing liquidity and yield farming opportunities <span class="asset-signal-status"></span></li>
							<li data-symbol="FET/USD"><strong>FET/USD</strong> - Fetch.ai: AI-powered blockchain platform enabling autonomous economic agents and machine learning applications <span class="asset-signal-status"></span></li>
							<li data-symbol="RNDR/USD"><strong>RNDR/USD</strong> - Render Token: Decentralized GPU rendering network connecting artists with distributed computing power for 3D rendering <span class="asset-signal-status"></span></li>
							<li data-symbol="AAVE/USD"><strong>AAVE/USD</strong> - Aave: Leading DeFi lending protocol token, enabling users to lend and borrow cryptocurrencies with competitive interest rates <span class="asset-signal-status"></span></li>
						</ul>
						<p style="color: rgba(255, 255, 255, 0.6); font-size: 0.9em; margin-top: 10px; font-style: italic;">These cryptocurrencies were selected based on comprehensive backtesting results showing optimal signal performance and trading outcomes.</p>
					</div>
					
					<div class="indicator-category">
						<h3>STOCKS & ETFs</h3>
						<p style="color: rgba(255, 255, 255, 0.8); margin-bottom: 15px;">Stock strategy focuses on sector ETFs, benchmarks, and select individual stocks:</p>
						<h4>US Sector ETFs</h4>
						<ul>
							<li data-symbol="XLK"><strong>XLK</strong> - Technology Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLY"><strong>XLY</strong> - Consumer Discretionary Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLP"><strong>XLP</strong> - Consumer Staples Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLI"><strong>XLI</strong> - Industrial Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLB"><strong>XLB</strong> - Materials Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLRE"><strong>XLRE</strong> - Real Estate Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLU"><strong>XLU</strong> - Utilities Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLC"><strong>XLC</strong> - Communication Services Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLF"><strong>XLF</strong> - Financial Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLV"><strong>XLV</strong> - Health Care Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
							<li data-symbol="XLE"><strong>XLE</strong> - Energy Select Sector SPDR Fund <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Specialized Sectors</h4>
						<ul>
							<li data-symbol="SOXX"><strong>SOXX</strong> - iShares Semiconductor ETF <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Individual Stocks</h4>
						<ul>
							<li data-symbol="NVDA"><strong>NVDA</strong> - NVIDIA Corporation <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Benchmarks</h4>
						<ul>
							<li data-symbol="SPY"><strong>SPY</strong> - SPDR S&P 500 ETF Trust <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Precious Metals</h4>
						<ul>
							<li data-symbol="GLD"><strong>GLD</strong> - SPDR Gold Trust <span class="asset-signal-status"></span></li>
							<li data-symbol="SLV"><strong>SLV</strong> - iShares Silver Trust <span class="asset-signal-status"></span></li>
							<li data-symbol="PPLT"><strong>PPLT</strong> - Aberdeen Standard Physical Platinum Shares ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="PALL"><strong>PALL</strong> - Aberdeen Standard Physical Palladium Shares ETF <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Energy</h4>
						<ul>
							<li data-symbol="USO"><strong>USO</strong> - United States Oil Fund <span class="asset-signal-status"></span></li>
						</ul>
						<h4>International & Credit</h4>
						<ul>
							<li data-symbol="EEM"><strong>EEM</strong> - iShares MSCI Emerging Markets ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="PCEF"><strong>PCEF</strong> - Invesco CEF Income Composite ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="HYG"><strong>HYG</strong> - iShares iBoxx $ High Yield Corporate Bond ETF <span class="asset-signal-status"></span></li>
						</ul>
						<h4>Country/Region ETFs</h4>
						<ul>
							<li data-symbol="MCHI"><strong>MCHI</strong> - iShares MSCI China ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="INDA"><strong>INDA</strong> - iShares MSCI India ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="EWJ"><strong>EWJ</strong> - iShares MSCI Japan ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="EWG"><strong>EWG</strong> - iShares MSCI Germany ETF <span class="asset-signal-status"></span></li>
							<li data-symbol="EWT"><strong>EWT</strong> - iShares MSCI Taiwan ETF <span class="asset-signal-status"></span></li>
						</ul>
					</div>
				</div>
			</div>
			
			<!-- Indicator Inventory Section -->
			<div id="comprehensive-indicator-analysis" class="indicators-section">
				<div class="indicators-header">
					<h2>üìä Comprehensive Indicator Analysis</h2>
					<p>Trading signals are generated using a sophisticated multi-indicator confluence approach (as you are about to see, it is a seemingly never-ending list of indicators).</p>
				</div>
				
				<div class="indicators-content">
					<div class="indicator-category">
						<h3>TREND INDICATORS</h3>
						<h4>Moving Averages</h4>
						<ul>
							<li><strong>EMA (Exponential Moving Average)</strong>
								<ul>
									<li>Fast EMA (12-period) - short-term trend</li>
									<li>Slow EMA (26-period) - medium-term trend</li>
									<li>EMA 13 - megabot trend direction</li>
									<li>EMA 21 - megabot secondary trend</li>
									<li>EMA 195 - long-term trend filter</li>
								</ul>
							</li>
							<li><strong>SMA (Simple Moving Average)</strong>
								<ul>
									<li>SMA 18 - short-term average</li>
									<li>SMA 20 - standard trend line</li>
									<li>SMA 50 - medium-term trend (BTC halving analysis)</li>
									<li>SMA 200 - long-term trend (BTC halving analysis)</li>
								</ul>
							</li>
							<li><strong>Hull Moving Average (HMA)</strong> - Base length 8, scalar 5 - smoothed trend following</li>
							<li><strong>Guppy GMMA (Multiple Moving Averages)</strong> - Multiple EMA layers for trend confirmation</li>
						</ul>
						<h4>Trend Strength & Direction</h4>
						<ul>
							<li><strong>ADX (Average Directional Index)</strong> - Helps the bot avoid getting in and out of trades doring horizontal consildation price action. 14-period ADX for trend strength measurement, ADX thresholds: 7-8 for shorts, 8+ for longs, ADX Divergence - price vs trend strength divergence</li>
							<li><strong>Parabolic SAR</strong> - Acceleration 0.02, maximum 0.2 - dynamic stop and reverse</li>
							<li><strong>Ichimoku Cloud</strong> - Tenkan (9-period), Kijun (26-period), Senkou A/B (52-period), Chikou span, cloud thickness analysis, comprehensive trend system with support/resistance</li>
							<li><strong>SuperTrend</strong> - ATR-based trend following with dynamic stop levels, Factor 3.0, ATR period 10, SuperTrend Slope Divergence - price vs trend slope divergence</li>
							<li><strong>Directional Movement</strong> - +DI and -DI components for trend direction, DX (Directional Index) calculation</li>
						</ul>
						<h4>Advanced Trend Detection</h4>
						<ul>
							<li><strong>Parabola Detection</strong> - Mathematical curve fitting (quadratic regression), R¬≤ confidence threshold (0.70 default), Deviation threshold (2% default), ATR and ADX filtered parabola detection, Persistent parabola signals with duration tracking</li>
							<li><strong>MegaBot Crossover System</strong> - Higher timeframe close vs open crossover (720-minute default), 34-period SMA on higher timeframe, Multi-timeframe trend confirmation</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>MOMENTUM INDICATORS</h3>
						<h4>Oscillators</h4>
						<div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
							<h4 style="color: #2196f3; margin-top: 0; font-size: 16px;">üîç Understanding Divergences (Simple Explanation)</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 10px; line-height: 1.6;">
								<strong>What is a divergence?</strong> A divergence occurs when the price moves in one direction, but the underlying buying or selling pressure moves in the opposite direction. 
							</p>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.6;">
								<strong>In simple terms:</strong> We're finding moments where there are fewer buyers (or less buying pressure), yet the price still went up. This is a warning sign that the price move might be weak or unsustainable. 
								Conversely, if prices are falling but buying pressure is increasing, it could signal a potential reversal. Divergences help us spot when price movements might be running out of steam before the average trader notices. The added beauty of this: less hard-coding (knowing history too well A.K.A. over-fitting) and it is a more robust strategy between asset classes.
							</p>
						</div>
						<ul>
							<li><strong>RSI (Relative Strength Index)</strong> - 14-period standard RSI, 7-period fast RSI (SuperTrend variant), 21-period slow RSI (SuperTrend variant), RSI Divergence (regular and hidden bullish/bearish), RSI momentum filter for regime detection</li>
							<li><strong>Stochastic RSI</strong> - 14-period RSI, 14-period stochastic, 3-period smoothing, Stochastic RSI Divergence (regular and hidden)</li>
							<li><strong>Stochastic Oscillator</strong> - Standard momentum indicator comparing closing price to price range over a period, %K and %D lines, overbought/oversold conditions (TradingView Technical Rating component)</li>
							<li><strong>MACD (Moving Average Convergence Divergence)</strong> - MACD1: Fast 12, Slow 26, Signal 9 (standard), MACD2 (Impulse MACD / LazyBear): 34-period SMMA-based, MACD Histogram analysis, MACD Divergence (regular and hidden), MACD crossover signals (up/down, above/below zero)</li>
							<li><strong>Williams %R</strong> - 14-period momentum oscillator (-100 to 0 scale), Williams %R Divergence</li>
							<li><strong>CCI (Commodity Channel Index)</strong> - 20-period CCI (-200 to +200 scale), CCI Divergence</li>
							<li><strong>MFI (Money Flow Index)</strong> - 14-period volume-weighted momentum (0-100 scale), MFI Divergence</li>
							<li><strong>ROC (Rate of Change)</strong> - 12-period percentage price change, ROC Divergence</li>
						</ul>
						<h4>Momentum Filters</h4>
						<ul>
							<li><strong>Divergence Analysis</strong> - Price vs indicator divergence detection, Regular and hidden divergences (bullish/bearish), Lookback: 20 periods, min swings: 2, persistence: 3 bars, Applied to: RSI, Stochastic RSI, MACD, CCI, MFI, Williams %R, ROC, OBV, SuperTrend, Bollinger Bands, VROC, ATR</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>VOLATILITY INDICATORS</h3>
						<h4>Volatility Measurement</h4>
						<ul>
							<li><strong>ATR (Average True Range)</strong> - 14-period ATR for volatility measurement, ATR-SMA(20) for volatility trend, ATR Channels - dynamic support/resistance with squeeze/bounce/breakout, ATR Divergence, ATR Filter - consolidation detection (1111-period, 2.5 threshold)</li>
							<li><strong>Bollinger Bands</strong> - Volatility-based envelope indicator using standard deviation:
								<ul>
									<li><strong>How it works:</strong> Middle band is 20-period SMA, upper/lower bands are ¬±2.0 standard deviations from the middle band</li>
									<li><strong>Configuration:</strong> 20-period, 2.0 standard deviations</li>
									<li><strong>Analysis features:</strong> Band width analysis, Bollinger Band Width Divergence, Squeeze detection (threshold 0.1), Bounce detection (threshold 0.2)</li>
									<li><strong>Purpose:</strong> Identifies overbought/oversold conditions and volatility expansion/compression - bands widen during high volatility and contract during low volatility</li>
								</ul>
							</li>
							<li><strong>Keltner Channels</strong> - Volatility-based envelope indicator using ATR:
								<ul>
									<li><strong>How it works:</strong> Middle band is 20-period EMA, upper/lower bands are ¬±2.0 ATR from the middle band</li>
									<li><strong>Configuration:</strong> 20-period EMA, 2.0 ATR multiplier</li>
									<li><strong>Analysis features:</strong> Squeeze detection (threshold 0.1), Bounce detection (threshold 0.2)</li>
									<li><strong>Purpose:</strong> Similar to Bollinger Bands but uses ATR instead of standard deviation, providing trend-following support/resistance levels that adapt to volatility - used in TTM Squeeze detection</li>
								</ul>
							</li>
							<li><strong>TTM Squeeze</strong> - Volatility compression indicator that compares Bollinger Bands (2.0 std dev) to Keltner Channels (1.0 ATR multiplier), 20-period default:
								<ul>
									<li><strong>How it works:</strong> When Bollinger Bands are inside Keltner Channels (BB < KC), volatility is compressed, indicating a potential explosive move is building</li>
									<li><strong>Calculation:</strong> Compares BB upper band (SMA + 2√óstd dev) to KC upper band (EMA + 1√óATR), squeeze detected when difference < 0</li>
									<li><strong>Trading application:</strong> Used as an alternative strength condition to ADX in long entry signals (bear halving periods), can be toggled via <code>gate_allowTTMSqueeze</code></li>
									<li><strong>Strategy purpose:</strong> Identifies low volatility periods (squeezes) that often precede high volatility breakouts, helping time entries before major moves</li>
									<li><strong>Why it matters:</strong> Low volatility periods compress price action, and when the squeeze releases, it often results in strong directional moves - entering during or just after a squeeze can capture these explosive moves</li>
								</ul>
							</li>
							<li><strong>RVOL (Relative Volatility)</strong> - Short-term ATR (5) vs Long-term ATR (14), Threshold 0.78 for volatility alerts</li>
						</ul>
						<h4>Advanced Volatility Analysis</h4>
						<ul>
							<li><strong>GAPO (Gopalakrishnan Range Index)</strong> - Real vs noisy trend detection, Base length 5, Min-Max normalization [-1,1], Z-score normalization with tanh clamping</li>
							<li><strong>Hurst Exponent</strong> (referenced for future implementation)</li>
							<li><strong>Detrended Price Oscillator</strong> (referenced for future implementation)</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>VOLUME INDICATORS</h3>
						<h4>Volume Analysis</h4>
						<ul>
							<li><strong>Volume SMA Ratio</strong> - 20-period volume vs 20-period SMA, Volume confirmation threshold (1.1x default)</li>
							<li><strong>VWAP (Volume Weighted Average Price)</strong> - Daily session VWAP, VWAP deviation analysis</li>
							<li><strong>OBV (On-Balance Volume)</strong> - 14-period cumulative volume flow, OBV Divergence (regular and hidden)</li>
							<li><strong>Volume Profile</strong> - High Volume Nodes (HVN) - strong support/resistance, Low Volume Nodes (LVN) - breakout zones, Volume trend analysis</li>
							<li><strong>VROC (Volume Rate of Change)</strong> - 10-period volume momentum, VROC SMA and momentum analysis, VROC Divergence</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>SUPPORT & RESISTANCE INDICATORS</h3>
						<h4>Dynamic Levels</h4>
						<ul>
							<li><strong>Donchian Channels</strong> - 20-period high/low breakout system</li>
							<li><strong>Support/Resistance Detection</strong> - Pivot-based S/R levels (4-period pivots, max 5 levels), Channel width analysis (10% max), Strength-based ranking (min strength 2), Most recent resistance tracking, Underneath resistance detection (0.1-2% band)</li>
							<li><strong>Fibonacci Retracements</strong> - 0.382, 0.500, 0.618, 0.764, 0.854 levels, 150-bar lookback for high/low, Fib 0.382 avoid-long band (1% underneath)</li>
							<li><strong>Round Number Avoidance</strong> - Unique indicator that identifies psychologically significant price levels. For example, BTC crossing $20,000 or $100,000 is a HUGE event and many traders pile in limit sell orders around those zones. Only trades once price is convincingly above or below the round number by 1%. Multiples of 50, 100, 1000, 10000 are monitored with proximity range (3 points default).</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>CANDLESTICK PATTERNS üìä</h3>
						<h4>Pattern Recognition Suite</h4>
						<ul>
							<li><strong>Shooting Star</strong> üêª üìâ - Long top wick (Bearish)</li>
							<li><strong>Bull Hammer</strong> üêÇ üìà - Long bottom wick (Bullish)</li>
							<li><strong>Marubozu</strong> - Full bodied candle (strong directional signal)</li>
							<li><strong>Doji</strong> - Flat candle (indecision)</li>
							<li><strong>Engulfing</strong> - Next candle overtakes the previous (strong reversal signal)</li>
							<li><strong>3 Bull Soldiers</strong> üêÇ üìà - 3 green candles in a row (strong bullish momentum)</li>
							<li><strong>3 Bear Soldiers</strong> üêª üìâ - 3 red candles in a row (strong bearish momentum)</li>
						</ul>
						<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 15px; margin-top: 15px; border-radius: 4px;">
							<h4 style="color: #ffc107; margin-top: 0; font-size: 16px;">üí° Unique Anti-Trade Approach</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 10px; line-height: 1.6;">
								<strong>The clever twist:</strong> Candlestick patterns are sometimes used as <strong>anti-trades</strong> rather than direct signals. 
							</p>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.6;">
								For example, if a bearish shooting star appears, we do <strong>NOT</strong> take a long trade. This approach recognizes that candlestick patterns can be medicore signals on their own because they can just be noise on low timeframes. 
								Instead, we use them to filter out bad trades - if a bearish pattern forms, we avoid bullish entries, and vice versa. This helps prevent entering trades when the market structure suggests weakness.
							</p>
						</div>
						<h4>Pattern Filters</h4>
						<ul>
							<li><strong>Body size threshold</strong> - 10% of range minimum</li>
							<li><strong>Lower lows confirmation</strong> - Pattern validation</li>
							<li><strong>Star pattern detection</strong> - 78.6% threshold for wick-to-body ratio</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>ELLIOTT WAVE & HARMONIC PATTERN ANALYSIS</h3>
						<h4>Elliott Wave Patterns</h4>
						<ul>
							<li><strong>Motive Waves (1-2-3-4-5)</strong> - Bullish and bearish impulse patterns, Wave vaAdvicelidation (W3 != min of W1, W3, W5), Wave structure confirmation</li>
							<li><strong>Corrective Waves (A-B-C)</strong> - Bullish and bearish corrective patterns, Fibonacci-based validation (0.854 threshold), Box pattern for corrective waves</li>
							<li><strong>Wave Invalidation</strong> - Dot pattern for invalidated waves, Break detection (box breakouts)</li>
							<li><strong>Fibonacci Extensions</strong> - 0.500, 0.618, 0.764, 0.854 levels, Wave-based Fibonacci projections</li>
						</ul>
						<h4>Harmonic Patterns</h4>
						<ul>
							<li><strong>Gartley Pattern</strong> - Bullish and bearish Gartley formations with Fibonacci retracement validation</li>
							<li><strong>Butterfly Pattern</strong> - Extended harmonic patterns with precise Fibonacci ratios</li>
							<li><strong>Bat Pattern</strong> - Harmonic reversal patterns with specific Fibonacci relationships</li>
							<li><strong>Fibonacci Ratio Validation</strong> - Multiple Fibonacci levels (0.382, 0.500, 0.618, 0.786, 0.886, 1.272, 1.414, 1.618) required for pattern confirmation</li>
							<li><strong>Pattern Structure Rules</strong> - Complex geometric relationships between swing points (X-A-B-C-D structure validation)</li>
						</ul>
						<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 20px; margin-top: 20px; border-radius: 4px;">
							<h4 style="color: #ffc107; margin-top: 0; font-size: 18px;">üéØ The Anti-Signal Approach: Where the Real Edge Lies</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 15px; line-height: 1.7; font-size: 16px;">
								<strong>The cleverness:</strong> Elliott Wave and Harmonic Patterns are implemented as <strong>anti-signals</strong> rather than direct trade triggers. This is a sophisticated risk management approach that most trading systems completely miss.
							</p>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 15px; line-height: 1.7;">
								<strong>How it works:</strong> When a bearish harmonic pattern or Elliott Wave structure is detected, the system <strong>blocks buy signals</strong> for a time-limited window (typically 2-4 hours). Conversely, when a bullish pattern appears, <strong>sell signals are blocked</strong>. This prevents entering trades that go against powerful pattern-based market structure, even when other indicators might suggest a trade.
							</p>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 15px; line-height: 1.7;">
								<strong>Why this matters:</strong> Pattern recognition systems are notoriously difficult to code correctly because they require understanding market psychology, Fibonacci relationships, and complex geometric rules. Most algorithmic traders avoid them entirely because they're too complex. But this complexity is exactly what creates the edge - by using these patterns to <strong>filter out bad trades</strong> rather than generate new ones, we're leveraging sophisticated market structure analysis that most competitors simply don't have.
							</p>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 0; line-height: 1.7; font-weight: bold;">
								<strong>The Edge:</strong> Elliott Wave and Harmonic Pattern analysis requires implementing hundreds of rules, multiple Fibonacci retracement and extension levels, complex geometric pattern validation, and understanding wave structure relationships. This level of complexity means most quantitative trading systems and algorithms simply don't include these patterns at all. By having this capability and using it as an anti-signal filter, we're operating with a layer of market structure analysis that most competitors cannot replicate.
							</p>
						</div>
						<div style="background: rgba(156, 39, 176, 0.1); border-left: 4px solid #9c27b0; padding: 20px; margin-top: 20px; border-radius: 4px;">
							<h4 style="color: #9c27b0; margin-top: 0; font-size: 16px;">‚öôÔ∏è Technical Implementation Complexity</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 10px; line-height: 1.6;">
								<strong>Why These Patterns Are Extremely Difficult to Code:</strong>
							</p>
							<ul style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.7;">
								<li><strong>Hundreds of Rules:</strong> Elliott Wave theory requires validating wave relationships (e.g., Wave 3 cannot be the shortest, Wave 4 cannot overlap Wave 1 in impulse patterns), corrective wave structures, and pattern invalidation conditions</li>
								<li><strong>Multiple Fibonacci Levels:</strong> Harmonic patterns require precise Fibonacci ratios (0.382, 0.500, 0.618, 0.786, 0.886, 1.272, 1.414, 1.618) to be validated simultaneously across multiple swing points</li>
								<li><strong>Geometric Relationships:</strong> Patterns must satisfy complex geometric rules (e.g., X-A-B-C-D structure in harmonics, where each leg must meet specific Fibonacci retracement requirements)</li>
								<li><strong>Pattern Persistence:</strong> Systems must track pattern state over time, handle pattern invalidation, and manage time-based expiration of anti-signal blocks</li>
								<li><strong>Multi-Timeframe Validation:</strong> True pattern recognition requires analysis across multiple timeframes to confirm pattern validity</li>
							</ul>
							<p style="color: rgba(255, 255, 255, 0.9); margin-top: 15px; margin-bottom: 0; line-height: 1.7; font-style: italic;">
								This complexity is precisely why most quantitative trading systems avoid these patterns entirely. The difficulty of implementation becomes our competitive advantage - we have market structure analysis capabilities that most algorithms simply cannot replicate.
							</p>
						</div>
					</div>
					
					<div class="indicator-category">
						<h3>ADVANCED FILTERS & SIGNALS</h3>
						<h4>Cycle & Frequency Analysis</h4>
						<ul>
							<li><strong>Hilbert Transform</strong> - Cycle length detection, Real and imaginary components, Phase analysis (teal/maroon/silver fills)</li>
							<li><strong>Ehler's Roofing Filter</strong> - High-pass filter (48-period default), Super Smoother Filter (10-period, 2-3 poles), Noise reduction for trend clarity</li>
						</ul>
						<h4>Macro Regime Filters - Huge Edge, many bots can day trade, but can they take the big picture macro enviroment into consideration?</h4>
						<ul>
							<li><strong>Hidden Markov Model (AI System)</strong> - 9-state Gaussian AI machine learning model, Features: Log Returns, Volatility, RSI, MFI, Regime labels: Extreme Bearish ‚Üí Extreme Bullish, Regime persistence tracking, Transition probability analysis. Essentially, you feed AI years of .csv data, open, high, low, close, returns and indicators and it answers these questions: How long to bear/bull regimes last? What are typical returns? What is the probability of changing or persisting in the current regime. Obviously this is an edge because a human can't meaningfully analyze hundreds of thousands of data points in a giant .csv file. Many indicators say AI because it is a buzzword that sells well, which is true, but their code doesn't actually use AI. This is <span class="sparkle-ml">ACTUALLY MACHINE LEARNING!</span></li>
							<li><strong>Bitcoin Dominance Filter</strong> - 2-period EMA of Bitcoin's market cap percentage, Current dominance vs EMA comparison, Blocks buy signals when dominance is above 2 EMA (rising - bearish for altcoins), Allows buy signals when dominance is below 2 EMA (falling - bullish for altcoins), Historical data loaded from CSV for accurate EMA calculation, Daily API updates to track current dominance. This filter helps avoid buying altcoins when Bitcoin is likely to outperform, improving entry timing by aligning with market risk appetite cycles.</li>
							<li><strong>Regime Filter (BTC Halving)</strong> - Weekly timeframe EMA(20), Market price vs EMA + 0.25 ATR, RSI momentum filter (70 threshold, optional), Bullish/bearish/caution counters</li>
							<li><strong>Bearish Counter (Extended Downturn Detection)</strong> - Unique timing indicator that counts consecutive bearish bars to identify prolonged market downturns:
								<ul>
									<li><strong>How it works:</strong> Tracks consecutive bars where market conditions are bearish (price below higher timeframe EMA + 0.25 ATR, and RSI(7) below momentum threshold)</li>
									<li><strong>Counter logic:</strong> Increments on each bearish bar, resets to 0 when conditions become bullish or caution</li>
									<li><strong>Trading application:</strong> Used in long entry conditions requiring <code>bearishCounter > 300</code> (default threshold: 300 bars)</li>
									<li><strong>Strategy purpose:</strong> Identifies opportunities to buy after extremely lengthy downturns, waiting for extended bearish periods before entering long positions - essentially "buying the bottom" after sustained selling pressure</li>
									<li><strong>Why it matters:</strong> Prevents premature entries during downtrends by requiring confirmation of a prolonged bearish regime, helping to time entries when markets are oversold and potentially ready for reversal</li>
								</ul>
							</li>
						</ul>
						<h4>Market Structure</h4>
						<ul>
							<li><strong>BTC Halving Cycles</strong> - Halving dates: 2012, 2016, 2020, 2024, Bull run length: 552 bars (4H) / 2208 bars (1H), Pre-halving length: 1100 bars (4H) / 4400 bars (1H), Max bull length: 3312 bars (4H) / 13248 bars (1H), Macro cycle timing filters</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>STATISTICAL & AI INDICATORS</h3>
						<h4>Statistical Analysis</h4>
						<ul>
							<li><strong>Z-Score</strong> - 20-period Z-score of close price, Standard deviation measurement, Threshold: ¬±2.0 default</li>
							<li><strong>Technical Rating (TradingView)</strong> - TradingView's proprietary multi-indicator rating system:
								<ul>
									<li><strong>Total Rating</strong> - Combined Moving Averages + Technical Indicators score</li>
									<li><strong>Moving Averages Rating</strong> - Multiple MAs (SMA, EMA, WMA) at various periods, price position relative to MAs, MA crossover analysis</li>
									<li><strong>Technical Indicators Rating</strong> - Comprehensive analysis including: RSI, MACD, Stochastic Oscillator, ADX, CCI, Williams %R, MFI, ROC, and other momentum/trend indicators</li>
									<li>Unified scale (-1.0 to +1.0, displayed as percentage), Used for exit conditions when rating drops below thresholds</li>
								</ul>
							</li>
							<li><strong>Sharpe Ratio</strong> - Risk-adjusted return measurement, Benchmark comparison (SPX default)</li>
							<li><strong>Sortino Ratio</strong> - Downside risk-adjusted return, Risk-free rate consideration (2% default)</li>
						</ul>
						<h4>Artificial Intelligence</h4>
						<ul>
							<li><strong>Hidden Markov Model (AI Regime Detection)</strong> - 9-state regime detection, Gaussian emission probabilities, Bayesian Information Criterion (BIC) for model selection, K-Means clustering for regime labeling, Feature standardization (StandardScaler)</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>TIMING & FILTERS</h3>
						<h4>Time-Based Filters</h4>
						<ul>
							<li><strong>Day-of-Week Filter</strong> - Friday block for buy entries, Sunday night avoidance for shorts</li>
							<li><strong>Bar Confirmation</strong> - 1-bar delay for signal confirmation, Barstate.isconfirmed requirement</li>
							<li><strong>Cooldown Periods</strong> - EMA+JSON cooldown: 360 minutes, Per-symbol execution tracking</li>
						</ul>
						<h4>Risk Management Filters</h4>
						<ul>
							<li><strong>Monte Carlo Skip</strong> - Probabilistic trade skipping (0-100%), Random spread application</li>
							<li><strong>Position Filters</strong> - Flat position requirement for new entries, Bars in position tracking, Bars since no position tracking</li>
							<li><strong>Profit/Loss Filters</strong> - Trade profit percentage tracking, Minimum profit threshold (0.50%), Maximum loss threshold (-1.0%), Average take profit (6.59% in bear markets)</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>MULTI-TIMEFRAME ANALYSIS</h3>
						<h4>Timeframe Confirmation</h4>
						<ul>
							<li><strong>Multi-Timeframe (MTF) Confirmation</strong> - Daily ‚Üí Weekly ‚Üí Monthly resampling, Strength boost: +50% (weekly), +100% (monthly), MTF alignment indicators</li>
							<li><strong>Higher Timeframe Requests</strong> - 720-minute (12-hour) megabot timeframe, Weekly and monthly confirmations, Lookahead bias prevention</li>
						</ul>
					</div>
					
					<div class="indicator-category">
						<h3>CONVICTION RANKING SYSTEM</h3>
						<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; margin-bottom: 25px; font-weight: bold;">
							Every signal is ranked by conviction level based on how many layers of analysis confirmed it. 
							More stars = More filters passed = Higher reliability.
						</p>
						
						<div style="background: rgba(33, 150, 243, 0.15); border-left: 4px solid #42a5f5; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
							<h4 style="color: #42a5f5; margin-top: 0;">‚≠ê STANDARD CONVICTION</h4>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 10px;">
								<strong>Source:</strong> TradingView chart analysis<br>
								<strong>Filters passed:</strong> 100+ technical indicators working together
							</p>
							<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;">
								These signals have already passed strict confluence requirements on the TradingView platform. 
								Multiple indicators must agree before the signal fires.
							</p>
						</div>
						
						<div style="background: rgba(255, 152, 0, 0.15); border-left: 4px solid #ffa726; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
							<h4 style="color: #ffa726; margin-top: 0;">‚≠ê‚≠ê HIGH CONVICTION</h4>
							<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 10px;">
								<strong>Source:</strong> TradingView + Python double-filter<br>
								<strong>Additional filters:</strong> EMA trends, volatility checks, risk management
							</p>
							<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;">
								TradingView signal that passed a second round of filtering in our Python algorithms. 
								Additional confirmation from moving averages, volatility analysis, and risk parameters must all align.
							</p>
						</div>
						
					<div style="background: rgba(156, 39, 176, 0.15); border-left: 4px solid #ab47bc; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
						<h4 style="color: #ab47bc; margin-top: 0;">‚≠ê‚≠ê‚≠ê ULTRA HIGH CONVICTION</h4>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 10px;">
							<strong>Source:</strong> AI extreme regime + MACD alignment + Volume > SMA + cooldown<br>
							<strong>Rarity:</strong> Only triggered in the strongest market conditions
						</p>
						<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;">
							The 9-state Hidden Markov Model flags an extreme bullish/bearish regime, then we additionally require MACD in the same direction, above-average volume, and the HMM cooldown to allow it. TradingView confirmation isn‚Äôt required for these, but momentum/volume and cooldown are.
						</p>
					</div>
					
					<div style="background: rgba(244, 67, 54, 0.15); border-left: 4px solid #ef5350; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
						<h4 style="color: #ef5350; margin-top: 0;">‚≠ê‚≠ê‚≠ê‚≠ê BEST CONVICTION</h4>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 10px;">
							<strong>Source:</strong> TradingView + AI confirmation (maximum confluence)<br>
							<strong>AI layer:</strong> 9-state Hidden Markov Model analyzing market regime
						</p>
						<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;">
							<strong>The highest conviction signals.</strong> Both TradingView's 100+ technical indicators AND the AI system agree on the signal direction. 
							This maximum confluence means the AI analyzes market structure, volatility patterns, and regime shifts 
							to confirm that TradingView's setup is legitimate. The combination of both systems creates the most reliable signals.
						</p>
					</div>
						
						<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 20px; margin-top: 30px; border-radius: 4px;">
							<h4 style="color: #ffc107; margin-top: 0;">üí° How to Use the Conviction System</h4>
							<ul style="margin-bottom: 0;">
								<li><strong>Position Sizing</strong> - Consider larger positions on higher conviction signals (still maintain proper risk management)</li>
								<li><strong>Entry Timing</strong> - Standard signals may benefit from additional confirmation time.</li>
								<li><strong>Risk Tolerance</strong> - Conservative traders focus on Ultra High and Best; aggressive traders can trade all levels</li>
								<li><strong>Track Performance</strong> - Monitor which conviction levels work best for your trading style and market conditions</li>
								<li><strong>Not Guarantees</strong> - Higher conviction = higher probability, but no signal is perfect. Always use stop-losses.</li>
						</ul>
						</div>
					</div>
					
					<div class="summary-stats">
						<h3>üìà Summary Statistics</h3>
						<ul>
							<li><strong>Trend Indicators</strong>: 15+</li>
							<li><strong>Momentum Indicators</strong>: 20+ (including divergences)</li>
							<li><strong>Volatility Indicators</strong>: 10+</li>
							<li><strong>Volume Indicators</strong>: 8+</li>
							<li><strong>Support/Resistance</strong>: 6+</li>
							<li><strong>Candlestick Patterns</strong>: 8+</li>
							<li><strong>Elliott Wave & Harmonic Patterns</strong>: Complete 5-wave + ABC system, Gartley/Butterfly/Bat patterns with Fibonacci validation</li>
							<li><strong>Advanced Filters</strong>: 10+</li>
							<li><strong>Statistical/ML</strong>: 5+</li>
							<li><strong>Timing Filters</strong>: 5+</li>
							<li style="grid-column: 1 / -1; font-size: 20px; font-weight: bold; color: var(--primary-color); margin-top: 10px;"><strong>Total Unique Indicators: 100+</strong></li>
						</ul>
						
						<div class="philosophy-box">
							<h4>Signal Generation Philosophy</h4>
							<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 15px;">Trading systems employ a <strong>multi-indicator confluence approach</strong> where signals require:</p>
							<ol>
								<li><strong>Multiple confirmations</strong> across different indicator categories</li>
								<li><strong>Timeframe alignment</strong> (daily, weekly, monthly)</li>
								<li><strong>Regime awareness</strong> (HMM, halving cycles, market structure)</li>
								<li><strong>Risk filters</strong> (volatility, volume, timing)</li>
								<li><strong>Pattern recognition</strong> (Elliott Wave, Harmonic Patterns, candlesticks, parabola)</li>
								<li><strong>Statistical validation</strong> (Z-scores, Sharpe/Sortino, technical ratings)</li>
							</ol>
							<p style="color: rgba(255, 255, 255, 0.9); margin-top: 15px; font-style: italic;">This comprehensive approach ensures that only <strong>high-conviction signals</strong> with multiple layers of confirmation are generated, reducing false signals and improving trade quality.</p>
						</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- Stock Historical Signals Section (7+ days old) - Hidden by default -->
		<div id="stock-historical-container" style="margin: 40px 0 !important; padding: 0; display: none;">
			<div style="text-align: center; margin-bottom: 20px;">
				<h2 style="color: var(--primary-color); margin-bottom: 15px;">üìà Historical Stock & ETF Signals (7+ Days Old)</h2>
				<p style="color: rgba(255, 255, 255, 0.5); font-size: 14px; margin-top: 10px; max-width: 600px; margin-left: auto; margin-right: auto;">
					Stock signals older than 7 days are archived here. Stocks are long-term plays, so these signals remain relevant for extended periods.<br>
					<span id="stock-historical-count-display" style="display: block; margin-top: 10px; color: rgba(255, 255, 255, 0.7); font-weight: bold;">(<span id="stock-historical-count">0</span> archived stock signals)</span>
				</p>
			</div>
			
			<div id="stock-historical-grid" class="signals-grid" style="display: grid; background: rgba(76, 175, 80, 0.1); border: 2px solid rgba(76, 175, 80, 0.3); padding: 20px; opacity: 0.8;">
				<!-- Historical stock signals will be rendered here -->
			</div>
		</div>
		
		<!-- Old Signals Section (Crypto 1+ days old) - Hidden by default -->
		<div class="refresh-info" style="display: none;">
			Auto-refreshing every 30 seconds
		</div>
		
		<div id="old-signals-container" style="margin: 20px 0 !important; padding: 0; display: none;">
			<div style="text-align: center; margin-bottom: 20px;">
				<h2 style="color: var(--primary-color); margin-bottom: 15px;">üìú Historical Crypto Signals (1+ Days Old)</h2>
				<p style="color: rgba(255, 255, 255, 0.5); font-size: 14px; margin-top: 10px; max-width: 600px; margin-left: auto; margin-right: auto;">
					Crypto signals older than 1 day are archived here for transparency and backtesting.<br>
					The longer a signal has aged without being edited, the more proof it provides against repainting.
					<span id="old-signals-count-display" style="display: block; margin-top: 10px; color: rgba(255, 255, 255, 0.7); font-weight: bold;">(<span id="old-signals-count">0</span> archived crypto signals)</span>
				</p>
			</div>
			
			<div id="old-signals-grid" class="signals-grid" style="display: grid; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 255, 255, 0.2); padding: 20px; opacity: 0.7;">
				<!-- Old crypto signals will be rendered here -->
			</div>
		</div>
		
		<!-- Other Tips & Tricks Section -->
		<div id="other-tips-tricks" class="indicators-section" style="margin: 60px 0 40px 0; background: rgba(33, 150, 243, 0.1); border: 2px solid rgba(33, 150, 243, 0.5);">
			<div class="indicators-header">
				<h2>üí° Other Tips & Tricks</h2>
			</div>
			
			<div class="indicators-content">
				<div class="indicator-category" style="background: rgba(33, 150, 243, 0.05);">
					
					<!-- Tip 1: Liquidity Providing -->
					<div style="background: rgba(76, 175, 80, 0.1); border-left: 4px solid #4caf50; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
						<h3 style="color: #4caf50; margin-top: 0; font-size: 20px; margin-bottom: 12px;">1. üí∞ Liquidity Providing - Own the Casino</h3>
						<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 12px; line-height: 1.7;">
							Liquidity providing can be very lucrative. This is when you use a self-custodial account to be your own market maker. Two coins are needed, and one of them could be USD stable coin.
						</p>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 12px; line-height: 1.7;">
							A beginner setup would be <strong>$100 of WETH and $100 of USDC</strong>. Every time people trade, it collects fees, leading to APY from <strong>8% to 1200%+</strong>. Essentially, <strong>don't be a gambler, own the casino instead</strong>.
						</p>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.7;">
							<strong>The downside?</strong> You may end up entirely in the under performing crypto, but if you keep an eye on it, you could always just readjust that. I recommend <strong>MetaMask and Uniswap</strong> as the way to do this for a beginner, as that is where this concept originated from. Same concept applies to most other blockchains though.
						</p>
					</div>
					
					<!-- Tip 2: Hardware Wallets & Security -->
					<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
						<h3 style="color: #ffc107; margin-top: 0; font-size: 20px; margin-bottom: 12px;">2. üîí Hardware Wallets & Security</h3>
						<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 12px; line-height: 1.7;">
							If you have a large portfolio, consider getting a <strong>hardware wallet</strong>, with <strong>Trezor being the most trusted company</strong>.
						</p>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 12px; line-height: 1.7;">
							Also consider getting a <strong>fireproof safe</strong> and keeping your passwords inside of it. Or buy a <strong>specialized steel cylinder from Trezor</strong> that is designed to punch your passwords into steel.
						</p>
						<p style="color: rgba(255, 255, 255, 0.85); margin-bottom: 0; line-height: 1.7;">
							<strong>Remember:</strong> There is no help desk in crypto, so if you lose your passwords, there is nothing that can be done. <strong>You are the bank</strong>.
						</p>
					</div>
					
					<!-- Tip 3: Coinbase Advanced -->
					<div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196f3; padding: 20px; margin-bottom: 20px; border-radius: 4px;">
						<h3 style="color: #2196f3; margin-top: 0; font-size: 20px; margin-bottom: 12px;">3. üí∏ Use Coinbase Advanced Instead of the User-Friendly Version</h3>
						<p style="color: rgba(255, 255, 255, 0.9); margin-bottom: 0; line-height: 1.7;">
							<strong>Trading fees are nearly 10x cheaper!!</strong> Coinbase Advanced (formerly Coinbase Pro) offers significantly lower trading fees compared to the regular Coinbase platform. If you're making frequent trades, the savings can add up quickly and significantly improve your overall returns.
						</p>
					</div>
					
				</div>
			</div>
		</div>
		
		<script>
			let refreshInterval;
			
			// Floating Nav Toggle Function
			function toggleFloatingNav() {
				const nav = document.getElementById('floating-nav');
				if (nav.classList.contains('minimized')) {
					nav.classList.remove('minimized');
					localStorage.setItem('floating-nav-minimized', 'false');
				} else {
					nav.classList.add('minimized');
					localStorage.setItem('floating-nav-minimized', 'true');
				}
			}
			
			// Restore floating nav state on page load
			function initFloatingNav() {
				const nav = document.getElementById('floating-nav');
				const savedState = localStorage.getItem('floating-nav-minimized');
				if (savedState === 'true') {
					nav.classList.add('minimized');
				}
			}
			
			// Initialize floating nav state when page loads
			document.addEventListener('DOMContentLoaded', function() {
				initFloatingNav();
			});
			
			// Disclaimer handling
			function initDisclaimer() {
				const overlay = document.getElementById('disclaimer-overlay');
				const checkbox = document.getElementById('disclaimer-checkbox');
				const acceptBtn = document.getElementById('disclaimer-accept-btn');
				const signalsContent = document.getElementById('signals-content');
				
				// Check if user has already accepted
				const accepted = localStorage.getItem('disclaimer-accepted');
				if (accepted === 'true') {
					overlay.classList.add('disclaimer-hidden');
					return;
				}
				
				// Hide signals content until accepted
				signalsContent.style.display = 'none';
				
				// Enable/disable accept button based on checkbox
				checkbox.addEventListener('change', function() {
					acceptBtn.disabled = !checkbox.checked;
				});
				
				// Handle accept button
				acceptBtn.addEventListener('click', function() {
					if (checkbox.checked) {
						localStorage.setItem('disclaimer-accepted', 'true');
						overlay.classList.add('disclaimer-hidden');
						signalsContent.style.display = 'block';
					}
				});
			}
			
			// Initialize disclaimer on page load
			initDisclaimer();
			
			// Bull Audio Player - Click to play music
			let bullAudio = null;
			let isPlaying = false;
			
			function initBullAudio() {
				// Create audio element (hidden, no autoplay)
				bullAudio = new Audio('audio/bull_synth.mp3');
				bullAudio.loop = true; // Loop the music
				bullAudio.volume = 0.5; // Set volume to 50%
				
				// Add click handlers to all bull images
				const bullImageNav = document.getElementById('bull-image-nav');
				const bullImageInline = document.getElementById('bull-image-inline');
				const bullNavLink = document.querySelector('.bull-nav-link');
				
				window.toggleBullAudio = function() {
					if (!bullAudio) return;
					
					if (isPlaying) {
						bullAudio.pause();
						isPlaying = false;
						// Update title to indicate it can be played
						if (bullImageNav) bullImageNav.title = 'Click to play music';
						if (bullImageInline) bullImageInline.title = 'Click to play music';
						if (bullNavLink) bullNavLink.title = 'Click to play music';
					} else {
						bullAudio.play().then(() => {
							isPlaying = true;
							// Update title to indicate it can be paused
							if (bullImageNav) bullImageNav.title = 'Click to pause music';
							if (bullImageInline) bullImageInline.title = 'Click to pause music';
							if (bullNavLink) bullNavLink.title = 'Click to pause music';
						}).catch(err => {
							console.error('Error playing audio:', err);
							alert('Could not play audio. Please check your browser settings.');
						});
					}
				}
				
				// Attach click handlers
				if (bullImageNav) {
					bullImageNav.addEventListener('click', toggleBullAudio);
				}
				if (bullImageInline) {
					bullImageInline.addEventListener('click', toggleBullAudio);
				}
			}
			
			// Initialize bull audio when DOM is ready
			document.addEventListener('DOMContentLoaded', function() {
				initBullAudio();
			});
			
			function formatTimestamp(timestamp) {
				if (!timestamp) return 'N/A';
				try {
					const date = new Date(timestamp);
					// Format in UTC with clear UTC label
					const month = date.toLocaleString('en-US', { month: 'short', timeZone: 'UTC' });
					const day = date.getUTCDate();
					const year = date.getUTCFullYear();
					const hours = String(date.getUTCHours()).padStart(2, '0');
					const minutes = String(date.getUTCMinutes()).padStart(2, '0');
					const seconds = String(date.getUTCSeconds()).padStart(2, '0');
					return `${month} ${day}, ${year} ${hours}:${minutes}:${seconds} UTC`;
				} catch (e) {
					return timestamp;
				}
			}
			
			function formatPrice(price) {
				if (price === null || price === undefined) return 'N/A';
				return '$' + parseFloat(price).toFixed(4);
			}

			// Helper: pick the first available numeric price field from a signal
			function getSignalPrice(signal) {
				if (!signal) return null;
				const candidates = [
					signal.price,
					signal.avg_price,
					signal.last_price,
					signal.entry_price,
					signal.limit_price,
					signal.close,
					signal.current_price,
					signal.market_price,
					signal.bid,
					signal.ask,
					signal.last,
					signal.value
				];
				for (const c of candidates) {
					const num = parseFloat(c);
					if (!Number.isNaN(num) && num > 0) return num;
				}
				return null;
			}
			
			function formatQuantity(quantity, symbol) {
				if (quantity === null || quantity === undefined) return 'N/A';
				const qty = parseFloat(quantity);
				const formattedQty = qty.toLocaleString('en-US', {
					minimumFractionDigits: 2,
					maximumFractionDigits: 2
				});
				
				// If quantity is exactly 100, it's likely USD
				if (qty === 100) {
					return formattedQty + ' USD';
				}
				
				// Otherwise, extract asset symbol and show both quantity and asset
				if (symbol) {
					const asset = symbol.split('/')[0]; // Extract "CRV" from "CRV/USD"
					return formattedQty + ' ' + asset;
				}
				
				return formattedQty;
			}
			
			// Price cache to avoid repeated API calls
			const priceCache = new Map();
			const PRICE_CACHE_TTL = 60000; // 1 minute "fresh" cache
			const PRICE_STALE_WARN_MS = 5 * 60 * 1000; // 5 minutes: show stale warning if older than this
			const PRICE_CACHE_STORAGE_KEY = 'signals_price_cache_v1';
			
			function _safeUpper(s) {
				return (s || '').toString().trim().toUpperCase();
			}
			
			function _normalizeSymbolForPrice(symbol) {
				const raw = (symbol || '').toString().trim();
				if (!raw) return '';
				const upper = raw.toUpperCase();
				const normalized = upper.replace(/[-_]/g, '/');
				return normalized.split('/')[0];
			}
			
			function _cacheKeyForSymbol(symbol, isStock) {
				const base = _normalizeSymbolForPrice(symbol);
				if (!base) return '';
				return `${isStock ? 'stock' : 'crypto'}_${base}`;
			}
			
			function _loadPriceCacheFromStorage() {
				try {
					const raw = localStorage.getItem(PRICE_CACHE_STORAGE_KEY);
					if (!raw) return;
					const parsed = JSON.parse(raw);
					if (!parsed || typeof parsed !== 'object') return;
					for (const [k, v] of Object.entries(parsed)) {
						if (!v || typeof v !== 'object') continue;
						if (typeof v.price !== 'number' || typeof v.timestamp !== 'number') continue;
						priceCache.set(k, { price: v.price, timestamp: v.timestamp, source: v.source || '' });
					}
				} catch (e) {
					// ignore
				}
			}
			
			function _persistPriceCacheToStorage() {
				try {
					const obj = {};
					for (const [k, v] of priceCache.entries()) {
						if (!v || typeof v !== 'object') continue;
						if (typeof v.price !== 'number' || typeof v.timestamp !== 'number') continue;
						obj[k] = { price: v.price, timestamp: v.timestamp, source: v.source || '' };
					}
					localStorage.setItem(PRICE_CACHE_STORAGE_KEY, JSON.stringify(obj));
				} catch (e) {
					// ignore
				}
			}
			
			_loadPriceCacheFromStorage();
			
			function getCachedPriceEntry(symbol, isStock) {
				const k = _cacheKeyForSymbol(symbol, isStock);
				if (!k) return null;
				const entry = priceCache.get(k);
				if (!entry || typeof entry.price !== 'number' || typeof entry.timestamp !== 'number') return null;
				return { ...entry, cacheKey: k };
			}
			
			function setCachedPriceEntry(symbol, isStock, price, source) {
				const k = _cacheKeyForSymbol(symbol, isStock);
				if (!k) return;
				if (typeof price !== 'number' || !(price > 0)) return;
				priceCache.set(k, { price, timestamp: Date.now(), source: source || '' });
				_persistPriceCacheToStorage();
			}
			
			function formatPriceWithStaleWarning(price, ageMs) {
				const base = formatPrice(price);
				if (ageMs !== null && ageMs !== undefined && ageMs > PRICE_STALE_WARN_MS) {
					const mins = Math.round(ageMs / 60000);
					return `${base} <span title="Price may be stale (~${mins}m old)" style="color: rgba(255, 193, 7, 0.95); font-weight: 700; margin-left: 6px;">‚ö†Ô∏è</span>`;
				}
				return base;
			}
			
			// Deterministic DOM key: fixes intermittent updates caused by Date.now() mismatches.
			function getSignalDomKey(signal) {
				if (!signal) return 'sig-unknown';
				const id = (signal.id !== undefined && signal.id !== null) ? String(signal.id) : '';
				if (id) return id.replace(/[^a-zA-Z0-9_-]/g, '_');
				const sym = _safeUpper(signal.symbol).replace(/[^A-Z0-9._/-]/g, '').replace(/[-_]/g, '/');
				const ts = (signal.timestamp || signal.received_at || signal.time || '').toString();
				const action = _safeUpper(signal.action || signal.side || signal.type || '');
				const key = `${sym}__${ts}__${action}`;
				return key.replace(/[^a-zA-Z0-9._:-]/g, '_');
			}
			
			async function fetchJsonWithRetry(url, options = {}, retryCfg = {}) {
				const retries = Number.isFinite(retryCfg.retries) ? retryCfg.retries : 2;
				const baseDelayMs = Number.isFinite(retryCfg.baseDelayMs) ? retryCfg.baseDelayMs : 700;
				const maxDelayMs = Number.isFinite(retryCfg.maxDelayMs) ? retryCfg.maxDelayMs : 2500;
				const retryStatuses = retryCfg.retryStatuses || [429, 500, 502, 503, 504];
				
				let lastErr = null;
				for (let attempt = 0; attempt <= retries; attempt++) {
					try {
						const resp = await fetch(url, options);
						if (!resp.ok) {
							if (retryStatuses.includes(resp.status) && attempt < retries) {
								const delay = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, attempt)) + Math.floor(Math.random() * 200);
								await new Promise(r => setTimeout(r, delay));
								continue;
							}
							const err = new Error(`HTTP ${resp.status}`);
							err.status = resp.status;
							throw err;
						}
						return await resp.json();
					} catch (e) {
						lastErr = e;
						if (attempt < retries) {
							const delay = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, attempt)) + Math.floor(Math.random() * 200);
							await new Promise(r => setTimeout(r, delay));
							continue;
						}
						throw lastErr;
					}
				}
				throw lastErr || new Error('fetchJsonWithRetry failed');
			}
			
			// ============================================================================
			// PnL TRACKING FUNCTIONS (FIFO-based for DCA accounting)
			// ============================================================================
			// NOTE: This PnL tracking is completely standalone - uses only localStorage
			// It does not interact with the backend Python bot
			
			/**
			 * Calculate PnL percentage from entry price and current price
			 * @param {number} entryPrice - Price when position was opened
			 * @param {number} currentPrice - Current/sell price
			 * @returns {number|null} PnL percentage or null if invalid
			 */
			function calculatePnL(entryPrice, currentPrice) {
				if (!entryPrice || !currentPrice || entryPrice <= 0 || currentPrice <= 0) {
					return null;
				}
				return ((currentPrice - entryPrice) / entryPrice) * 100;
			}
			
			/**
			 * Format PnL percentage with color coding
			 * @param {number|null} pnl - PnL percentage
			 * @returns {string} HTML string with formatted PnL
			 */
			function formatPnL(pnl) {
				if (pnl === null || pnl === undefined) {
					return '<span style="color: rgba(255, 255, 255, 0.5);">N/A</span>';
				}
				const sign = pnl >= 0 ? '+' : '';
				const color = pnl >= 0 ? '#4caf50' : '#f44336';
				const emoji = pnl >= 0 ? 'üìà' : 'üìâ';
				return `<span style="color: ${color}; font-weight: bold;">${emoji} ${sign}${pnl.toFixed(2)}%</span>`;
			}
			
			// ============================================================================
			// PnL De-duplication + persistence (prevents intermittent PnL due to re-renders)
			// ============================================================================
			const PNL_PROCESSED_SIGNALS_KEY = 'signals_pnl_processed_v1'; // domKey -> true
			const PNL_SELL_RESULTS_KEY = 'signals_pnl_sell_results_v1'; // domKey -> { pnl:number|null, ts:number, note?:string }
			
			function _getJsonLS(key, fallback) {
				try {
					const raw = localStorage.getItem(key);
					if (!raw) return fallback;
					return JSON.parse(raw);
				} catch (e) {
					return fallback;
				}
			}
			
			function _setJsonLS(key, value) {
				try {
					localStorage.setItem(key, JSON.stringify(value));
				} catch (e) {
					// ignore
				}
			}
			
			function wasPnLSignalProcessed(domKey) {
				if (!domKey) return false;
				const seen = _getJsonLS(PNL_PROCESSED_SIGNALS_KEY, {});
				return !!seen[domKey];
			}
			
			function markPnLSignalProcessed(domKey) {
				if (!domKey) return;
				const seen = _getJsonLS(PNL_PROCESSED_SIGNALS_KEY, {});
				seen[domKey] = true;
				_setJsonLS(PNL_PROCESSED_SIGNALS_KEY, seen);
			}
			
			function getStoredSellPnL(domKey) {
				if (!domKey) return null;
				const all = _getJsonLS(PNL_SELL_RESULTS_KEY, {});
				return all[domKey] || null;
			}
			
			function setStoredSellPnL(domKey, pnl, note = '') {
				if (!domKey) return;
				const all = _getJsonLS(PNL_SELL_RESULTS_KEY, {});
				all[domKey] = { pnl: pnl === null ? null : Number(pnl), ts: Date.now(), note: note || '' };
				_setJsonLS(PNL_SELL_RESULTS_KEY, all);
			}
			
			/**
			 * Get quantity from signal (try multiple fields, default to 100)
			 * @param {Object} signal - Signal object
			 * @returns {number} Quantity or 100 as default
			 */
			function getSignalQuantity(signal) {
				if (!signal) return 100;
				const candidates = [
					signal.quantity,
					signal.qty,
					signal.amount,
					signal.size,
					signal.volume
				];
				for (const qty of candidates) {
					const num = parseFloat(qty);
					if (!Number.isNaN(num) && num > 0) return num;
				}
				return 100; // Default quantity (matches bot's default)
			}
			
			/**
			 * Store buy position in FIFO queue (localStorage)
			 * Handles multiple buys (DCA) by maintaining a queue
			 * @param {string} symbol - Symbol (e.g., "AAVE/USD")
			 * @param {number} entryPrice - Entry price
			 * @param {number} quantity - Quantity purchased (optional, defaults to 100)
			 * @param {string} timestamp - Timestamp of buy signal
			 */
			function storeBuyPosition(symbol, entryPrice, quantity, timestamp) {
				if (!symbol || !entryPrice || entryPrice <= 0) return;
				if (!quantity || quantity <= 0) quantity = 100; // Default quantity
				
				const positionKey = `position_${symbol}`;
				try {
					// Get existing FIFO queue (array of buy positions)
					const stored = localStorage.getItem(positionKey);
					let positions = stored ? JSON.parse(stored) : [];
					
					// Ensure positions is an array
					if (!Array.isArray(positions)) {
						positions = [];
					}
					
					// Add new buy to the queue (FIFO - First In First Out)
					positions.push({
						entryPrice: entryPrice,
						quantity: quantity,
						entryTime: timestamp || new Date().toISOString(),
						symbol: symbol
					});
					
					// Store updated queue
					localStorage.setItem(positionKey, JSON.stringify(positions));
					console.log(`[PnL] Stored buy position for ${symbol}: ${quantity} @ $${entryPrice} (Queue size: ${positions.length})`);
				} catch (e) {
					console.error(`[PnL] Failed to store position for ${symbol}:`, e);
				}
			}
			
			/**
			 * Get first buy position from FIFO queue (for FIFO accounting)
			 * Uses the oldest (first) buy when calculating PnL for sells
			 * @param {string} symbol - Symbol (e.g., "AAVE/USD")
			 * @returns {Object|null} First position data or null if queue is empty
			 */
			function getFirstBuyPosition(symbol) {
				if (!symbol) return null;
				
				const positionKey = `position_${symbol}`;
				try {
					const stored = localStorage.getItem(positionKey);
					if (stored) {
						const positions = JSON.parse(stored);
						if (Array.isArray(positions) && positions.length > 0) {
							return positions[0]; // Return first (oldest) buy (FIFO)
						}
					}
				} catch (e) {
					console.error(`[PnL] Failed to retrieve position for ${symbol}:`, e);
				}
				return null;
			}
			
			/**
			 * Remove first buy position from FIFO queue (after sell)
			 * Since sells are typically 100% of position, we remove the first buy
			 * TODO: Handle partial sells - if sellQuantity < position.quantity, 
			 *       reduce quantity instead of removing entire position
			 * @param {string} symbol - Symbol (e.g., "AAVE/USD")
			 * @param {number} sellQuantity - Quantity being sold (optional, for future partial sell support)
			 * @returns {boolean} True if position was removed, false otherwise
			 */
			function removeFirstBuyPosition(symbol, sellQuantity = null) {
				if (!symbol) return false;
				
				const positionKey = `position_${symbol}`;
				try {
					const stored = localStorage.getItem(positionKey);
					if (stored) {
						let positions = JSON.parse(stored);
						if (Array.isArray(positions) && positions.length > 0) {
							// TODO: Handle partial sells
							// For now, since sells are typically 100% of position, remove first position entirely
							positions.shift(); // Remove first element (FIFO)
							
							if (positions.length === 0) {
								localStorage.removeItem(positionKey);
								console.log(`[PnL] Cleared all positions for ${symbol} (queue empty)`);
							} else {
								localStorage.setItem(positionKey, JSON.stringify(positions));
								console.log(`[PnL] Removed first position for ${symbol} (Remaining: ${positions.length})`);
							}
							return true;
						}
					}
				} catch (e) {
					console.error(`[PnL] Failed to remove position for ${symbol}:`, e);
				}
				return false;
			}
			
			// Map trading symbols to CoinGecko IDs
			const coinGeckoSymbolMap = {
				'ETH/USD': 'ethereum',
				'BTC/USD': 'bitcoin',
				'SOL/USD': 'solana',
				'BONK/USD': 'bonk',
				'CRV/USD': 'curve-dao-token',
				'SUI/USD': 'sui',
				'AERO/USD': 'aerodrome-finance',
				'FET/USD': 'fetch-ai',
				'RNDR/USD': 'render-token',
				'AAVE/USD': 'aave'
			};
			
			async function fetchPriceFromCoinGecko(symbol) {
				if (!symbol) return null;
				
				// Check persisted cache first
				const cachedEntry = getCachedPriceEntry(symbol, false);
				if (cachedEntry && (Date.now() - cachedEntry.timestamp) < PRICE_CACHE_TTL) {
					return cachedEntry.price;
				}
				
				// Get CoinGecko ID
				const coinId = coinGeckoSymbolMap[symbol] || symbol.split('/')[0].toLowerCase();
				
				try {
					const url = `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`;
					const data = await fetchJsonWithRetry(url, {}, { retries: 2, baseDelayMs: 700 });
					
					if (data[coinId] && data[coinId].usd) {
						const price = data[coinId].usd;
						setCachedPriceEntry(symbol, false, price, 'coingecko');
						return price;
					}
				} catch (error) {
					// Fallback: Binance (often avoids CoinGecko rate limits for major coins)
					try {
						const base = _normalizeSymbolForPrice(symbol);
						if (base) {
							const pair = `${base}USDT`;
							const binanceUrl = `https://api.binance.com/api/v3/ticker/price?symbol=${pair}`;
							const data = await fetchJsonWithRetry(binanceUrl, {}, { retries: 2, baseDelayMs: 700 });
							if (data && data.price) {
								const price = parseFloat(data.price);
								if (!Number.isNaN(price) && price > 0) {
									setCachedPriceEntry(symbol, false, price, 'binance');
									return price;
								}
							}
						}
					} catch (e2) {
						// ignore fallback
					}
					console.error(`Error fetching price for ${symbol} from CoinGecko/Binance:`, error);
				}
				
				return null;
			}
			
			/**
			 * Fetch stock price from Yahoo Finance API (JavaScript equivalent of yfinance)
			 * @param {string} symbol - Stock symbol (e.g., "SPY", "NVDA", "AAPL")
			 * @returns {Promise<number|null>} Stock price or null if unavailable
			 */
			async function fetchStockPrice(symbol) {
				if (!symbol) return null;
				
				// Check persisted cache first
				const cachedEntry = getCachedPriceEntry(symbol, true);
				if (cachedEntry && (Date.now() - cachedEntry.timestamp) < PRICE_CACHE_TTL) {
					return cachedEntry.price;
				}
				
				try {
					// Normalize symbol for Yahoo Finance (remove /USD if present, e.g., "SPY/USD" -> "SPY")
					const normalizedSymbol = symbol.split('/')[0].toUpperCase();
					
					async function tryYahoo(host) {
						const url = `https://${host}.finance.yahoo.com/v8/finance/chart/${normalizedSymbol}?interval=1d&range=1d`;
						return await fetchJsonWithRetry(url, {}, { retries: 2, baseDelayMs: 700 });
					}
					
					// Yahoo sometimes rate limits; try query1 then query2.
					let data = null;
					try {
						data = await tryYahoo('query1');
					} catch (e1) {
						data = await tryYahoo('query2');
					}
					
					// Extract price from Yahoo Finance response
					if (data.chart && data.chart.result && data.chart.result.length > 0) {
						const result = data.chart.result[0];
						if (result.meta && result.meta.regularMarketPrice) {
							const price = result.meta.regularMarketPrice;
							setCachedPriceEntry(symbol, true, price, 'yahoo');
							return price;
						}
						// Fallback to previous close if regularMarketPrice not available
						if (result.meta && result.meta.previousClose) {
							const price = result.meta.previousClose;
							setCachedPriceEntry(symbol, true, price, 'yahoo_prev_close');
							return price;
						}
					}
				} catch (error) {
					console.error(`Error fetching stock price for ${symbol} from Yahoo Finance:`, error);
				}
				
				return null;
			}
			
			// Batch update prices with rate limiting to avoid hitting API limits
			async function updateMissingPrices(signals, opts = {}) {
				const force = !!opts.force;
				
				// Find all signals that might need price fetching (NOT TradingView-only)
				// - Fetch if missing price OR if forced OR if cached is older than "fresh" TTL
				const signalsNeedingPrice = (signals || []).filter(signal => {
					if (!signal || !signal.symbol) return false;
					const isStock = isStockSignal(signal);
					const cached = getCachedPriceEntry(signal.symbol, isStock);
					const hasAnyPrice = getSignalPrice(signal) !== null;
					if (force) return true;
					if (!hasAnyPrice) return true;
					// If the signal already has a price, seed the cache once (no fetch needed)
					if (!cached) {
						const p = getSignalPrice(signal);
						const num = parseFloat(p);
						if (!Number.isNaN(num) && num > 0) {
							setCachedPriceEntry(signal.symbol, isStock, num, 'signal');
						}
						return false;
					}
					if (cached && (Date.now() - cached.timestamp) > PRICE_CACHE_TTL) return true;
					return false;
				});
				
				if (signalsNeedingPrice.length === 0) return;
				
				console.log(`Fetching prices for ${signalsNeedingPrice.length} signals...`);
				
				// Rate limit: 1 request per 1.2 seconds (50 requests per minute, well under CoinGecko's free tier limit)
				const RATE_LIMIT_MS = 1200;
				
				for (let i = 0; i < signalsNeedingPrice.length; i++) {
					const signal = signalsNeedingPrice[i];
					const domKey = getSignalDomKey(signal);
					const priceElementId = `price-${domKey}`;
					const pnlElementId = `pnl-${domKey}`;
					const priceElement = document.getElementById(priceElementId);
					const pnlElement = document.getElementById(pnlElementId);
					
					const actionL = ((signal.action || '').toString().toLowerCase());
					const isBuy = actionL === 'buy';
					const isSell = actionL === 'sell';
					
					if (priceElement) {
						try {
							// Show cached price immediately (even if stale), then refresh if needed
							const isStock = isStockSignal(signal);
							const cached = getCachedPriceEntry(signal.symbol, isStock);
							if (cached && typeof cached.price === 'number') {
								const ageMs = Date.now() - cached.timestamp;
								priceElement.innerHTML = formatPriceWithStaleWarning(cached.price, ageMs);
								priceElement.style.color = '';
								priceElement.style.fontStyle = 'normal';
							}
							
							// Fetch fresh price unless cache is still "fresh" and not forced
							let shouldFetch = force;
							if (!shouldFetch) {
								if (!cached) shouldFetch = true;
								else if ((Date.now() - cached.timestamp) > PRICE_CACHE_TTL) shouldFetch = true;
							}
							
							let price = cached ? cached.price : null;
							if (shouldFetch) {
								if (isStock) {
									price = await fetchStockPrice(signal.symbol);
								} else {
									price = await fetchPriceFromCoinGecko(signal.symbol);
								}
							}
							
							if (price !== null && priceElement) {
								const latest = getCachedPriceEntry(signal.symbol, isStock);
								const ageMs = latest ? (Date.now() - latest.timestamp) : null;
								priceElement.innerHTML = formatPriceWithStaleWarning(price, ageMs);
								priceElement.style.color = ''; // Remove italic/gray styling
								priceElement.style.fontStyle = 'normal';
								
								// If the original signal lacked a price, keep it for downstream logic
								if (getSignalPrice(signal) === null) {
									signal.price = price;
								}
								
								// PnL when price arrives asynchronously (de-duped across refreshes):
								if (isBuy) {
									if (!wasPnLSignalProcessed(domKey)) {
										const quantity = getSignalQuantity(signal);
										storeBuyPosition(signal.symbol, price, quantity, signal.timestamp || signal.received_at);
										markPnLSignalProcessed(domKey);
									}
								} else if (isSell && pnlElement) {
									const stored = getStoredSellPnL(domKey);
									if (stored && (stored.pnl === null || typeof stored.pnl === 'number')) {
										if (typeof stored.pnl === 'number') pnlElement.innerHTML = formatPnL(stored.pnl);
										else pnlElement.innerHTML = '<span style="color: rgba(255, 165, 0, 0.8); font-style: italic;">‚ö†Ô∏è No entry data</span>';
									} else if (!wasPnLSignalProcessed(domKey)) {
										const position = getFirstBuyPosition(signal.symbol);
										if (position && position.entryPrice) {
											const pnl = calculatePnL(position.entryPrice, price);
											if (pnl !== null) {
												setStoredSellPnL(domKey, pnl, '');
												pnlElement.innerHTML = formatPnL(pnl);
											} else {
												setStoredSellPnL(domKey, null, 'Invalid price');
												pnlElement.innerHTML = '<span style="color: rgba(255, 165, 0, 0.8); font-style: italic;">‚ö†Ô∏è Invalid price</span>';
											}
											removeFirstBuyPosition(signal.symbol);
										} else {
											setStoredSellPnL(domKey, null, 'No entry data');
											pnlElement.innerHTML = '<span style="color: rgba(255, 165, 0, 0.8); font-style: italic;">‚ö†Ô∏è No entry data</span>';
										}
										markPnLSignalProcessed(domKey);
									}
								}
							} else if (priceElement) {
								priceElement.textContent = 'Price unavailable';
								priceElement.style.color = 'rgba(255, 255, 255, 0.5)';
							}
						} catch (error) {
							console.error(`Error updating price for ${signal.symbol}:`, error);
							if (priceElement) {
								priceElement.textContent = 'Price unavailable';
								priceElement.style.color = 'rgba(255, 255, 255, 0.5)';
							}
						}
					}
					
					// Rate limiting: wait between requests (except for the last one)
					if (i < signalsNeedingPrice.length - 1) {
						await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS));
					}
				}
				
				console.log('Price fetching complete');
			}
			
			async function manualRefreshPrices() {
				const btn = document.getElementById('refresh-prices-btn');
				const statusEl = document.getElementById('price-refresh-status');
				try {
					if (btn) {
						btn.disabled = true;
						btn.style.opacity = '0.7';
						btn.style.cursor = 'not-allowed';
					}
					if (statusEl) statusEl.textContent = 'Refreshing prices‚Ä¶';
					
					const signals = window.__latestSignalsForPriceRefresh || [];
					await updateMissingPrices(signals, { force: true });
					
					if (statusEl) statusEl.textContent = `Prices refreshed @ ${new Date().toLocaleTimeString()}`;
				} catch (e) {
					console.error('Manual refresh failed:', e);
					if (statusEl) statusEl.textContent = 'Refresh failed (check console).';
				} finally {
					if (btn) {
						btn.disabled = false;
						btn.style.opacity = '';
						btn.style.cursor = 'pointer';
					}
				}
			}
			
			// Function to get emojis for a ticker symbol
			function getSymbolEmojis(symbol) {
				if (!symbol) return '';
				const sym = symbol.toUpperCase();
				
				// Helper to wrap emojis in span with emoji font support
				const wrapEmojis = (emojiString) => {
					return emojiString.split(' ').map(emoji => 
						`<span style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif; font-style: normal;">${emoji}</span>`
					).join(' ');
				};
				
				// Technology (XLK, QQQ)
				if (sym === 'XLK' || sym === 'QQQ') return wrapEmojis('üíª üñ•Ô∏è üì± ü§ñ ‚öôÔ∏è');
				
				// Healthcare (XLV)
				if (sym === 'XLV') return wrapEmojis('üè• üß¨ üíä ü©∫');
				
				// Financials (XLF)
				if (sym === 'XLF') return wrapEmojis('üè¶ üí≥ üí∞ üìä üíº');
				
				// Consumer Discretionary (XLY)
				if (sym === 'XLY') return wrapEmojis('üõçÔ∏è üöó üèñÔ∏è üéÆ üçî');
				
				// Consumer Staples (XLP)
				if (sym === 'XLP') return wrapEmojis('üßÉ üßº üõçÔ∏è üçû üì¶');
				
				// Energy (XLE)
				if (sym === 'XLE') return wrapEmojis('üõ¢Ô∏è ‚õΩ üî• ‚ö° üåç');
				
				// Industrials (XLI)
				if (sym === 'XLI') return wrapEmojis('üè≠ ‚öôÔ∏è üöõ üèóÔ∏è üî®');
				
				// Materials (XLB)
				if (sym === 'XLB') return wrapEmojis('üß± ü™® ‚öíÔ∏è üß™ üßØ');
				
				// Utilities (XLU)
				if (sym === 'XLU') return wrapEmojis('‚ö° üí° üîå üö∞ üåä');
				
				// Real Estate (XLRE)
				if (sym === 'XLRE') return wrapEmojis('üè†');
				
				// Communication Services (XLC)
				if (sym === 'XLC') return wrapEmojis('üì°');
				
				// Gold / Precious Metals (GLD, GDX)
				if (sym === 'GLD' || sym === 'GDX') return wrapEmojis('üèÖ');
				
				// Silver
				if (sym === 'SLV') return wrapEmojis('ü•à');
				
				// Commodities (DBC, PDBC)
				if (sym === 'DBC' || sym === 'PDBC') return 'üåæ üõ¢Ô∏è ü™® ‚öíÔ∏è';
				
				// Bonds / Fixed Income (TLT, BND)
				if (sym === 'TLT' || sym === 'BND') return 'üè¶  üíµ';
				
				// Treasuries
				if (sym === 'TLT' || sym.includes('TREASURY')) return 'üèõÔ∏è üíµ';
				
				// Dividend / Income ETFs
				if (sym.includes('DIV') || sym.includes('INCOME')) return 'üè¶ üíµ';
				
				// Growth ETFs
				if (sym.includes('GROWTH')) return 'üöÄ üìà üå±';
				
				// Value ETFs
				if (sym.includes('VALUE')) return 'üíé';
				
				// Broad Market (SPY, VTI)
				if (sym === 'SPY' || sym === 'VTI') return 'üåç';
				
				// Small Cap (IWM)
				if (sym === 'IWM') return 'üê£';
				
				// Mid Cap
				if (sym.includes('MID')) return 'üè¢';
				
				// International / Global
				if (sym === 'EEM' || sym === 'MCHI' || sym === 'INDA' || sym === 'EWJ' || sym === 'EWG' || sym === 'EWT') return 'üåç';
				
				// Emerging Markets
				if (sym === 'EEM') return 'üå± üåé üìà';
				
				// Volatility (VIX, UVXY)
				if (sym === 'VIX' || sym === 'UVXY') return 'üå™Ô∏è ‚ö†Ô∏è üìâ';
				
				// Defensive / Risk-Off
				if (sym.includes('DEFENSIVE') || sym.includes('RISK')) return 'üõ°Ô∏è';
				
				// Crypto / Digital Assets
				if (sym.includes('BTC') || sym === 'BITCOIN') return '‚Çø';
				if (sym.includes('ETH') || sym === 'ETHEREUM') return 'üî∑';
				
				// Semiconductor (SOXX)
				if (sym === 'SOXX') return 'üíª üñ•Ô∏è üì± ü§ñ ‚öôÔ∏è';
				
				// NVIDIA (NVDA)
				if (sym === 'NVDA') return 'üíª üñ•Ô∏è üì± ü§ñ ‚öôÔ∏è';
				
				// Platinum (PPLT)
				if (sym === 'PPLT') return 'ü™ô ‚õèÔ∏è üßà';
				
				// Palladium (PALL)
				if (sym === 'PALL') return 'ü™ô ‚õèÔ∏è üßà';
				
				// Oil (USO)
				if (sym === 'USO') return 'üõ¢Ô∏è ‚õΩ';
				
				// Credit (PCEF, HYG)
				if (sym === 'PCEF' || sym === 'HYG') return 'üè¶ üìÑ üíµ';
				
				return '';
			}
			
			// Function to identify if a signal is a stock/ETF (not crypto)
			function isStockSignal(signal) {
				const raw = (signal.symbol || '').trim();
				if (!raw) return false;
				const sym = raw.toUpperCase();
				const normalized = sym.replace(/[-_]/g, '/'); // allow XLK-USD ‚Üí XLK/USD

				// Treat obvious crypto pairs (crypto quote leg) as NOT stocks
				if (normalized.includes('/') && /\/(USD|USDT|USDC|BTC|ETH)$/i.test(normalized)) {
					return false;
				}

				// Plain tickers (e.g., SPY, XLK, NVDA, GLD, SLV, PPLT)
				if (/^[A-Z]{1,6}$/.test(sym)) return true;

				// Ticker with fiat suffix separated by slash (XLK/USD, NVDA/USD)
				const parts = normalized.split('/');
				if (
					parts.length === 2 &&
					/^[A-Z]+$/.test(parts[0]) &&
					parts[0].length <= 6 &&
					['USD', 'USDT', 'USDC'].includes(parts[1])
				) {
					return true;
				}

				// Dot-style tickers (e.g., BRK.B, XLK.US)
				if (/^[A-Z]{1,5}\.[A-Z]{1,3}$/.test(sym)) return true;

				return false;
			}
			
			function switchToCrypto() {
				const cryptoContainer = document.getElementById('crypto-signals-container');
				const stockContainer = document.getElementById('stock-signals-container');
				const assetListContainer = document.getElementById('asset-list-container');
				
				// Show crypto, hide stocks and asset list
				if (cryptoContainer) cryptoContainer.style.display = 'block';
				if (stockContainer) stockContainer.style.display = 'none';
				if (assetListContainer) assetListContainer.style.display = 'none';
				
				// Scroll to crypto section
				setTimeout(() => {
					if (cryptoContainer) {
						cryptoContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}
				}, 100);
			}
			
			function switchToStocks() {
				const cryptoContainer = document.getElementById('crypto-signals-container');
				const stockContainer = document.getElementById('stock-signals-container');
				const stockHistoricalContainer = document.getElementById('stock-historical-container');
				const assetListContainer = document.getElementById('asset-list-container');
				
				// Hide crypto and asset list, show stocks
				if (cryptoContainer) cryptoContainer.style.display = 'none';
				if (stockContainer) stockContainer.style.display = 'block';
				if (stockHistoricalContainer) stockHistoricalContainer.style.display = 'block';
				if (assetListContainer) assetListContainer.style.display = 'none';
				
				// Scroll to stock signals section
					setTimeout(() => {
					if (stockContainer) {
						stockContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}
					}, 100);
			}
			
			function showStockSignals() {
				// Redirect to the new navigation system
				switchToStocks();
			}
			
			function showHistoricalSignals() {
				const oldContainer = document.getElementById('old-signals-container');
				const oldGrid = document.getElementById('old-signals-grid');
				
				if (!oldContainer) return;
				
				// Toggle visibility
				if (oldContainer.style.display === 'none' || oldContainer.style.display === '') {
					// Show historical crypto signals
					oldContainer.style.display = 'block';
					if (oldGrid) {
						oldGrid.style.display = 'grid';
					}
					// Scroll to the historical signals section
					setTimeout(() => {
						oldContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				} else {
					// Hide historical signals
					oldContainer.style.display = 'none';
					if (oldGrid) {
						oldGrid.style.display = 'none';
					}
					// Scroll back to top
					window.scrollTo({ top: 0, behavior: 'smooth' });
				}
			}
			
			function showAssetList() {
				const assetsTradedSection = document.getElementById('assets-traded-section');
				const assetListContainer = document.getElementById('asset-list-container');
				const cryptoContainer = document.getElementById('crypto-signals-container');
				const stockContainer = document.getElementById('stock-signals-container');
				
				// Hide other sections
				if (cryptoContainer) cryptoContainer.style.display = 'none';
				if (stockContainer) stockContainer.style.display = 'none';
				
				// Show asset list container if it exists
				if (assetListContainer) {
					assetListContainer.style.display = 'block';
				}
				
				// Scroll to Assets Traded section
				if (assetsTradedSection) {
					setTimeout(() => {
						assetsTradedSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				} else if (assetListContainer) {
					setTimeout(() => {
						assetListContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				}
				
				// Render the asset list if we have signals
				if (window.allSignals && window.allSignals.length > 0) {
					renderAssetList(window.allSignals);
				}
			}
			
			function showCodeExplanation() {
				const section = document.getElementById('comprehensive-indicator-analysis');
				if (section) {
					setTimeout(() => {
						section.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				}
			}
			
			function showCodeForSale() {
				const section = document.getElementById('code-download-section');
				if (section) {
					setTimeout(() => {
						section.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				}
			}
			
			function showMiscellaneousTips() {
				const section = document.getElementById('other-tips-tricks');
				if (section) {
					setTimeout(() => {
						section.scrollIntoView({ behavior: 'smooth', block: 'start' });
					}, 100);
				}
			}
			
			function renderAssetList(signals) {
				if (!signals || signals.length === 0) {
					document.getElementById('crypto-asset-list').innerHTML = '<div class="empty-state"><p>No signals available</p></div>';
					document.getElementById('stock-asset-list').innerHTML = '<div class="empty-state"><p>No signals available</p></div>';
					return;
				}
				
				// Create a map to store the most recent signal per asset
				const assetMap = new Map();
				
				// Process all signals to find the most recent one per asset
				signals.forEach(signal => {
					const symbol = signal.symbol || '';
					const timestamp = new Date(signal.timestamp || signal.received_at).getTime();
					const price = getSignalPrice(signal);
					
					// Check if we already have a signal for this asset
					if (!assetMap.has(symbol) || timestamp > assetMap.get(symbol).timestamp) {
						assetMap.set(symbol, {
							symbol: symbol,
							action: signal.action || 'unknown',
							price: price,
							timestamp: timestamp,
							note: signal.note || '',
							source: signal.source || ''
						});
					}
				});
				
				// Separate crypto and stocks
				const cryptoAssets = [];
				const stockAssets = [];
				
				assetMap.forEach((assetData, symbol) => {
					if (isStockSignal({ symbol: symbol })) {
						stockAssets.push(assetData);
					} else {
						cryptoAssets.push(assetData);
					}
				});
				
				// Sort alphabetically
				cryptoAssets.sort((a, b) => a.symbol.localeCompare(b.symbol));
				stockAssets.sort((a, b) => a.symbol.localeCompare(b.symbol));
				
				// Render crypto assets
				const cryptoList = document.getElementById('crypto-asset-list');
				if (cryptoAssets.length === 0) {
					cryptoList.innerHTML = '<div class="empty-state"><p>No cryptocurrency signals available</p></div>';
				} else {
					cryptoList.innerHTML = cryptoAssets.map(asset => renderAssetItem(asset)).join('');
				}
				
				// Render stock assets
				const stockList = document.getElementById('stock-asset-list');
				if (stockAssets.length === 0) {
					stockList.innerHTML = '<div class="empty-state"><p>No stock signals available</p></div>';
				} else {
					stockList.innerHTML = stockAssets.map(asset => renderAssetItem(asset)).join('');
				}
			}
			
			function renderAssetItem(asset) {
				const isBuy = asset.action.toLowerCase() === 'buy';
				const actionClass = isBuy ? 'buy' : 'sell';
				const actionEmoji = isBuy ? 'üü¢ üìà' : 'üî¥ üìâ';
				
				// Get emojis for this symbol
				const symbolEmojis = getSymbolEmojis(asset.symbol);
				const symbolDisplay = symbolEmojis ? `${symbolEmojis} ${asset.symbol}` : asset.symbol;
				
				// Determine conviction badge
				let signalBadge = '';
				let signalClass = '';
				const note = asset.note || '';
				if (note.includes('Pure JSON Trade')) {
					signalBadge = '‚≠ê';
					signalClass = 'confluence-pure';
				} else if (note.includes('EMA + JSON')) {
					signalBadge = '‚≠ê‚≠ê';
					signalClass = 'confluence-ema';
			} else if (note.includes('HMM + JSON') || note.includes('AI + JSON')) {
				signalBadge = '‚≠ê‚≠ê‚≠ê‚≠ê';
				signalClass = 'confluence-hmm';
			} else if (note.includes('HMM Extreme') || note.includes('AI Extreme')) {
				signalBadge = '‚≠ê‚≠ê‚≠ê';
				signalClass = 'confluence-extreme';
			}
				
				const isWatched = isInWatchlist(asset.symbol);
				const watchButtonHtml = `
					<button class="watch-button ${isWatched ? 'watched' : ''}" 
							onclick="toggleWatchlist('${asset.symbol.replace(/'/g, "\\'")}'); event.stopPropagation();"
							title="${isWatched ? 'Remove from watchlist' : 'Add to watchlist'}"
							style="background: ${isWatched ? 'rgba(255, 193, 7, 0.3)' : 'rgba(255, 255, 255, 0.1)'}; 
								   border: 1px solid ${isWatched ? '#ffc107' : 'rgba(255, 255, 255, 0.3)'}; 
								   color: ${isWatched ? '#ffc107' : 'rgba(255, 255, 255, 0.7)'}; 
								   padding: 4px 8px; 
								   border-radius: 4px; 
								   cursor: pointer; 
								   font-size: 16px;
								   transition: all 0.2s;">
						${isWatched ? '‚≠ê' : '‚òÜ'}
					</button>
				`;
				
				return `
					<div class="asset-list-item ${actionClass}">
						<div>
							<div style="display: flex; align-items: center; gap: 8px;">
								<div class="asset-name">${symbolDisplay}</div>
								${watchButtonHtml}
							</div>
							${asset.price !== null && asset.price !== undefined ? `
								<div class="asset-signal-price">${formatPrice(asset.price)}</div>
							` : ''}
						</div>
						<div class="asset-signal">
							<div style="display: flex; align-items: center; gap: 8px;">
								<span class="asset-signal-action ${actionClass}">${actionEmoji} ${asset.action.toUpperCase()}</span>
								${signalBadge ? `<span class="confluence-badge ${signalClass}" style="font-size: 12px;">${signalBadge}</span>` : ''}
							</div>
							<div class="asset-signal-time">${formatTimestamp(new Date(asset.timestamp))}</div>
						</div>
					</div>
				`;
			}
			
			function renderMarketBreadth(signals) {
				// Extract stock signals only
				const stockSignals = signals.filter(s => isStockSignal(s));
				
				if (stockSignals.length === 0) {
					document.getElementById('market-breadth-content').innerHTML = 
						'<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">No stock signals available for market breadth analysis</div>';
					return;
				}
				
				// Constants for thresholds (same as Top 3)
				const BUY_THRESHOLD = 16;  // ‚â•16/38 (‚âà42%)
				const SELL_THRESHOLD = 13; // ‚â•13/37 (‚âà35%)
				
				// Calculate market breadth
				let totalSymbols = 0;
				let buyCount = 0;
				let sellCount = 0;
				let mixedCount = 0;
				let neutralCount = 0;
				
				stockSignals.forEach(signal => {
					// Extract scores
					let buyScore = 0, sellScore = 0;
					
					if (signal.buy_score !== undefined) {
						buyScore = signal.buy_score;
					}
					if (signal.sell_score !== undefined) {
						sellScore = signal.sell_score;
					}
					
					// Try parsing from note if available
					const note = signal.note || '';
					const buyMatch = note.match(/buy\s+(\d+)\/(\d+)/i);
					const sellMatch = note.match(/sell\s+(\d+)\/(\d+)/i);
					
					if (buyMatch) {
						buyScore = parseInt(buyMatch[1]);
					}
					if (sellMatch) {
						sellScore = parseInt(sellMatch[1]);
					}
					
					// Determine if signal meets thresholds
					const hasBuySignal = buyScore >= BUY_THRESHOLD;
					const hasSellSignal = sellScore >= SELL_THRESHOLD;
					
					totalSymbols++;
					
					if (hasBuySignal && hasSellSignal) {
						mixedCount++;
					} else if (hasBuySignal) {
						buyCount++;
					} else if (hasSellSignal) {
						sellCount++;
					} else {
						neutralCount++;
					}
				});
				
				// Calculate percentages
				const buyPct = totalSymbols > 0 ? (buyCount / totalSymbols) : 0;
				const sellPct = totalSymbols > 0 ? (sellCount / totalSymbols) : 0;
				const mixedPct = totalSymbols > 0 ? (mixedCount / totalSymbols) : 0;
				const neutralPct = totalSymbols > 0 ? (neutralCount / totalSymbols) : 0;
				
				// Determine if bearish warning is needed (>50% bearish)
				const isBearish = sellPct > 0.50;
				
				// Render market breadth
				const breadthContainer = document.getElementById('market-breadth-content');
				let warningHtml = '';
				
				if (isBearish) {
					warningHtml = `
						<div style="background: rgba(244, 67, 54, 0.2); border: 2px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 15px;">
							<div style="color: #f44336; font-weight: bold; font-size: 18px; margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
								<span>üö® BEARISH MARKET WARNING</span>
							</div>
							<div style="color: rgba(255, 255, 255, 0.95); font-size: 16px; line-height: 1.6;">
								<strong>${(sellPct * 100).toFixed(0)}% of scanned assets</strong> (${sellCount}/${totalSymbols}) are showing SELL signals. 
								Market breadth indicates <strong>bearish conditions</strong>.
							</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 15px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
								‚ö†Ô∏è <strong>Exercise caution when taking long positions</strong> - even if individual assets show BUY signals, 
								the overall market environment is bearish. Consider:
								<ul style="margin: 10px 0 0 20px; padding-left: 10px;">
									<li>Reducing position sizes on long trades</li>
									<li>Waiting for market breadth to improve before entering new longs</li>
									<li>Using tighter stop-losses to protect capital</li>
									<li>Focusing on defensive assets or cash positions</li>
								</ul>
							</div>
						</div>
					`;
				}
				
				breadthContainer.innerHTML = `
					${warningHtml}
					<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: ${isBearish ? '0' : '15px'};">
						<div style="background: rgba(76, 175, 80, 0.15); border: 2px solid rgba(76, 175, 80, 0.5); border-radius: 8px; padding: 15px; text-align: center;">
							<div style="color: #4caf50; font-size: 32px; font-weight: bold; margin-bottom: 5px;">${(buyPct * 100).toFixed(0)}%</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 5px;">üü¢ BUY Signals</div>
							<div style="color: rgba(255, 255, 255, 0.7); font-size: 12px;">${buyCount} of ${totalSymbols} assets</div>
						</div>
						<div style="background: rgba(244, 67, 54, 0.15); border: 2px solid rgba(244, 67, 54, 0.5); border-radius: 8px; padding: 15px; text-align: center;">
							<div style="color: #f44336; font-size: 32px; font-weight: bold; margin-bottom: 5px;">${(sellPct * 100).toFixed(0)}%</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 5px;">üî¥ SELL Signals</div>
							<div style="color: rgba(255, 255, 255, 0.7); font-size: 12px;">${sellCount} of ${totalSymbols} assets</div>
						</div>
						<div style="background: rgba(255, 193, 7, 0.15); border: 2px solid rgba(255, 193, 7, 0.5); border-radius: 8px; padding: 15px; text-align: center;">
							<div style="color: #ffc107; font-size: 32px; font-weight: bold; margin-bottom: 5px;">${(mixedPct * 100).toFixed(0)}%</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 5px;">üü° MIXED Signals</div>
							<div style="color: rgba(255, 255, 255, 0.7); font-size: 12px;">${mixedCount} of ${totalSymbols} assets</div>
						</div>
						<div style="background: rgba(158, 158, 158, 0.15); border: 2px solid rgba(158, 158, 158, 0.5); border-radius: 8px; padding: 15px; text-align: center;">
							<div style="color: #9e9e9e; font-size: 32px; font-weight: bold; margin-bottom: 5px;">${(neutralPct * 100).toFixed(0)}%</div>
							<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 5px;">‚ö™ NEUTRAL</div>
							<div style="color: rgba(255, 255, 255, 0.7); font-size: 12px;">${neutralCount} of ${totalSymbols} assets</div>
						</div>
					</div>
				`;
			}
			
			// Bitcoin Dominance tracking
			async function fetchBitcoinDominance() {
				try {
					const response = await fetch('https://api.coingecko.com/api/v3/global');
					const data = await response.json();
					const btcDominance = data.data.market_cap_percentage.btc;
					return btcDominance;
				} catch (error) {
					console.error('Error fetching Bitcoin dominance:', error);
					return null;
				}
			}
			
			async function updateBitcoinDominanceWarning() {
				try {
					const currentDominance = await fetchBitcoinDominance();
					if (currentDominance === null) {
						return;
					}
					
					// Get stored previous dominance values
					const storedData = localStorage.getItem('btc_dominance_history');
					let dominanceHistory = storedData ? JSON.parse(storedData) : [];
					
					// Add current value with timestamp
					const now = Date.now();
					dominanceHistory.push({
						value: currentDominance,
						timestamp: now
					});
					
					// Keep only last 7 days of data (cleanup old entries)
					const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
					dominanceHistory = dominanceHistory.filter(entry => entry.timestamp > sevenDaysAgo);
					
					// Save updated history
					localStorage.setItem('btc_dominance_history', JSON.stringify(dominanceHistory));
					
					// Get DOM elements
					const warningDiv = document.getElementById('btc-dominance-warning');
					const infoDiv = document.getElementById('btc-dominance-info');
					
					// Determine trend: rising, falling, or stable
					if (dominanceHistory.length >= 6) {
						const sorted = dominanceHistory.sort((a, b) => a.timestamp - b.timestamp);
						const recent = sorted.slice(-3); // Last 3 entries
						const previous = sorted.slice(-6, -3); // Previous 3 entries
						
						const recentAvg = recent.reduce((sum, e) => sum + e.value, 0) / recent.length;
						const previousAvg = previous.reduce((sum, e) => sum + e.value, 0) / previous.length;
						const change = recentAvg - previousAvg;
						const changePercent = (change / previousAvg) * 100;
						
						// Determine trend: rising if change > 0.5%, falling if change < -0.5%, otherwise stable
						if (changePercent > 0.5) {
							// RISING - Show warning
							if (warningDiv) warningDiv.style.display = 'block';
							if (infoDiv) infoDiv.style.display = 'none';
						} else if (changePercent < -0.5) {
							// FALLING - Show safe to proceed message
							if (warningDiv) warningDiv.style.display = 'none';
							if (infoDiv) {
								infoDiv.style.display = 'block';
								infoDiv.innerHTML = `
									<div style="color: #4caf50; font-weight: bold; font-size: 16px; margin-bottom: 8px;">
										‚úÖ SAFE TO PROCEED - Bitcoin Dominance Declining
									</div>
									<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.6;">
										Bitcoin dominance is <strong>trending downwards</strong> (${changePercent.toFixed(2)}% change), which typically indicates capital is flowing from Bitcoin into altcoins. This environment is generally <strong>more favorable for altcoin long positions</strong>.
									</div>
								`;
							}
						} else {
							// STABLE - Show neutral message
							if (warningDiv) warningDiv.style.display = 'none';
							if (infoDiv) {
								infoDiv.style.display = 'block';
								infoDiv.innerHTML = `
									<div style="color: #ffc107; font-weight: bold; font-size: 16px; margin-bottom: 8px;">
										‚öñÔ∏è Bitcoin Dominance Stable
									</div>
									<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.6;">
										Bitcoin dominance appears relatively stable (${changePercent.toFixed(2)}% change). This is a neutral environment for altcoin trading. Always use proper risk management regardless of dominance trends.
									</div>
								`;
							}
						}
					} else {
						// Not enough data yet, show neutral message by default
						if (warningDiv) warningDiv.style.display = 'none';
						if (infoDiv) {
							infoDiv.style.display = 'block';
							infoDiv.innerHTML = `
								<div style="color: #9e9e9e; font-weight: bold; font-size: 16px; margin-bottom: 8px;">
									‚è≥ Collecting Data
								</div>
								<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; line-height: 1.6;">
									Collecting Bitcoin dominance data to determine trend. Check back in a few minutes.
								</div>
							`;
						}
					}
				} catch (error) {
					console.error('Error updating Bitcoin dominance warning:', error);
				}
			}
			
			/**
			 * Check if current time is within the weekend halting period.
			 * Halts processing from Friday 8 PM (20:00) to Sunday 8 PM (20:00).
			 * This matches the backend logic and allows Sunday night trading to be processed.
			 * @returns {boolean} True if it's within the halt period
			 */
			function isInWeekendHaltingPeriod() {
				const now = new Date();
				const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, ..., 5=Saturday, 6=Sunday
				const currentHour = now.getHours();
				
				// Saturday: always halt (all day)
				if (dayOfWeek === 6) { // Saturday
					return true;
				}
				
				// Friday after 8 PM: halt
				if (dayOfWeek === 5 && currentHour >= 20) { // Friday, 8 PM or later
					return true;
				}
				
				// Sunday before 8 PM: halt
				if (dayOfWeek === 0 && currentHour < 20) { // Sunday, before 8 PM
					return true;
				}
				
				// All other times: not in halt period
				return false;
			}
			
			function renderTop3Signals(signals) {
				// Extract stock signals only
				const stockSignals = signals.filter(s => isStockSignal(s));
				
				console.log('üîç renderTop3Signals - Total signals:', signals.length, 'Stock signals:', stockSignals.length);
				
				// Filter to recent stock signals (last 7 days) - ensures Friday's signals appear on Monday
				const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
				const recentStockSignals = stockSignals.filter(signal => {
					const timestamp = new Date(signal.timestamp || signal.received_at);
					return timestamp.getTime() > sevenDaysAgo;
				});
				
				console.log('üîç renderTop3Signals - Recent stock signals (last 7 days):', recentStockSignals.length);
				
				// Show/hide weekend warning (matches backend halt period: Friday 8 PM - Sunday 8 PM)
				const weekendWarningBuy = document.getElementById('weekend-warning-buy');
				const weekendWarningSell = document.getElementById('weekend-warning-sell');
				if (isInWeekendHaltingPeriod()) {
					if (weekendWarningBuy) weekendWarningBuy.style.display = 'block';
					if (weekendWarningSell) weekendWarningSell.style.display = 'block';
				} else {
					if (weekendWarningBuy) weekendWarningBuy.style.display = 'none';
					if (weekendWarningSell) weekendWarningSell.style.display = 'none';
				}
				
				// Render market breadth first (using all stock signals for context)
				renderMarketBreadth(signals);
				
				if (recentStockSignals.length === 0) {
					document.getElementById('top-buy-signals').innerHTML = '<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">No stock signals available</div>';
					document.getElementById('top-sell-signals').innerHTML = '<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">No stock signals available</div>';
					return;
				}
				
				// Constants for thresholds
				const BUY_THRESHOLD = 16;  // ‚â•16/38 (‚âà42%)
				const SELL_THRESHOLD = 13; // ‚â•13/37 (‚âà35%)
				
				// Extract scores from signals (if available in metadata)
				// Signals might have buy_score, sell_score, total_buy, total_sell in note or metadata
				const signalsWithScores = recentStockSignals.map(signal => {
					// Try to extract scores from note or metadata
					let buyScore = 0, sellScore = 0, totalBuy = 38, totalSell = 37;
					
					// Check if signal has score metadata
					if (signal.buy_score !== undefined) {
						buyScore = signal.buy_score;
						totalBuy = signal.total_buy_components || 38;
					}
					if (signal.sell_score !== undefined) {
						sellScore = signal.sell_score;
						totalSell = signal.total_sell_components || 37;
					}
					
					// Try parsing from note if available
					const note = signal.note || '';
					const buyMatch = note.match(/buy\s+(\d+)\/(\d+)/i);
					const sellMatch = note.match(/sell\s+(\d+)\/(\d+)/i);
					
					if (buyMatch) {
						buyScore = parseInt(buyMatch[1]);
						totalBuy = parseInt(buyMatch[2]);
					}
					if (sellMatch) {
						sellScore = parseInt(sellMatch[1]);
						totalSell = parseInt(sellMatch[2]);
					}
					
					// Determine action from scores if not explicitly set
					let action = signal.action;
					if (!action || action === '') {
						// If no explicit action, use the higher score to determine
						action = buyScore > sellScore ? 'buy' : (sellScore > buyScore ? 'sell' : 'buy');
					}
					
					return {
						symbol: signal.symbol || 'N/A',
						price: getSignalPrice(signal),
						buyScore: buyScore,
						sellScore: sellScore,
						totalBuy: totalBuy,
						totalSell: totalSell,
						action: action ? action.toLowerCase() : 'buy',
						timestamp: signal.timestamp || signal.received_at,
						sector: signal.sector || 'N/A',
						note: signal.note || '',
						// Exclude blocked-buy candidates from Top 3, but still show them as cards below.
						buyBlockedRsiBearDiv: !!signal.buy_blocked_rsi_bear_div || (signal.note || '').toLowerCase().includes('high divergences detected'),
						buySignalRaw: !!signal.buy_signal_raw
					};
				});
				
				// Sort by buy_score descending - show top 3 regardless of threshold or score value
				// Include all signals, using buy_score to rank them (even if 0)
				// Deduplicate by symbol to prevent same ticker appearing multiple times
				const seenBuySymbols = new Set();
				const topBuy = signalsWithScores
					.filter(s => {
						// Don't show blocked buys in Top 3 BUY list (they should appear as warning cards below instead).
						if (s.buyBlockedRsiBearDiv) return false;

						// Include if explicitly marked as buy, OR if buy_score >= sell_score (best buy candidates)
						// This ensures we show the "best" buy signals even if scores are low
						return s.action === 'buy' || s.buyScore >= s.sellScore;
					})
					.sort((a, b) => b.buyScore - a.buyScore)
					.filter(s => {
						// Deduplicate: keep only first occurrence of each symbol (highest score)
						if (seenBuySymbols.has(s.symbol)) {
							return false;
						}
						seenBuySymbols.add(s.symbol);
						return true;
					})
					.slice(0, 3);
				
				// Sort by sell_score descending - show top 3 regardless of threshold or score value
				// Include all signals, using sell_score to rank them (even if 0)
				// Deduplicate by symbol to prevent same ticker appearing multiple times
				const seenSellSymbols = new Set();
				const topSell = signalsWithScores
					.filter(s => {
						// Include if explicitly marked as sell, OR if sell_score >= buy_score (best sell candidates)
						// This ensures we show the "best" sell signals even if scores are low
						return s.action === 'sell' || s.sellScore >= s.buyScore;
					})
					.sort((a, b) => b.sellScore - a.sellScore)
					.filter(s => {
						// Deduplicate: keep only first occurrence of each symbol (highest score)
						if (seenSellSymbols.has(s.symbol)) {
							return false;
						}
						seenSellSymbols.add(s.symbol);
						return true;
					})
					.slice(0, 3);
				
				console.log('üìä Top 3 BUY:', topBuy.length, 'Top 3 SELL:', topSell.length);
				
				// Render Top 3 BUY
				const buyContainer = document.getElementById('top-buy-signals');
				if (topBuy.length === 0) {
					buyContainer.innerHTML = '<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">No BUY signals available<br><small style="font-style: italic;">No valid signals found in the data.</small></div>';
				} else {
					buyContainer.innerHTML = topBuy.map((signal, idx) => {
						const metThreshold = signal.buyScore >= BUY_THRESHOLD;
						const thresholdStatus = metThreshold 
							? `<span style="color: #4caf50; font-weight: bold;">‚úÖ Met (‚â•${BUY_THRESHOLD})</span>`
							: `<span style="color: #ffc107; font-weight: bold;">‚ö†Ô∏è Need ${BUY_THRESHOLD - signal.buyScore} more (threshold: ‚â•${BUY_THRESHOLD})</span>`;
						
						const symbolEmojis = getSymbolEmojis(signal.symbol);
						const symbolDisplay = symbolEmojis ? `${symbolEmojis} ${signal.symbol}` : signal.symbol;
						
						// Format timestamp
						let timestampDisplay = '';
						if (signal.timestamp) {
							try {
								const signalTime = new Date(signal.timestamp);
								const timeAgo = formatTimeAgo(signalTime);
								const fullTimestamp = formatTimestamp(signal.timestamp);
								timestampDisplay = `<div style="color: rgba(255, 255, 255, 0.6); font-size: 12px; margin-top: 6px;">
									üïê ${timeAgo} <span style="color: rgba(255, 255, 255, 0.5);">(${fullTimestamp})</span>
								</div>`;
							} catch (e) {
								// If timestamp parsing fails, skip it
							}
						}
						
						return `
							<div style="background: rgba(0, 0, 0, 0.3); padding: 15px; margin-bottom: 12px; border-radius: 6px; border-left: 3px solid #4caf50;">
								<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
									<span style="color: #4caf50; font-weight: bold; font-size: 18px;">#${idx + 1} ${symbolDisplay}</span>
									${(() => {
										const price = getSignalPrice(signal);
										if (price !== null && price !== undefined) {
											return `<span style="color: #fff; font-weight: bold;">$${parseFloat(price).toFixed(2)}</span>`;
										} else if (signal.source && signal.source.includes('TradingView')) {
											return `<span style="color: rgba(255, 255, 255, 0.6); font-style: italic; font-size: 13px;">Market Price</span>`;
										}
										return '';
									})()}
								</div>
								<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 6px;">
									<strong>BUY Score:</strong> ${signal.buyScore}/${signal.totalBuy} ${thresholdStatus}
								</div>
								<div style="color: rgba(255, 255, 255, 0.7); font-size: 13px;">
									SELL: ${signal.sellScore}/${signal.totalSell} | Sector: ${signal.sector}
								</div>
								${timestampDisplay}
							</div>
						`;
					}).join('');
				}
				
				// Render Top 3 SELL
				const sellContainer = document.getElementById('top-sell-signals');
				if (topSell.length === 0) {
					sellContainer.innerHTML = '<div style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">No SELL signals available<br><small style="font-style: italic;">No valid signals found in the data.</small></div>';
				} else {
					sellContainer.innerHTML = topSell.map((signal, idx) => {
						const metThreshold = signal.sellScore >= SELL_THRESHOLD;
						const thresholdStatus = metThreshold 
							? `<span style="color: #4caf50; font-weight: bold;">‚úÖ Met (‚â•${SELL_THRESHOLD})</span>`
							: `<span style="color: #ffc107; font-weight: bold;">‚ö†Ô∏è Need ${SELL_THRESHOLD - signal.sellScore} more (threshold: ‚â•${SELL_THRESHOLD})</span>`;
						
						const symbolEmojis = getSymbolEmojis(signal.symbol);
						const symbolDisplay = symbolEmojis ? `${symbolEmojis} ${signal.symbol}` : signal.symbol;
						
						// Format timestamp
						let timestampDisplay = '';
						if (signal.timestamp) {
							try {
								const signalTime = new Date(signal.timestamp);
								const timeAgo = formatTimeAgo(signalTime);
								const fullTimestamp = formatTimestamp(signal.timestamp);
								timestampDisplay = `<div style="color: rgba(255, 255, 255, 0.6); font-size: 12px; margin-top: 6px;">
									üïê ${timeAgo} <span style="color: rgba(255, 255, 255, 0.5);">(${fullTimestamp})</span>
								</div>`;
							} catch (e) {
								// If timestamp parsing fails, skip it
							}
						}
						
						return `
							<div style="background: rgba(0, 0, 0, 0.3); padding: 15px; margin-bottom: 12px; border-radius: 6px; border-left: 3px solid #f44336;">
								<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
									<span style="color: #f44336; font-weight: bold; font-size: 18px;">#${idx + 1} ${symbolDisplay}</span>
									${(() => {
										const price = getSignalPrice(signal);
										if (price !== null && price !== undefined) {
											return `<span style="color: #fff; font-weight: bold;">$${parseFloat(price).toFixed(2)}</span>`;
										} else if (signal.source && signal.source.includes('TradingView')) {
											return `<span style="color: rgba(255, 255, 255, 0.6); font-style: italic; font-size: 13px;">Market Price</span>`;
										}
										return '';
									})()}
								</div>
								<div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 6px;">
									<strong>SELL Score:</strong> ${signal.sellScore}/${signal.totalSell} ${thresholdStatus}
								</div>
								<div style="color: rgba(255, 255, 255, 0.7); font-size: 13px;">
									BUY: ${signal.buyScore}/${signal.totalBuy} | Sector: ${signal.sector}
								</div>
								${timestampDisplay}
							</div>
						`;
					}).join('');
				}
			}
			
			function renderSignals(signals) {
				// Store signals globally so asset list can access them
				window.allSignals = signals;
				
				const grid = document.getElementById('signals-grid'); // Crypto recent
				const oldGrid = document.getElementById('old-signals-grid'); // Crypto historical
				const oldContainer = document.getElementById('old-signals-container'); // Crypto historical container
				const stockGrid = document.getElementById('stock-signals-grid'); // Stock recent
				const stockContainer = document.getElementById('stock-signals-container'); // Stock recent container
				const stockHistoricalGrid = document.getElementById('stock-historical-grid'); // Stock historical
				const stockHistoricalContainer = document.getElementById('stock-historical-container'); // Stock historical container
				
				console.log('renderSignals called with', signals.length, 'signals');
				
				if (!signals || signals.length === 0) {
					grid.innerHTML = '<div class="empty-state"><h3>‚è≥ Waiting for signals...</h3><p>Signals will appear here automatically when your trading bots generate them</p></div>';
					oldContainer.style.display = 'none';
					stockContainer.style.display = 'none';
					stockHistoricalContainer.style.display = 'none';
					return;
				}
				
				// Separate stocks from crypto
				const stockSignals = [];
				const cryptoSignals = [];
				
				signals.forEach(signal => {
					if (isStockSignal(signal)) {
						stockSignals.push(signal);
					} else {
						cryptoSignals.push(signal);
					}
				});
				
				// Process CRYPTO signals: recent (1 day) vs historical (1+ days)
				const oneDayAgo = Date.now() - (1 * 24 * 60 * 60 * 1000);
				const recentCrypto = [];
				const oldCrypto = [];
				
				cryptoSignals.forEach(signal => {
					const timestamp = new Date(signal.timestamp || signal.received_at);
					if (timestamp.getTime() > oneDayAgo) {
						recentCrypto.push(signal);
					} else {
						oldCrypto.push(signal);
					}
				});
				
				// Process STOCK signals: recent (7 days, since stocks are long-term) vs historical (7+ days)
				const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
				const recentStocks = [];
				const oldStocks = [];
				
				stockSignals.forEach(signal => {
					const timestamp = new Date(signal.timestamp || signal.received_at);
					if (timestamp.getTime() > sevenDaysAgo) {
						// Stocks from last 7 days are considered recent (long-term plays)
						recentStocks.push(signal);
					} else {
						// Stocks older than 7 days go to historical
						oldStocks.push(signal);
					}
				});
				
				console.log('Crypto - Recent:', recentCrypto.length, 'Old:', oldCrypto.length);
				console.log('Stocks - Recent:', recentStocks.length, 'Historical (7+ days):', oldStocks.length);
				
				// Render CRYPTO signals
				if (recentCrypto.length === 0) {
					grid.innerHTML = '<div class="empty-state"><h3>‚è≥ No recent crypto signals</h3><p>Check historical signals or wait for new signals</p></div>';
				} else {
					renderSignalCards(recentCrypto, grid);
				}
				
				// Render crypto historical (hidden by default)
				if (oldCrypto.length > 0) {
					oldContainer.style.display = 'none';
					document.getElementById('old-signals-count').textContent = oldCrypto.length;
					if (document.getElementById('old-signals-count-display')) {
						document.getElementById('old-signals-count-display').style.display = 'block';
					}
					renderSignalCards(oldCrypto, oldGrid);
				} else {
					oldContainer.style.display = 'none';
				}
				
				// Render STOCK signals (only if user has access - trial active or subscribed)
				if (!hasAccess()) {
					// Trial expired - show paywall
					if (stockGrid) {
						const paymentLinkConfigured = STRIPE_PAYMENT_LINK && STRIPE_PAYMENT_LINK !== 'https://buy.stripe.com/YOUR_PAYMENT_LINK_HERE';
						stockGrid.innerHTML = paymentLinkConfigured 
							? `<div class="empty-state" style="text-align: center; padding: 60px 40px; background: rgba(244, 67, 54, 0.15); border: 3px solid rgba(244, 67, 54, 0.7); border-radius: 12px; margin: 20px 0;">
								<h2 style="color: #fff; font-size: 32px; margin-bottom: 20px; font-weight: bold;">‚è∞ Your Trial Has Expired</h2>
								<p style="color: #fff; font-size: 20px; margin: 20px 0; font-weight: 500;">Your 7-day free trial has ended.</p>
								<p style="color: rgba(255, 255, 255, 0.9); font-size: 18px; margin-bottom: 30px;">Subscribe now to get <strong>permanent access</strong> to all stock signals.</p>
								<a href="${STRIPE_PAYMENT_LINK}" target="_blank" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 18px 40px; border-radius: 8px; font-size: 20px; font-weight: bold; cursor: pointer; text-decoration: none; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 25px rgba(102, 126, 234, 0.7)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.5)';">üí≥ Pay Now - $9.99 One-Time (Limited Time)</a>
								<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-top: 20px;">After payment, you'll be redirected back and granted permanent access.</p>
							</div>`
							: '<div class="empty-state" style="text-align: center; padding: 60px 40px; background: rgba(244, 67, 54, 0.15); border: 3px solid rgba(244, 67, 54, 0.7); border-radius: 12px; margin: 20px 0;"><h2 style="color: #fff; font-size: 32px; margin-bottom: 20px; font-weight: bold;">‚è∞ Your Trial Has Expired</h2><p style="color: #fff; font-size: 20px; margin: 20px 0; font-weight: 500;">Your 7-day free trial has ended.</p><p style="color: rgba(255, 255, 255, 0.9); font-size: 18px; margin-bottom: 30px;">Please subscribe to continue viewing stock signals.</p></div>';
					}
					// Hide Top 3 and watchlist sections
					const topSignalsSection = document.getElementById('top-signals-section');
					const watchlistSection = document.getElementById('watchlist-section');
					if (topSignalsSection) {
						topSignalsSection.style.display = 'none';
					}
					if (watchlistSection) {
						watchlistSection.style.display = 'none';
					}
				} else {
					// User has access (trial active or subscribed) - show stock signals
					if (recentStocks.length > 0) {
						renderSignalCards(recentStocks, stockGrid);
						// Render Top 3 signals section
						renderTop3Signals(signals);
						// Stock container visibility controlled by navigation buttons, don't override here
					} else {
						stockGrid.innerHTML = '<div class="empty-state"><h3>‚è≥ No recent stock signals</h3><p>Check historical stock signals or wait for new signals</p></div>';
						// Still try to render Top 3 from all signals
						renderTop3Signals(signals);
						// Stock container visibility controlled by navigation buttons, don't override here
					}
					// Show Top 3 and watchlist sections
					const topSignalsSection = document.getElementById('top-signals-section');
					const watchlistSection = document.getElementById('watchlist-section');
					if (topSignalsSection) {
						topSignalsSection.style.display = 'block';
					}
					if (watchlistSection) {
						watchlistSection.style.display = 'block';
					}
				}
				
				// Render stock historical (hidden by default)
				if (oldStocks.length > 0) {
					stockHistoricalContainer.style.display = 'none';
					document.getElementById('stock-historical-count').textContent = oldStocks.length;
					if (document.getElementById('stock-historical-count-display')) {
						document.getElementById('stock-historical-count-display').style.display = 'block';
					}
					renderSignalCards(oldStocks, stockHistoricalGrid);
				} else {
					stockHistoricalContainer.style.display = 'none';
				}
				
				// Update missing prices asynchronously (after all cards are rendered)
				// Keep latest signals in memory for manual refresh
				window.__latestSignalsForPriceRefresh = signals;
				
				// Update prices asynchronously (all signals; uses cache + retries)
				updateMissingPrices(signals).catch(err => {
					console.error('Error updating missing prices:', err);
				});
			}
			
			function renderSignalCards(signals, targetGrid) {
				try {
					const html = signals.map((signal, index) => {
						console.log('Processing signal', index, signal);
						const action = signal.action || 'unknown';
						const isBuy = action.toLowerCase() === 'buy';
						const actionClass = isBuy ? 'buy' : 'sell';
						
						// Determine signal conviction level from note
						let signalBadge = '';
						let signalClass = '';
						const note = signal.note || '';
						if (note.includes('Pure JSON Trade')) {
							signalBadge = '‚≠ê STANDARD CONVICTION';
							signalClass = 'confluence-pure';
						} else if (note.includes('EMA + JSON')) {
							signalBadge = '‚≠ê‚≠ê HIGH CONVICTION';
							signalClass = 'confluence-ema';
					} else if (note.includes('HMM + JSON') || note.includes('AI + JSON')) {
						signalBadge = '‚≠ê‚≠ê‚≠ê‚≠ê BEST CONVICTION';
						signalClass = 'confluence-hmm';
					} else if (note.includes('HMM Extreme') || note.includes('AI Extreme')) {
						signalBadge = '‚≠ê‚≠ê‚≠ê ULTRA HIGH CONVICTION';
						signalClass = 'confluence-extreme';
					}
						// Skip "Raw JSON signal" - internal only, not shown to users
						
						// Check if this is a crypto signal (not stock)
						const isCrypto = !isStockSignal(signal);
						
						const symbolEmojis = getSymbolEmojis(signal.symbol);
						const symbolDisplay = symbolEmojis ? `${symbolEmojis} ${signal.symbol || 'N/A'}` : (signal.symbol || 'N/A');
						
						const isWatched = isInWatchlist(signal.symbol);
						const watchButtonHtml = `
							<button class="watch-button ${isWatched ? 'watched' : ''}" 
									onclick="toggleWatchlist('${signal.symbol.replace(/'/g, "\\'")}'); event.stopPropagation();"
									title="${isWatched ? 'Remove from watchlist' : 'Add to watchlist'}"
									style="background: ${isWatched ? 'rgba(255, 193, 7, 0.3)' : 'rgba(255, 255, 255, 0.1)'}; 
										   border: 1px solid ${isWatched ? '#ffc107' : 'rgba(255, 255, 255, 0.3)'}; 
										   color: ${isWatched ? '#ffc107' : 'rgba(255, 255, 255, 0.7)'}; 
										   padding: 4px 8px; 
										   border-radius: 4px; 
										   cursor: pointer; 
										   font-size: 16px;
										   transition: all 0.2s;">
								${isWatched ? '‚≠ê' : '‚òÜ'}
							</button>
						`;
						
						// Handle PnL tracking for crypto and stock signals (FIFO-based for DCA)
						// NOTE: PnL tracking is standalone - uses localStorage only
						const currentPrice = getSignalPrice(signal);
						const domKey = getSignalDomKey(signal);
						let pnlDisplay = '';
						
						// Enable PnL for both crypto and stocks
						if (currentPrice !== null && currentPrice !== undefined && currentPrice > 0) {
							if (isBuy) {
								// Store buy position only once per BUY signal (prevents duplicates on auto-refresh)
								if (!wasPnLSignalProcessed(domKey)) {
									const quantity = getSignalQuantity(signal);
									storeBuyPosition(signal.symbol, currentPrice, quantity, signal.timestamp || signal.received_at);
									markPnLSignalProcessed(domKey);
								}
							} else {
								// For sells, persist the computed result so it doesn't disappear on rerender.
								const stored = getStoredSellPnL(domKey);
								if (stored && (stored.pnl === null || typeof stored.pnl === 'number')) {
									if (typeof stored.pnl === 'number') {
										pnlDisplay = `
											<div class="signal-detail-row">
												<span class="signal-detail-label">PnL:</span>
												<span class="signal-detail-value">${formatPnL(stored.pnl)}</span>
											</div>
										`;
									} else {
										pnlDisplay = `
											<div class="signal-detail-row">
												<span class="signal-detail-label">PnL:</span>
												<span class="signal-detail-value" style="color: rgba(255, 165, 0, 0.8); font-style: italic;">‚ö†Ô∏è ${stored.note || 'No entry data'}</span>
											</div>
										`;
									}
								} else if (!wasPnLSignalProcessed(domKey)) {
									const position = getFirstBuyPosition(signal.symbol);
									if (position && position.entryPrice) {
										const pnl = calculatePnL(position.entryPrice, currentPrice);
										if (pnl !== null) {
											setStoredSellPnL(domKey, pnl, '');
											pnlDisplay = `
												<div class="signal-detail-row">
													<span class="signal-detail-label">PnL:</span>
													<span class="signal-detail-value">${formatPnL(pnl)}</span>
												</div>
											`;
										} else {
											setStoredSellPnL(domKey, null, 'Invalid price');
										}
										removeFirstBuyPosition(signal.symbol);
									} else {
										console.warn(`[PnL] No entry price found for ${signal.symbol} sell signal - may be mid-run start or backup sell signal`);
										setStoredSellPnL(domKey, null, 'No entry data');
										pnlDisplay = `
											<div class="signal-detail-row">
												<span class="signal-detail-label">PnL:</span>
												<span class="signal-detail-value" style="color: rgba(255, 165, 0, 0.8); font-style: italic;">‚ö†Ô∏è No entry data</span>
											</div>
										`;
									}
									markPnLSignalProcessed(domKey);
								}
							}
						}
						// If price is missing, create a PnL placeholder for SELL so we can fill it asynchronously
						else if (!isBuy && signal.symbol) {
							pnlDisplay = `
								<div class="signal-detail-row">
									<span class="signal-detail-label">PnL:</span>
									<span class="signal-detail-value" id="pnl-${domKey}" style="color: rgba(255, 255, 255, 0.6); font-style: italic;">Loading...</span>
								</div>
							`;
						}
						
						const cardHtml = `
							<div class="signal-card ${actionClass}">
								<div class="signal-header">
									<div style="display: flex; align-items: center; gap: 8px;">
										<span class="signal-symbol">${symbolDisplay}</span>
										${watchButtonHtml}
									</div>
									<div>
										<span class="signal-action ${actionClass}">${isBuy ? 'üü¢ üìà' : 'üî¥ üìâ'} ${action.toUpperCase()}${signal.partial_exit ? ` <span style="color: rgba(255, 165, 0, 0.9); font-size: 0.85em;">(PARTIAL ${(signal.partial_exit_pct || signal.exit_pct || 0) * 100}%)</span>` : ''}</span>
										${signalBadge ? `<span class="confluence-badge ${signalClass}">${signalBadge}</span>` : ''}
									</div>
								</div>
								<div class="signal-details">
									${(() => {
										const price = getSignalPrice(signal);
										if (price !== null && price !== undefined) {
											const domKey = getSignalDomKey(signal);
											const priceElementId = `price-${domKey}`;
											return `
												<div class="signal-detail-row">
													<span class="signal-detail-label">Price:</span>
													<span class="signal-detail-value" id="${priceElementId}">${formatPrice(price)}</span>
												</div>
											`;
										} else if (signal.symbol) {
											// Deterministic ID so async updates always find the right element
											const domKey = getSignalDomKey(signal);
											const priceElementId = `price-${domKey}`;
											
											// If we have a cached price, show it immediately (even if stale)
											const isStock = isStockSignal(signal);
											const cached = getCachedPriceEntry(signal.symbol, isStock);
											const cachedHtml = cached ? formatPriceWithStaleWarning(cached.price, Date.now() - cached.timestamp) : 'Loading...';
											const cachedStyle = cached ? 'color: #fff; font-style: normal;' : 'color: rgba(255, 255, 255, 0.6); font-style: italic;';
											return `
												<div class="signal-detail-row">
													<span class="signal-detail-label">Price:</span>
													<span class="signal-detail-value" id="${priceElementId}" style="${cachedStyle}">${cachedHtml}</span>
												</div>
											`;
										}
										return '';
									})()}
									${(() => {
										// Position sizing display for stock signals
										const hasPositionData = (signal.buy_position_multiplier !== undefined || signal.sell_position_multiplier !== undefined);
										if (isStockSignal(signal) && hasPositionData) {
											const isBuy = action.toLowerCase() === 'buy';
											const multiplier = isBuy ? (signal.buy_position_multiplier || 1.0) : (signal.sell_position_multiplier || 1.0);
											const conviction = isBuy ? (signal.buy_conviction || 0.0) : (signal.sell_conviction || 0.0);
											const persistence = isBuy ? (signal.buy_persistence || 0) : (signal.sell_persistence || 0);
											
											// Determine multiplier color and label
											let multiplierColor = '#9e9e9e'; // Default gray
											let multiplierLabel = 'Normal';
											if (multiplier < 0.75) {
												multiplierColor = '#ff9800'; // Orange for low (0.5x)
												multiplierLabel = 'Low';
											} else if (multiplier > 1.25) {
												multiplierColor = '#4caf50'; // Green for high (1.5x)
												multiplierLabel = 'High';
											}
											
											// Conviction color based on level
											let convictionColor = '#9e9e9e';
											if (conviction >= 0.7) convictionColor = '#4caf50'; // High
											else if (conviction >= 0.4) convictionColor = '#ffc107'; // Medium
											else convictionColor = '#ff9800'; // Low
											
											return `
												<div class="signal-detail-row" style="background: rgba(33, 150, 243, 0.1); border-left: 3px solid rgba(33, 150, 243, 0.6); padding: 10px; margin: 10px 0; border-radius: 4px;">
													<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
														<span class="signal-detail-label" style="color: rgba(33, 150, 243, 0.9); font-weight: bold; font-size: 13px;">üí∞ Position Sizing</span>
														<span style="background: ${multiplierColor}; color: #fff; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">
															${multiplier.toFixed(1)}x (${multiplierLabel})
														</span>
													</div>
													<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
														<div>
															<span style="color: rgba(255, 255, 255, 0.7);">Conviction:</span>
															<span style="color: ${convictionColor}; font-weight: bold; margin-left: 4px;">
																${(conviction * 100).toFixed(0)}%
															</span>
														</div>
														<div>
															<span style="color: rgba(255, 255, 255, 0.7);">Persistence:</span>
															<span style="color: rgba(255, 255, 255, 0.9); font-weight: bold; margin-left: 4px;">
																${persistence} bars
															</span>
														</div>
													</div>
													<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
														<small style="color: rgba(255, 255, 255, 0.6); font-size: 11px; line-height: 1.4;">
															${multiplier < 0.75 ? 'Half size (0.5x) - Lower conviction signal' : multiplier > 1.25 ? 'Larger size (1.5x) - High conviction signal' : 'Normal size (1.0x) - Medium conviction signal'}
														</small>
													</div>
												</div>
											`;
										}
										return '';
									})()}
									${pnlDisplay}
									${signal.partial_exit ? `
										<div class="signal-detail-row" style="background: rgba(255, 165, 0, 0.15); border-left: 3px solid rgba(255, 165, 0, 0.6); padding: 8px; margin: 8px 0; border-radius: 4px;">
											<span class="signal-detail-label" style="color: rgba(255, 165, 0, 0.9); font-weight: bold;">‚ö†Ô∏è Partial Exit:</span>
											<span class="signal-detail-value" style="color: rgba(255, 165, 0, 0.9);">
												Level ${signal.partial_exit_level || 'N/A'} - ${((signal.partial_exit_pct || signal.exit_pct || 0) * 100).toFixed(0)}% of position
											</span>
										</div>
									` : ''}
									${signal.is_stop_loss && signal.exit_reason ? `
										<div class="signal-detail-row" style="background: rgba(33, 150, 243, 0.15); border-left: 3px solid rgba(33, 150, 243, 0.8); padding: 10px; margin: 8px 0; border-radius: 4px;">
											<span class="signal-detail-label" style="color: rgba(33, 150, 243, 0.9); font-weight: bold;">üõ°Ô∏è Stop Loss (Risk Management):</span>
											<span class="signal-detail-value" style="color: rgba(255, 255, 255, 0.9); font-size: 13px; line-height: 1.4;">
												${signal.exit_reason}
												<br><small style="color: rgba(255, 255, 255, 0.7); font-style: italic; margin-top: 4px; display: block;">
													This is NOT a bearish signal - it's capital protection. The bot limits losses to preserve your capital for future trades.
												</small>
											</span>
										</div>
									` : ''}
									${signal.source ? `
										<div class="signal-detail-row">
											<span class="signal-detail-label">Source:</span>
											<span class="signal-detail-value">${signal.source.replace(/MASTER_BOT_\d+/gi, 'Python Bot').replace(/MASTERMASTER/gi, 'Python Bot')}</span>
										</div>
									` : ''}
									${signal.note ? `
										<div class="note-highlight">
											${signal.note.replace(/HMM/gi, 'AI').replace(/JSON/gi, 'indicator suite')}
										</div>
									` : ''}
								</div>
								<div class="signal-timestamp">
									${formatTimestamp(signal.timestamp || signal.received_at)}
								</div>
							</div>
						`;
						return cardHtml;
					}).join('');
					
					console.log('Generated HTML length:', html.length);
					console.log('First 200 chars of HTML:', html.substring(0, 200));
					console.log('Setting innerHTML...');
					targetGrid.innerHTML = html;
					console.log('innerHTML set. Grid children:', targetGrid.children.length);
					console.log('Grid innerHTML length after set:', targetGrid.innerHTML.length);
					
					// Note: Price updates are handled at the end of renderSignals() for all signals
					
					// Force a visual test
					if (targetGrid.children.length > 0) {
						console.log('First child element:', targetGrid.children[0]);
						console.log('First child visible?', window.getComputedStyle(targetGrid.children[0]).display);
					}
				} catch (error) {
					console.error('Error in renderSignalCards:', error);
					targetGrid.innerHTML = '<div class="empty-state"><h3>Error rendering signals</h3><p>' + error.message + '</p></div>';
				}
			}
			
			function loadSignals() {
				console.log('Loading signals...');
				// Try to load signals.json (list of all signals)
				fetch('signals/signals.json')
					.then(response => {
						console.log('Response status:', response.status);
						if (!response.ok) {
							// If signals.json doesn't exist, try latest.json
							return fetch('signals/latest.json')
								.then(res => {
									if (!res.ok) throw new Error('No signals file found');
									return res.json();
								})
								.then(data => [data]); // Wrap single signal in array
						}
						return response.json();
					})
					.then(data => {
						console.log('Received data:', data);
				// Only block if trial truly expired
				if (!signalsVisible) {
					console.log('Trial expired: hiding signals');
					hideAllSignals();
					return;
				}
						// Ensure data is an array
						const signals = Array.isArray(data) ? data : [data];
						console.log('Rendering', signals.length, 'signals');
						
						// Check for watchlist changes BEFORE rendering (to catch changes)
						checkWatchlistChanges(signals);
						
						renderSignals(signals);
						
						// Update asset list if it's currently visible
						const assetListContainer = document.getElementById('asset-list-container');
						if (assetListContainer && assetListContainer.style.display !== 'none') {
							renderAssetList(signals);
						}
						
						// Update signal status in asset list
						updateAssetSignalStatus(signals);
						
						// Update watchlist display
						updateWatchlistDisplay();
						
						document.getElementById('status-indicator').className = 'status-indicator active';
						document.getElementById('status-text').textContent = 'Connected';
						const now = new Date();
						const utcHours = String(now.getUTCHours()).padStart(2, '0');
						const utcMinutes = String(now.getUTCMinutes()).padStart(2, '0');
						const utcSeconds = String(now.getUTCSeconds()).padStart(2, '0');
						document.getElementById('last-update').textContent = `Last updated: ${utcHours}:${utcMinutes}:${utcSeconds} UTC`;
					})
					.catch(error => {
						console.error('Error loading signals:', error);
						document.getElementById('signals-grid').innerHTML = 
							'<div class="empty-state"><h3>‚è≥ Waiting for signals...</h3><p>Servers are restarting. Signals are stale. Please check back in a few minutes.</p></div>';
						document.getElementById('status-indicator').className = 'status-indicator inactive';
						document.getElementById('status-text').textContent = 'Servers Restarting';
						showServerRestartBanner();
					});
			}
			
			// ========================================
			// ASSET SIGNAL STATUS FUNCTIONS
			// ========================================
			
			/**
			 * Normalize symbol format for matching (handles ETH/USD, ETH-USD, etc.)
			 */
			function normalizeSymbol(symbol) {
				if (!symbol) return '';
				// Convert to uppercase and replace common separators
				return symbol.toUpperCase().replace(/[-_]/g, '/');
			}
			
			/**
			 * Get the latest signal for each symbol from the signals array
			 */
			function getLatestSignalsBySymbol(signals) {
				const latestBySymbol = {};
				
				if (!signals || !Array.isArray(signals)) {
					return latestBySymbol;
				}
				
				signals.forEach(signal => {
					if (!signal.symbol) return;
					
					const symbol = normalizeSymbol(signal.symbol);
					const timestamp = signal.timestamp || signal.received_at;
					
					if (!timestamp) return;
					
					// Parse timestamp
					const signalTime = new Date(timestamp);
					
					// Skip invalid dates
					if (isNaN(signalTime.getTime())) return;
					
					// If we don't have a signal for this symbol yet, or this one is newer
					if (!latestBySymbol[symbol] || signalTime > latestBySymbol[symbol].time) {
						latestBySymbol[symbol] = {
							action: signal.action || signal.side || '',
							time: signalTime,
							timestamp: timestamp,
							price: getSignalPrice(signal)
						};
					}
				});
				
				return latestBySymbol;
			}
			
			/**
			 * Check if a signal is older than 72 hours
			 */
			function isSignalOlderThan72Hours(signalTime) {
				if (!signalTime) return true;
				
				const now = new Date();
				const hoursDiff = (now - signalTime) / (1000 * 60 * 60);
				return hoursDiff > 72;
			}
			
			/**
			 * Format time ago string (e.g., "2 hours ago", "3 days ago")
			 */
			function formatTimeAgo(signalTime) {
				if (!signalTime) return '';
				
				const now = new Date();
				const diffMs = now - signalTime;
				const diffHours = diffMs / (1000 * 60 * 60);
				const diffDays = diffMs / (1000 * 60 * 60 * 24);
				
				if (diffHours < 1) {
					const diffMins = Math.floor(diffMs / (1000 * 60));
					return diffMins <= 1 ? 'just now' : `${diffMins} min ago`;
				} else if (diffHours < 24) {
					const hours = Math.floor(diffHours);
					return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`;
				} else {
					const days = Math.floor(diffDays);
					return `${days} ${days === 1 ? 'day' : 'days'} ago`;
				}
			}
			
			/**
			 * Update signal status for all assets in the "Assets Traded" section
			 */
			function updateAssetSignalStatus(signals) {
				const latestSignals = getLatestSignalsBySymbol(signals);
				const isSubscribed = localStorage.getItem(STORAGE_KEY_SUBSCRIBED) === 'true';
				const trialActive = typeof signalsVisible !== 'undefined' ? signalsVisible : true;
				const hasAccess = isSubscribed || trialActive;
				
				// Find all asset list items
				const assetItems = document.querySelectorAll('li[data-symbol]');
				
				assetItems.forEach(item => {
					const symbol = normalizeSymbol(item.getAttribute('data-symbol'));
					const statusSpan = item.querySelector('.asset-signal-status');
					
					if (!statusSpan) return;
					
					const latestSignal = latestSignals[symbol];
					
					// Clear existing classes
					statusSpan.className = 'asset-signal-status';
					
					if (!hasAccess) {
						// Show subscribe button for non-subscribers
						statusSpan.className += ' locked';
						statusSpan.innerHTML = '<a href="#" onclick="event.preventDefault(); showSubscriptionModal(); return false;" class="subscribe-mini-btn">Subscribe</a>';
					} else if (!latestSignal) {
						// No signal found for this symbol
						statusSpan.className += ' neutral';
						statusSpan.innerHTML = '‚ö™ NEUTRAL';
					} else {
						const signalTime = latestSignal.time;
						const isOld = isSignalOlderThan72Hours(signalTime);
						
						if (isOld) {
							// Signal is >72 hours old, show neutral
							statusSpan.className += ' neutral';
							statusSpan.innerHTML = '‚ö™ NEUTRAL';
						} else {
							// Show BUY or SELL with time ago
							const action = latestSignal.action.toLowerCase();
							const timeAgo = formatTimeAgo(signalTime);
							
							if (action === 'buy') {
								statusSpan.className += ' buy';
								statusSpan.innerHTML = `üü¢ BUY<span class="time-ago"> (${timeAgo})</span>`;
							} else if (action === 'sell') {
								statusSpan.className += ' sell';
								statusSpan.innerHTML = `üî¥ SELL<span class="time-ago"> (${timeAgo})</span>`;
							} else {
								statusSpan.className += ' neutral';
								statusSpan.innerHTML = '‚ö™ NEUTRAL';
							}
						}
					}
					});
			}
			
			// ========================================
			// TRIAL TRACKING & ACCESS CONTROL
			// ========================================
			
			const TRIAL_DAYS = 7;
			const STORAGE_KEY_TRIAL_START = 'trial_start_date';
			const STORAGE_KEY_SUBSCRIBED = 'is_subscribed';
			const STORAGE_KEY_EMAIL = 'user_email';
			
			// Developer whitelist - Change this secret key to something only you know
			// Two ways to activate: 
			// 1. Set localStorage: localStorage.setItem('DEV_WHITELIST', 'true')
			// 2. Add to URL: signals.html?dev=YOUR_SECRET_KEY_HERE
			const DEV_WHITELIST_SECRET = 'dev_access_2024'; // Change this to your own secret key
			const DEV_WHITELIST_STORAGE_KEY = 'DEV_WHITELIST';
			
			// Stripe Payment Link - Configured for Trading Signals PRO $9.99 one-time payment (limited time offer) with 7-day free trial
			// Success URL should be set to: https://brianstreckfus.com/signals.html?paid=true
			// NOTE: To update the Stripe payment page description, go to Stripe Dashboard > Payment Links > Edit and update the product description to say "One-Time Payment - Limited Time Offer"
			const STRIPE_PAYMENT_LINK = 'https://buy.stripe.com/00w00legUbde5wT5UB8og00';
			const COINBASE_COMMERCE_CHECKOUT_URL = 'https://commerce.coinbase.com/checkout/e29add99-d295-46f1-a97e-152221f9e3ad';
			
			// Initialize trial tracking
			function initializeTrial() {
				// Initialize non-blocking email capture
				initEmailCapture();
				
				// Developer whitelist check - bypasses all subscription/trial checks
				const devWhitelistLocalStorage = localStorage.getItem(DEV_WHITELIST_STORAGE_KEY) === 'true';
				const urlParams = new URLSearchParams(window.location.search);
				const devWhitelistUrlParam = urlParams.get('dev') === DEV_WHITELIST_SECRET;
				
				if (devWhitelistLocalStorage || devWhitelistUrlParam) {
					// Auto-set subscribed status for dev access
					localStorage.setItem(STORAGE_KEY_SUBSCRIBED, 'true');
					updateTrialStatus('subscribed');
					console.log('üîì Developer whitelist active - full access granted');
					return true; // Full access
				}
				
				// Check if user is returning from successful payment (Payment Link redirect)
				if (urlParams.get('paid') === 'true') {
					// Mark as subscribed and grant permanent access
					localStorage.setItem(STORAGE_KEY_SUBSCRIBED, 'true');
					// Clean up URL
					window.history.replaceState({}, document.title, window.location.pathname);
					console.log('‚úÖ Payment confirmed - granting permanent access');
				}

				// Check if user is marked as subscribed
				const isSubscribed = localStorage.getItem(STORAGE_KEY_SUBSCRIBED) === 'true';
				if (isSubscribed) {
					updateTrialStatus('subscribed');
					return true; // Full access
				}
				
				// Check if trial has started
				let trialStartDate = localStorage.getItem(STORAGE_KEY_TRIAL_START);
				
				if (!trialStartDate) {
					// First visit - start trial now
					trialStartDate = new Date().toISOString();
					localStorage.setItem(STORAGE_KEY_TRIAL_START, trialStartDate);
					updateTrialStatus('active');
					return true; // Show signals during trial
				}
				
				// Check if trial has expired
				const startDate = new Date(trialStartDate);
				const now = new Date();
				const daysElapsed = (now - startDate) / (1000 * 60 * 60 * 24);
				
				if (daysElapsed >= TRIAL_DAYS) {
					updateTrialStatus('expired');
					return false; // Hide signals after trial
				} else {
					const daysRemaining = Math.ceil(TRIAL_DAYS - daysElapsed);
					updateTrialStatus('active', daysRemaining);
					return true; // Show signals during trial
				}
			}
			
			// Update trial status banner
			function updateTrialStatus(status, daysRemaining = null) {
				const banner = document.getElementById('trial-status-banner');
				const message = document.getElementById('trial-status-message');
				
				if (!banner || !message) return;
				
				if (status === 'subscribed') {
					banner.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.3) 0%, rgba(76, 175, 80, 0.2) 100%)';
					banner.style.borderColor = 'rgba(76, 175, 80, 0.7)';
					message.innerHTML = '‚úÖ <strong>Premium Subscriber</strong> - Full access to all trading signals';
				} else if (status === 'active') {
					banner.style.background = 'linear-gradient(135deg, rgba(33, 150, 243, 0.3) 0%, rgba(76, 175, 80, 0.2) 100%)';
					banner.style.borderColor = 'rgba(33, 150, 243, 0.7)';
					if (daysRemaining !== null) {
						message.innerHTML = `üéâ <strong>7-Day Free Trial Active</strong> - ${daysRemaining} day${daysRemaining !== 1 ? 's' : ''} remaining. Signals are visible!`;
					} else {
						message.innerHTML = 'üéâ <strong>7-Day Free Trial Started</strong> - Signals are now visible!';
					}
				} else if (status === 'expired') {
					banner.style.background = 'linear-gradient(135deg, rgba(244, 67, 54, 0.4) 0%, rgba(255, 152, 0, 0.3) 100%)';
					banner.style.borderColor = 'rgba(244, 67, 54, 1)';
					banner.style.borderWidth = '3px';
					banner.style.boxShadow = '0 4px 20px rgba(244, 67, 54, 0.5)';
					message.style.fontSize = '20px';
					message.style.fontWeight = 'bold';
					message.innerHTML = '‚è∞ <strong style="font-size: 24px;">Your Trial Has Expired</strong><br><span style="font-size: 18px; font-weight: normal; margin-top: 10px; display: block;">Please subscribe to continue viewing signals.</span><br><a href="#" onclick="event.preventDefault(); showSubscriptionModal(); return false;" style="color: #fff; text-decoration: underline; font-weight: bold; font-size: 18px; margin-top: 10px; display: inline-block; background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 6px;">Subscribe Now ‚Üí</a>';
				}
				
				// Refresh asset signal status when trial status changes
				if (typeof window.allSignals !== 'undefined' && window.allSignals) {
					updateAssetSignalStatus(window.allSignals);
				}
			}
			
			// Check if user has access (trial active or subscribed)
			function hasAccess() {
				// Developer whitelist check - bypasses all subscription/trial checks
				const devWhitelistLocalStorage = localStorage.getItem(DEV_WHITELIST_STORAGE_KEY) === 'true';
				const urlParams = new URLSearchParams(window.location.search);
				const devWhitelistUrlParam = urlParams.get('dev') === DEV_WHITELIST_SECRET;
				
				if (devWhitelistLocalStorage || devWhitelistUrlParam) {
					// Auto-set subscribed status for dev access
					if (!localStorage.getItem(STORAGE_KEY_SUBSCRIBED)) {
						localStorage.setItem(STORAGE_KEY_SUBSCRIBED, 'true');
					}
					return true;
				}
				
				// Normal access check
				const isSubscribed = localStorage.getItem(STORAGE_KEY_SUBSCRIBED) === 'true';
				return isSubscribed || (typeof signalsVisible !== 'undefined' && signalsVisible);
			}
			
			// Hide all signal grids when trial expires
			function hideAllSignals() {
				const grids = [
					document.getElementById('signals-grid'),
					document.getElementById('stock-signals-grid'),
					document.getElementById('old-signals-grid'),
					document.getElementById('stock-historical-grid'),
					document.getElementById('crypto-asset-list'),
					document.getElementById('stock-asset-list'),
					document.getElementById('top-signals-section'),
					document.getElementById('watchlist-section')
				];
				
				// Check if Payment Link is configured
				const paymentLinkConfigured = STRIPE_PAYMENT_LINK && STRIPE_PAYMENT_LINK !== 'https://buy.stripe.com/YOUR_PAYMENT_LINK_HERE';
				
				const paywallMessage = paymentLinkConfigured 
					? `<div class="empty-state" style="text-align: center; padding: 60px 40px; background: rgba(244, 67, 54, 0.15); border: 3px solid rgba(244, 67, 54, 0.7); border-radius: 12px; margin: 20px 0;">
						<h2 style="color: #fff; font-size: 32px; margin-bottom: 20px; font-weight: bold;">‚è∞ Your Trial Has Expired</h2>
						<p style="color: #fff; font-size: 20px; margin: 20px 0; font-weight: 500;">Your 7-day free trial has ended.</p>
						<p style="color: rgba(255, 255, 255, 0.9); font-size: 18px; margin-bottom: 30px;">Subscribe now to get <strong>permanent access</strong> to all trading signals.</p>
						<a href="${STRIPE_PAYMENT_LINK}" target="_blank" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 18px 40px; border-radius: 8px; font-size: 20px; font-weight: bold; cursor: pointer; text-decoration: none; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 25px rgba(102, 126, 234, 0.7)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.5)';">üí≥ Pay Now - $9.99 One-Time (Limited Time)</a>
						<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-top: 20px;">After payment, you'll be redirected back and granted permanent access.</p>
					</div>`
					: '<div class="empty-state" style="text-align: center; padding: 60px 40px; background: rgba(244, 67, 54, 0.15); border: 3px solid rgba(244, 67, 54, 0.7); border-radius: 12px; margin: 20px 0;"><h2 style="color: #fff; font-size: 32px; margin-bottom: 20px; font-weight: bold;">‚è∞ Your Trial Has Expired</h2><p style="color: #fff; font-size: 20px; margin: 20px 0; font-weight: 500;">Your 7-day free trial has ended.</p><p style="color: rgba(255, 255, 255, 0.9); font-size: 18px; margin-bottom: 30px;">Please subscribe to continue viewing all trading signals.</p><p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-top: 20px;">‚ö†Ô∏è Payment link not configured. Please contact support.</p></div>';
				
				grids.forEach(grid => {
					if (grid) {
						grid.innerHTML = paywallMessage;
						grid.style.opacity = '1';
						grid.style.visibility = 'visible';
						grid.style.display = 'grid';
					}
				});
			}
			
			// Check if signals should be visible
			let signalsVisible = true; // Default to visible
			
			// Update static asset list items with emojis
			function updateStaticAssetListEmojis() {
				const assetItems = document.querySelectorAll('li[data-symbol]');
				assetItems.forEach(item => {
					const symbol = item.getAttribute('data-symbol');
					const emojis = getSymbolEmojis(symbol);
					if (emojis) {
						const strongTag = item.querySelector('strong');
						if (strongTag) {
							// Add emojis before the symbol in the strong tag
							strongTag.innerHTML = `${emojis} ${strongTag.textContent.trim()}`;
						}
					}
				});
			}
			
			// Initialize: Show crypto by default on page load
			window.addEventListener('DOMContentLoaded', function() {
				// Check trial status first
				signalsVisible = initializeTrial();
				
				// Update static asset list with emojis
				updateStaticAssetListEmojis();
				
				switchToCrypto();
			
				// Load signals immediately regardless; loadSignals will hide if expired
			loadSignals();
			// Auto-refresh every 30 seconds
			refreshInterval = setInterval(loadSignals, 30000);
			
			// Initialize asset signal status (will show subscribe buttons if no access)
			updateAssetSignalStatus([]);
			
			// Initialize Bitcoin dominance tracking
			updateBitcoinDominanceWarning();
			// Update Bitcoin dominance every 5 minutes (less frequent than signals)
			setInterval(updateBitcoinDominanceWarning, 5 * 60 * 1000);
			});
			
			// Add scroll detection for mobile nav shrinking
			window.addEventListener("scroll", function() {
				var distance = window.pageYOffset || document.documentElement.scrollTop;
				if(distance > 20) {
					document.querySelector("nav").classList.add("scrolled");
					document.getElementById("backing").classList.add("scrolled");
				} else {
					document.querySelector("nav").classList.remove("scrolled");
					document.getElementById("backing").classList.remove("scrolled");
				}
			});
			
			// Stripe Payment Links - no backend or Stripe.js required

			// Non-blocking email capture (freemium)
			function initEmailCapture() {
				const savedEmail = localStorage.getItem(STORAGE_KEY_EMAIL);
				const banner = document.getElementById('email-capture-banner');
				const input = document.getElementById('email-capture-input');
				const btn = document.getElementById('email-capture-btn');
				const status = document.getElementById('email-capture-status');

				if (!banner || !input || !btn || !status) return;

				if (savedEmail) {
					banner.style.display = 'none';
					return;
				}

				banner.style.display = 'block';

				btn.addEventListener('click', function() {
					const email = (input.value || '').trim();
					if (!email || !email.includes('@')) {
						status.style.display = 'block';
						status.style.color = '#f44336';
						status.textContent = 'Please enter a valid email.';
					return;
				}
					localStorage.setItem(STORAGE_KEY_EMAIL, email);
					status.style.display = 'block';
					status.style.color = '#4caf50';
					status.textContent = 'Saved! Thank you.';
					setTimeout(() => {
						banner.style.display = 'none';
					}, 1200);
				});
			}
			
			function showSubscriptionModal() {
				const modal = document.getElementById('subscription-modal');
				const errorDiv = document.getElementById('subscription-error');
				const button = document.getElementById('start-subscription-btn');
				
				if (modal) {
					modal.style.display = 'flex';
				}
				
				// Payment Links work without backend - always enable button
					if (errorDiv) {
						errorDiv.style.display = 'none';
						errorDiv.textContent = '';
					}
					if (button) {
						button.disabled = false;
						button.textContent = 'Start 7-Day Free Trial';
				}
			}
			
			function closeSubscriptionModal() {
				const modal = document.getElementById('subscription-modal');
				if (modal) {
					modal.style.display = 'none';
				}
				const errorDiv = document.getElementById('subscription-error');
				if (errorDiv) {
					errorDiv.style.display = 'none';
					errorDiv.textContent = '';
				}
			}
			
			// Close modal when clicking outside
			document.addEventListener('click', function(event) {
				const modal = document.getElementById('subscription-modal');
				if (modal && event.target === modal) {
					closeSubscriptionModal();
				}
			});
			
			function startSubscription() {
				// Redirect directly to Stripe Payment Link (no backend needed)
				const paymentLinkConfigured = STRIPE_PAYMENT_LINK && STRIPE_PAYMENT_LINK !== 'https://buy.stripe.com/YOUR_PAYMENT_LINK_HERE';
				
				if (paymentLinkConfigured) {
					// Close modal and redirect to Payment Link
					closeSubscriptionModal();
					window.location.href = STRIPE_PAYMENT_LINK;
				} else {
					// Fallback error (shouldn't happen if Payment Link is configured)
					const errorDiv = document.getElementById('subscription-error');
						if (errorDiv) {
							errorDiv.style.display = 'block';
						errorDiv.textContent = '‚ö†Ô∏è Payment Link not configured. Please contact support.';
					}
				}
			}

			function startCryptoPayment() {
				// Coinbase Commerce checkout (2nd option; does NOT replace Stripe)
				if (!COINBASE_COMMERCE_CHECKOUT_URL) {
					const errorDiv = document.getElementById('subscription-error');
					if (errorDiv) {
						errorDiv.style.display = 'block';
						errorDiv.textContent = '‚ö†Ô∏è Crypto checkout link not configured. Please contact support.';
					}
					return;
				}

				closeSubscriptionModal();
				// Open in a new tab so the user can easily return to the signals page
				window.open(COINBASE_COMMERCE_CHECKOUT_URL, '_blank', 'noopener');
			}
			
			// Mark user as subscribed (called after successful payment)
			function markAsSubscribed() {
				localStorage.setItem(STORAGE_KEY_SUBSCRIBED, 'true');
				signalsVisible = true;
				updateTrialStatus('subscribed');
				// Reload signals if they were hidden
				loadSignals();
				if (!refreshInterval) {
					refreshInterval = setInterval(loadSignals, 30000);
				}
			}
			
			// Check if user is returning from successful payment
			// This handles both Stripe Checkout (session_id) and Payment Links (paid=true)
			const urlParams = new URLSearchParams(window.location.search);
			if (urlParams.get('session_id') || urlParams.get('paid') === 'true') {
				// Mark as subscribed and show success message
				markAsSubscribed();
				setTimeout(() => {
					alert('üéâ Payment successful! Thank you for subscribing. You now have permanent access to all signals.');
					// Clean up URL
					window.history.replaceState({}, document.title, window.location.pathname);
				}, 500);
			}
			
			// =============================================================================
			// WATCHLIST FUNCTIONALITY WITH NOTIFICATIONS
			// =============================================================================
			
			// Watchlist storage functions
			function getWatchlist() {
				try {
					const stored = localStorage.getItem('watchlist');
					return stored ? JSON.parse(stored) : [];
				} catch (e) {
					console.error('Error loading watchlist:', e);
					return [];
				}
			}
			
			function saveWatchlist(symbols) {
				try {
					localStorage.setItem('watchlist', JSON.stringify(symbols));
				} catch (e) {
					console.error('Error saving watchlist:', e);
				}
			}
			
			function isInWatchlist(symbol) {
				const watchlist = getWatchlist();
				return watchlist.includes(symbol);
			}
			
			function toggleWatchlist(symbol) {
				// Check if user has access (trial active or subscribed)
				if (!hasAccess()) {
					showSubscriptionModal();
					return;
				}
				
				const watchlist = getWatchlist();
				const index = watchlist.indexOf(symbol);
				
				if (index > -1) {
					watchlist.splice(index, 1);
					console.log(`Removed ${symbol} from watchlist`);
				} else {
					watchlist.push(symbol);
					console.log(`Added ${symbol} to watchlist`);
					if (watchlist.length === 1) {
						requestNotificationPermission();
					}
				}
				
				saveWatchlist(watchlist);
				updateWatchlistDisplay();
				if (window.allSignals) {
					renderSignals(window.allSignals);
					renderAssetList(window.allSignals);
				}
			}
			
			// Signal history storage
			function getSignalHistory() {
				try {
					const stored = localStorage.getItem('signalHistory');
					return stored ? JSON.parse(stored) : {};
				} catch (e) {
					return {};
				}
			}
			
			function saveSignalHistory(history) {
				try {
					localStorage.setItem('signalHistory', JSON.stringify(history));
				} catch (e) {
					console.error('Error saving signal history:', e);
				}
			}
			
			// Notification functions
			function requestNotificationPermission() {
				if ('Notification' in window) {
					if (Notification.permission === 'default') {
						Notification.requestPermission().then(permission => {
							updateNotificationButton();
						});
					} else {
						updateNotificationButton();
					}
				}
			}
			
			function updateNotificationButton() {
				const btn = document.getElementById('request-notification-btn');
				if (!btn) return;
				
				if ('Notification' in window) {
					if (Notification.permission === 'granted') {
						btn.style.display = 'none';
					} else if (Notification.permission === 'denied') {
						btn.textContent = 'üîî Notifications Blocked';
						btn.style.opacity = '0.5';
						btn.disabled = true;
					} else {
						btn.style.display = 'block';
					}
				}
			}
			
			function playNotificationSound() {
				try {
					const audioContext = new (window.AudioContext || window.webkitAudioContext)();
					const oscillator = audioContext.createOscillator();
					const gainNode = audioContext.createGain();
					
					oscillator.connect(gainNode);
					gainNode.connect(audioContext.destination);
					
					oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
					oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
					
					gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
					
					oscillator.start(audioContext.currentTime);
					oscillator.stop(audioContext.currentTime + 0.3);
				} catch (e) {
					console.error('Error playing sound:', e);
				}
			}
			
			function showNotification(title, body, symbol) {
				playNotificationSound();
				
				if ('Notification' in window && Notification.permission === 'granted') {
					const notification = new Notification(title, {
						body: body,
						icon: '/favicon.ico',
						badge: '/favicon.ico',
						tag: symbol
					});
					
					setTimeout(() => notification.close(), 5000);
					notification.onclick = () => {
						window.focus();
						notification.close();
					};
				}
				
				showVisualAlert(title, body, symbol);
			}
			
			function showVisualAlert(title, body, symbol) {
				const alert = document.createElement('div');
				alert.style.cssText = `
					position: fixed; top: 20px; right: 20px;
					background: rgba(255, 193, 7, 0.95); color: #000;
					padding: 15px 20px; border-radius: 8px;
					box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
					z-index: 10000; max-width: 350px;
					animation: slideIn 0.3s ease-out;
				`;
				alert.innerHTML = `
					<div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${title}</div>
					<div style="font-size: 14px; color: rgba(0, 0, 0, 0.8);">${body}</div>
				`;
				
				const style = document.createElement('style');
				style.textContent = `@keyframes slideIn {
					from { transform: translateX(400px); opacity: 0; }
					to { transform: translateX(0); opacity: 1; }
				}`;
				document.head.appendChild(style);
				
				document.body.appendChild(alert);
				setTimeout(() => {
					alert.style.animation = 'slideIn 0.3s ease-out reverse';
					setTimeout(() => alert.remove(), 300);
				}, 5000);
			}
			
			function checkWatchlistChanges(currentSignals) {
				const watchlist = getWatchlist();
				if (watchlist.length === 0) return;
				
				const previousSignals = getSignalHistory();
				const currentSignalMap = {};
				
				currentSignals.forEach(signal => {
					currentSignalMap[signal.symbol] = {
						action: signal.action || 'unknown',
						buyScore: signal.buy_score || 0,
						sellScore: signal.sell_score || 0
					};
				});
				
				watchlist.forEach(symbol => {
					const current = currentSignalMap[symbol];
					const previous = previousSignals[symbol];
					
					if (!current) return;
					
					if (previous) {
						if (current.action.toLowerCase() !== previous.action.toLowerCase()) {
							showNotification(`${symbol} Signal Changed!`, 
								`Changed from ${previous.action.toUpperCase()} to ${current.action.toUpperCase()}`, symbol);
						} else if (current.action.toLowerCase() === 'buy' && current.buyScore >= 16 && previous.buyScore < 16) {
							showNotification(`${symbol} BUY Threshold Met!`, 
								`BUY score: ${current.buyScore}/38`, symbol);
						} else if (current.action.toLowerCase() === 'sell' && current.sellScore >= 13 && previous.sellScore < 13) {
							showNotification(`${symbol} SELL Threshold Met!`, 
								`SELL score: ${current.sellScore}/37`, symbol);
						}
					}
				});
				
				saveSignalHistory(currentSignalMap);
			}
			
			function updateWatchlistDisplay() {
				const container = document.getElementById('watchlist-items');
				if (!container) return;
				
				// Check if user has access (trial active or subscribed)
				if (!hasAccess()) {
					const paymentLinkConfigured = STRIPE_PAYMENT_LINK && STRIPE_PAYMENT_LINK !== 'https://buy.stripe.com/YOUR_PAYMENT_LINK_HERE';
					container.innerHTML = paymentLinkConfigured 
						? `<div style="color: rgba(255, 255, 255, 0.9); text-align: center; padding: 30px; grid-column: 1 / -1; background: rgba(244, 67, 54, 0.15); border: 2px solid rgba(244, 67, 54, 0.7); border-radius: 8px;">
							<p style="font-size: 16px; margin-bottom: 15px; font-weight: bold;">‚è∞ Your Trial Has Expired</p>
							<p style="font-size: 14px; margin-bottom: 20px; color: rgba(255, 255, 255, 0.8);">Subscribe to access your watchlist and get notifications.</p>
							<a href="${STRIPE_PAYMENT_LINK}" target="_blank" onclick="event.stopPropagation();" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 14px; font-weight: bold; cursor: pointer; text-decoration: none;">üí≥ Subscribe Now</a>
						</div>`
						: `<div style="color: rgba(255, 255, 255, 0.9); text-align: center; padding: 30px; grid-column: 1 / -1; background: rgba(244, 67, 54, 0.15); border: 2px solid rgba(244, 67, 54, 0.7); border-radius: 8px;">
							<p style="font-size: 16px; margin-bottom: 15px; font-weight: bold;">‚è∞ Your Trial Has Expired</p>
							<p style="font-size: 14px; margin-bottom: 20px; color: rgba(255, 255, 255, 0.8);">Subscribe to access your watchlist.</p>
						</div>`;
					return;
				}
				
				const watchlist = getWatchlist();
				
				if (watchlist.length === 0) {
					container.innerHTML = `<div style="color: rgba(255, 255, 255, 0.5); text-align: center; padding: 20px; font-style: italic; grid-column: 1 / -1;">
						No symbols in watchlist yet. Add symbols using the ‚≠ê button on signal cards.
					</div>`;
					return;
				}
				
				const currentSignals = window.allSignals || [];
				const signalMap = {};
				currentSignals.forEach(s => signalMap[s.symbol] = s);
				
				container.innerHTML = watchlist.map(symbol => {
					const signal = signalMap[symbol];
					const isBuy = signal && signal.action && signal.action.toLowerCase() === 'buy';
					return `<div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 6px; border-left: 3px solid ${isBuy ? '#4caf50' : '#f44336'};">
						<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
							<span style="font-weight: bold; color: #ffc107;">${symbol}</span>
							<button onclick="toggleWatchlist('${symbol.replace(/'/g, "\\'")}');" 
									style="background: rgba(255, 193, 7, 0.2); border: 1px solid #ffc107; color: #ffc107; padding: 2px 6px; border-radius: 4px; cursor: pointer; font-size: 12px;">
								Remove
							</button>
						</div>
						<div style="color: rgba(255, 255, 255, 0.8); font-size: 13px;">
							${isBuy ? 'üü¢' : 'üî¥'} ${signal ? signal.action.toUpperCase() : 'No Signal'}
							${(() => {
								if (!signal) return '';
								const price = getSignalPrice(signal);
								if (price !== null && price !== undefined) {
									return ` | $${parseFloat(price).toFixed(2)}`;
								} else if (signal.source && signal.source.includes('TradingView')) {
									return ` | Market Price`;
								}
								return '';
							})()}
						</div>
					</div>`;
				}).join('');
			}
			
			// Initialize on page load
			document.addEventListener('DOMContentLoaded', function() {
				updateNotificationButton();
				const btn = document.getElementById('request-notification-btn');
				if (btn) btn.addEventListener('click', requestNotificationPermission);
				updateWatchlistDisplay();
			});
		</script>
		
		<!-- Optional Code to Download Section -->
		<section id="code-download-section" style="max-width: 1200px; margin: 60px auto 40px; padding: 0 20px;">
			<div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(255, 193, 7, 0.3); border-radius: 12px; padding: 30px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
				<h2 style="color: #ffc107; font-size: 28px; margin-bottom: 10px; font-weight: bold; text-align: center; text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);">
					üì• Optional Code to Download
				</h2>
				<p style="color: rgba(255, 255, 255, 0.8); text-align: center; margin-bottom: 15px; font-size: 16px;">
					Access premium trading code and unique indicators for pinescript. I'm choosing to upload pinescript first because it is low risk of me hacking you. It just gives signals on tradingview.com no connection of brokers or wallets.
				</p>
				<div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 30px; border-radius: 4px;">
					<p style="color: rgba(255, 255, 255, 0.9); font-size: 14px; margin: 0; line-height: 1.6;">
						<strong style="color: #ffc107;">üìå Note:</strong> The code provided here is written in <strong>PineScript</strong>, which is proprietary code designed specifically for <strong>TradingView</strong> users. This code is ideal for TradingView platform integration. If you need to adapt it for other trading platforms or languages, you can easily convert it by running the code through AI tools (such as ChatGPT, Claude, etc.) and asking it to translate the logic to your desired language or platform.
					</p>
				</div>
				
				<div id="code-download-content">
					<!-- Content will be populated by JavaScript based on subscription status -->
				</div>
			</div>
		</section>
		
		<script>
			// Store code downloads in a global object
			// Note: Code is stored in template literals which preserve exact whitespace and formatting
			window.codeDownloads = {};
			
			// Function to download code as file
			// Preserves exact formatting, indentation, and newlines from source files
			function downloadCode(filename, codeId) {
				const codeContent = window.codeDownloads[codeId];
				if (!codeContent) {
					alert('Code not found. Please refresh the page.');
					return;
				}
				// Use text/plain with UTF-8 encoding to preserve all formatting exactly
				// Template literals preserve whitespace, and Blob preserves it in the downloaded file
				const blob = new Blob([codeContent], { type: 'text/plain;charset=utf-8' });
				const url = window.URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				window.URL.revokeObjectURL(url);
			}
			
			// Function to update code download section based on subscription status
			function updateCodeDownloadSection() {
				const container = document.getElementById('code-download-content');
				if (!container) return;
				
				// Save which details elements are open before updating
				const openDetails = [];
				const detailsElements = container.querySelectorAll('details');
				detailsElements.forEach((details, index) => {
					if (details.open) {
						openDetails.push(index);
					}
				});
				
				if (!hasAccess()) {
					const paymentLinkConfigured = STRIPE_PAYMENT_LINK && STRIPE_PAYMENT_LINK !== 'https://buy.stripe.com/YOUR_PAYMENT_LINK_HERE';
					container.innerHTML = `
						<div style="text-align: center; padding: 40px 20px; background: rgba(244, 67, 54, 0.15); border: 2px solid rgba(244, 67, 54, 0.7); border-radius: 8px;">
							<p style="color: #fff; font-size: 20px; margin-bottom: 15px; font-weight: bold;">üîí Premium Content</p>
							<p style="color: rgba(255, 255, 255, 0.9); font-size: 16px; margin-bottom: 25px;">Subscribe to access downloadable trading code and indicators.</p>
							${paymentLinkConfigured 
								? `<a href="${STRIPE_PAYMENT_LINK}" target="_blank" onclick="event.stopPropagation();" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 14px 28px; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; text-decoration: none; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 25px rgba(102, 126, 234, 0.7)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.5)';">üí≥ Pay Now - $9.99 One-Time (Limited Time)</a>`
								: `<a href="#" onclick="event.preventDefault(); showSubscriptionModal(); return false;" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 14px 28px; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; text-decoration: none;">üí≥ Subscribe Now</a>`
							}
						</div>
					`;
					return;
				}
				
				// User has access - show code downloads
				// Store DXY code in global object for download
				window.codeDownloads['dxy_indicator'] = `// Github Rustyribcage
// This indicator is written in pinescript code and is designed to be used in tradingview.com to overlay the DXY (Dollar Index) on the chart.
// It normalizes the DXY data to fit within the range [0, 1] and calculates a 15-bar average.
// It also provides alerts for significant changes in the DXY state, indicating hawkish or dovish conditions.
// Many traders realize the importance of understanding what the dollar is doing since everything is measured 
// in dollars. So if this indicator is high, it is bearish, not bullish! I color coded it so that it was a bit 
// more intuitive to understand.
// @version=5
indicator("Favorable DXY Overlay", overlay = false)

// Use libraries to fix the 40 request.security problem?
// Define the symbol for the DXY (Dollar Index) chart
dxySymbol = "DXY"

// Fetch DXY data using the security function
dxyClose = request.security(dxySymbol, "D", close)

// Calculate the minimum and maximum values of DXY data
dxyMin = ta.lowest(dxyClose, 50)
dxyMax = ta.highest(dxyClose, 50)

// Normalize the DXY data to fit within the range [0, 1]
normalizedDXY = (dxyClose - dxyMin) / (dxyMax - dxyMin)

// Function to calculate the average of a series over a specified period
avgSeries(source, length) =>
    sum = 0.0
    for i = 0 to length - 1
        sum := sum + source[i]
    sum / length

// Calculate the 5-bar average of normalizedDXY
averageNormalizedDXY = avgSeries(normalizedDXY, 15)

// Initialize variables so that it only alerts me when there is change.
var bool prevHawkishDXYAlert = false
var bool prevDovishDXYAlert = false

// Labeling DXY extremes. > >= ? < or <= ? seems to not effect anything. Use these more throughout the script.
hawkishDXY = normalizedDXY < 1 and averageNormalizedDXY < 1
dovishDXY = normalizedDXY > 0 and averageNormalizedDXY > 0 
nonUltraHawkishDXY = normalizedDXY <= 0.9 and averageNormalizedDXY <= 0.9
nonUltraDovishDXY = normalizedDXY >= 0.1 and averageNormalizedDXY >= 0.1

hawkishDXYAlert = normalizedDXY < 0.5 and averageNormalizedDXY < 0.5
dovishDXYAlert = normalizedDXY > 0.5 and averageNormalizedDXY >0.5

// Check for state change and trigger alerts
if hawkishDXYAlert != prevHawkishDXYAlert
    alert(message="Hawkish DXY above 0.5")
    prevHawkishDXYAlert := hawkishDXYAlert

if dovishDXYAlert != prevDovishDXYAlert
    alert(message="Dovish DXY below 0.5")
    prevDovishDXYAlert := dovishDXYAlert

// Obsolete alerts.
// if hawkishDXYAlert
//    alert(message = "Hawkish DXY above 0.5")
// if dovishDXYAlert
//    alert(message = "Dovish DXY below 0.5")
// Define colors for the range [0, 1]
colorDovish = color.green
colorHawkish = color.red

// Set the transparency for the colors
transparency = 50

// Plot the 5-bar average of normalized DXY data
plot(averageNormalizedDXY, title="15-Bar Avg Normalized DXY", color=averageNormalizedDXY >= 0.5 ? colorHawkish : colorDovish, linewidth=2, transp=transparency)

// Plot the normalized DXY data as an overlay on the main chart
plot(normalizedDXY, title = "Normalized DXY", color = normalizedDXY >= 0.5 ? colorHawkish : colorDovish, linewidth = 2, transp = transparency)


alertcondition(normalizedDXY < 0.5 and averageNormalizedDXY < 0.5, title = "DXY Below 0.5", message = "Dovish DXY is Below 0.5!")
alertcondition(normalizedDXY > 0.5 and averageNormalizedDXY >0.5, title = "DXY Above 0.5", message = "Hawkish DXY is Above 0.5!")`;

				// Store Normalized MFI + OBV code in global object for download
				window.codeDownloads['normalized_mfi_obv'] = `//@version=5
indicator("Standardized OBV (0-100) and MFI", overlay=false)

// OBV calculation
obv = ta.cum(math.sign(close - close[1]) * volume)

// Input for lookback period to find the min/max OBV
lookbackPeriod = input.int(14, title="Lookback Period", minval=1)

// Find the minimum and maximum OBV in the lookback period
minOBV = ta.lowest(obv, lookbackPeriod)
maxOBV = ta.highest(obv, lookbackPeriod)

// Standardize OBV to a 0-100 scale
standardizedOBV = (obv - minOBV) / (maxOBV - minOBV) * 100

// Plot the standardized OBV
plot(standardizedOBV, color=color.blue, title="Standardized OBV (0-100)")

// Optional: Plot MFI for comparison
mfi = ta.mfi(close, 14)  // Default MFI with 14 periods
plot(mfi, color=color.green, title="MFI (14)", style=plot.style_line)`;

				// Store Parabola Detector code in global object for download
				window.codeDownloads['parabola_detector'] = `// ============================================================================
// Parabola v7 - Parabola Detector Module
// ============================================================================
// This Pine Script module detects parabolic price movements and plots visual
// markers when upward or downward parabolas break. The indicator uses curve
// fitting with R-squared confidence to identify parabolic trends.
//
// KEY FEATURES:
// - Detects parabolic price movements using mathematical curve fitting
// - Plots orange X crosses when upward parabolas break (bearish reversal signal)
// - Plots orange X crosses when downward parabolas break (bullish reversal signal)  
// - Includes ATR and ADX filters to reduce false signals
// - Configurable persistence duration for break signals
// - Info table showing parabola status, confidence, and filter states
// - Background color changes when parabolas are detected
//
// BREAK PLOTS:
// - Bull Break: Orange X cross appears ABOVE bar when upward parabola breaks
// - Bear Break: Orange X cross appears BELOW bar when downward parabola breaks
// - These breaks indicate potential reversal points in price action
// ============================================================================

// ============================================================================
// Parabola v7
// ============================================================================
// Performance settings (originally from indicator declaration)
// ============================================================================
// CHANGELOG - Today's Modifications (for Python to Pine Script migration)
// 1. REMOVED INDICATOR DECLARATION
//    - Removed @version=5 and indicator() declaration to prevent conflicts
//    - This allows the code to be safely added to strategy scripts
//    - Added max_bars_back and max_lines_count as input parameters instead
//
// 2. RENAMED VARIABLES FOR UNIQUENESS
//    - plus_dm ‚Üí plus_dm_parabola (to avoid conflicts with main strategy)
//    - minus_dm ‚Üí minus_dm_parabola (to avoid conflicts with main strategy)
//    - dx ‚Üí dx_parabola (to avoid conflicts with main strategy)
//    - adx ‚Üí adx_parabola (to avoid conflicts with main strategy)
//    - All references updated throughout the code
//
// 3. PLOT STATEMENTS (v7)
//    - Added plotshapes for parabola break detection (bull/bear breaks)
//    - Removed curved parabola line drawing logic (not needed)
//    - Kept all core logic, alerts, and info table
//    - Includes break detection plots for visual feedback
//
// 4. ADDED PERFORMANCE PARAMETERS
//    - max_bars_back = input.int(500, "Max Bars Back", minval=100, maxval=1000, group="Performance")
//    - max_lines_count = input.int(500, "Max Lines Count", minval=100, maxval=1000, group="Performance")
//    - These replace the original hardcoded values from indicator declaration
//
// 5. MAINTAINED FUNCTIONALITY
//    - All parabola detection logic preserved
//    - All ATR and ADX filtering preserved
//    - All entry/exit signals preserved
//    - All alerts preserved
//    - Info table with status display preserved
//    - Background color changes preserved
//
// 6. UPDATED DEFAULTS (v6)
//    - max_bars_back default lowered to 100 (was 500 in v5) to reduce calculation time
//    - You can increase this if you need more history, at the cost of performance
//
// 7. DOCUMENTATION CHANGES (v6)
//    - Changelog/comments condensed versus v5; functionality remains the same
//
// 8. PARABOLA BREAK PLOTS (v7)
//    - Added plotshapes for visual parabola break detection
//    - Orange X crosses show when bullish/bearish parabolas break
//    - Helps identify reversal signals visually on chart
//
// PURPOSE: This module can now be safely integrated into larger Pine Script
// strategies without variable name conflicts or declaration errors.
// ============================================================================
// ============================================================================
// INPUT PARAMETERS
// ============================================================================
// Master toggle to enable/disable entire parabola module
enable_parabola = input.bool(true, "Enable Parabola Module", group="Parabola", tooltip="Master toggle: When OFF, all parabola calculations are skipped for better performance")

// Performance settings (originally from indicator declaration)
max_bars_back = input.int(100, "Max Bars Back", minval=100, maxval=1000, group="Parabola")
max_lines_count = input.int(500, "Max Lines Count", minval=100, maxval=1000, group="Parabola")

lookback_period_parabola = input.int(50, "Lookback Period", minval=10, maxval=200, group="Parabola")
confidence_threshold_parabola = input.float(0.70, "Confidence Threshold", minval=0.5, maxval=1.0, group="Parabola")
deviation_threshold_parabola = input.float(0.02, "Deviation Threshold", minval=0.01, maxval=0.1, group="Parabola")

// Removed curve_type input - going back to parabola only

// Visual settings
show_parabola = input.bool(true, "Show Parabola Line", group="Parabola")
show_bands = input.bool(true, "Show Deviation Bands", group="Parabola")
show_signals = input.bool(false, "Show Entry/Exit Signals", group="Parabola") // Labels long/short unbroken/broken
show_info = input.bool(true, "Show Info Table", group="Parabola")
show_debug_labels = input.bool(false, "Show Debug Labels (R¬≤)", group="Parabola")

parabola_color = input.color(color.blue, "Parabola Color", group="Parabola")
band_color = input.color(color.gray, "Band Color", group="Parabola")
long_color = input.color(color.green, "Long Signal Color", group="Parabola")
short_color = input.color(color.red, "Short Signal Color", group="Parabola")
exit_color = input.color(color.orange, "Exit Signal Color", group="Parabola")

// Add ATR and ADX calculations
use_atr_filter_parabola = input.bool(true, "Use ATR Filter", group="Parabola")
use_adx_filter_parabola = input.bool(true, "Use ADX Filter", group="Parabola")
atr_period_parabola = input.int(14, "ATR Period", minval=1, maxval=50, group="Parabola")
adx_period_parabola = input.int(14, "ADX Period", minval=1, maxval=50, group="Parabola")
adx_threshold_parabola = input.int(15, "ADX Threshold", minval=10, maxval=50, group="Parabola")
atr_threshold_parabola = input.float(0.3, "ATR Threshold Multiplier", minval=0.1, maxval=2.0, group="Parabola")

// Persistence settings
use_persistence_parabola = input.bool(true, "Use Signal Persistence", group="Parabola")
// #TODO: Backtest persistence_duration_parabola to find optimal value for your trading pairs
persistence_duration_parabola = input.int(16, "End Signal Persistence (bars)", minval=1, maxval=100, group="Parabola", tooltip="How long the 'parabola break' signal persists after detection. For 1h candles: 16 bars = 16 hours. Shorter (3-6h) = more signals but higher false signal risk. Longer (12-24h) = more conservative, higher confidence signals.")

// EMA invalidation filter (for Elliott Wave 5th wave continuation)
use_ema_invalidation_parabola = input.bool(true, "Use EMA Invalidation", group="Parabola", tooltip="Invalidate persistence if price crosses above/below EMA (catches 5th wave continuations)")
ema_period_parabola = input.int(26, "EMA Period for Invalidation", minval=5, maxval=100, group="Parabola", tooltip="Short EMA to detect trend continuation. If price crosses above EMA after upward break, invalidate (5th wave may be coming). If price crosses below EMA after downward break, invalidate.")

// Position management settings
use_position_tracking_parabola = input.bool(false, "Use Position Tracking", group="Parabola", tooltip="Disable this if you handle positions in your main strategy")

// ============================================================================
// VARIABLES
// ============================================================================
var float parabola_a = na
var float parabola_b = na
var float parabola_c = na
var float parabola_confidence = na
var string parabola_direction = na
var bool in_parabola = false
var int parabola_start_bar = na
var int parabola_end_bar = na

// Position tracking
var int position_parabola = 0  // 0 = no position, 1 = long, -1 = short
var float entry_price_parabola = na
var int entry_bar_parabola = na

// Persistence tracking variables
var bool persistent_bull_parabola = false
var bool persistent_bear_parabola = false
var bool persistent_bull_parabola_end = false
var bool persistent_bear_parabola_end = false
var int bull_parabola_end_bar = na
var int bear_parabola_end_bar = na

// Arrays for price data
var float[] prices = array.new_float(0)
var int[] bars = array.new_int(0)

// Fitting variables
var float a_parabola = na
var float b_parabola = na
var float c_parabola = na
var float r_squared_parabola = na

// ============================================================================
// PARABOLA CALCULATIONS (only run if enable_parabola is true)
// ============================================================================
// Declare parabola-specific variables (initialized to default values)
var float atr_parabola = 0.0
var float adx_parabola = 0.0
var float ema_parabola = close

if enable_parabola
    // Manual ADX calculation
    // Calculate True Range
    tr1_parabola = high - low
    tr2_parabola = math.abs(high - close[1])
    tr3_parabola = math.abs(low - close[1])
    tr_parabola = math.max(tr1_parabola, math.max(tr2_parabola, tr3_parabola))

    // Calculate Directional Movement
    high_diff_parabola = high - high[1]
    low_diff_parabola = low[1] - low

    // +DM: Current high - Previous high (if positive and greater than previous low - current low)
    plus_dm_parabola = high_diff_parabola > low_diff_parabola and high_diff_parabola > 0 ? high_diff_parabola : 0
    // -DM: Previous low - Current low (if positive and greater than current high - previous high)
    minus_dm_parabola = low_diff_parabola > high_diff_parabola and low_diff_parabola > 0 ? low_diff_parabola : 0

    // Smooth the values using Wilder's smoothing (exponential moving average)
    tr_smooth_parabola = ta.ema(tr_parabola, adx_period_parabola)
    plus_dm_smooth_parabola = ta.ema(plus_dm_parabola, adx_period_parabola)
    minus_dm_smooth_parabola = ta.ema(minus_dm_parabola, adx_period_parabola)

    // Calculate +DI and -DI
    plus_di_parabola = tr_smooth_parabola != 0 ? (plus_dm_smooth_parabola / tr_smooth_parabola) * 100 : 0
    minus_di_parabola = tr_smooth_parabola != 0 ? (minus_dm_smooth_parabola / tr_smooth_parabola) * 100 : 0

    // Calculate DX (Directional Index)
    dx_parabola = (plus_di_parabola + minus_di_parabola) != 0 ? math.abs(plus_di_parabola - minus_di_parabola) / (plus_di_parabola + minus_di_parabola) * 100 : 0

    // Calculate ADX, ATR, and EMA for persistence invalidation (catches 5th wave continuations)
    atr_parabola := ta.atr(atr_period_parabola)
    adx_parabola := ta.ema(dx_parabola, adx_period_parabola)
    ema_parabola := ta.ema(close, ema_period_parabola)
else
    // When parabola is disabled, set default values
    atr_parabola := 0.0
    adx_parabola := 0.0
    ema_parabola := close

// ============================================================================
// PARABOLA DETECTION FUNCTIONS
// ============================================================================
parabolic_function(x, a, b, c) =>
    a * x * x + b * x + c

calculate_r_squared(prices_array, a, b, c) =>
    if array.size(prices_array) < 3
        0
    else
        sum_residuals = 0.0
        sum_total = 0.0
        mean_price = array.avg(prices_array)
        
        for i = 0 to array.size(prices_array) - 1
            predicted = parabolic_function(i, a, b, c)
            actual = array.get(prices_array, i)
            residual = actual - predicted
            sum_residuals += residual * residual
            sum_total += (actual - mean_price) * (actual - mean_price)
        
        r_squared = sum_total != 0 ? 1 - (sum_residuals / sum_total) : 0
        r_squared

fit_parabola(prices_array) =>
    if array.size(prices_array) < 3
        [na, na, na, 0]
    else
        // Simple parabola fitting using least squares
        n = array.size(prices_array)
        sum_x = 0.0
        sum_x2 = 0.0
        sum_x4 = 0.0
        sum_y = 0.0
        sum_xy = 0.0
        sum_x2y = 0.0
        
        for i = 0 to n - 1
            x = float(i)
            y = array.get(prices_array, i)
            x2 = x * x
            
            sum_x += x
            sum_x2 += x2
            sum_x4 += x2 * x2
            sum_y += y
            sum_xy += x * y
            sum_x2y += x2 * y
        
        // Solve system of equations for a, b, c
        det = n * sum_x4 - sum_x2 * sum_x2
        
        if det != 0
            a = (n * sum_x2y - sum_x2 * sum_y) / det
            b = (sum_xy * sum_x2 - sum_x2y * sum_x) / det
            c = (sum_y - a * sum_x2 - b * sum_x) / n
            
            // Calculate R-squared
            r_squared = calculate_r_squared(prices_array, a, b, c)
            [a, b, c, r_squared]
        else
            [na, na, na, 0]

// Removed exponential function - parabola only

// ============================================================================
// PARABOLA MAIN LOGIC (only run if enable_parabola is true)
// ============================================================================
if enable_parabola
    // Add current price to arrays
    array.push(prices, close)
    array.push(bars, bar_index)

    // Keep only lookback_period_parabola values
    if array.size(prices) > lookback_period_parabola
        array.shift(prices)
        array.shift(bars)

    // Detect parabola when we have enough data - WITH FILTERS
    if array.size(prices) >= lookback_period_parabola
        // Check market conditions based on toggle settings
        is_trending_parabola = use_adx_filter_parabola ? adx_parabola > adx_threshold_parabola : true
        has_volatility_parabola = use_atr_filter_parabola ? atr_parabola > ta.sma(atr_parabola, 20) * atr_threshold_parabola : true
        
        // Only detect parabola when filters are satisfied
        if is_trending_parabola and has_volatility_parabola
            // Fit the curve - parabola only
            [temp_a_parabola, temp_b_parabola, temp_c_parabola, temp_r_squared_parabola] = fit_parabola(prices)
            a_parabola := temp_a_parabola
            b_parabola := temp_b_parabola
            c_parabola := temp_c_parabola
            r_squared_parabola := temp_r_squared_parabola
        
        // Debug output
        if not na(a_parabola) and show_debug_labels
            label.new(bar_index, high, "R¬≤=" + str.tostring(r_squared_parabola, "#.###") + "\\nConf=" + str.tostring(confidence_threshold_parabola, "#.###"), color=color.blue, style=label.style_label_down, textcolor=color.white, size=size.tiny)
        
        if not na(a_parabola) and r_squared_parabola >= confidence_threshold_parabola
            parabola_a := a_parabola
            parabola_b := b_parabola
            parabola_c := c_parabola
            parabola_confidence := r_squared_parabola
            parabola_direction := a_parabola > 0 ? "up" : "down"
            in_parabola := true
            parabola_start_bar := array.get(bars, 0)
            parabola_end_bar := bar_index
            
            // Debug label for successful detection
            if show_debug_labels
                label.new(bar_index, low, "DETECTED!\\nParabola\\nR¬≤=" + str.tostring(r_squared_parabola, "#.###"), color=color.green, style=label.style_label_up, textcolor=color.white)
            
            // #TODO: Single signal entry logic - COULD be a strategy (entering on parabola detection, not break)
            // This enters positions when parabola is first detected (momentum following strategy)
            // Currently not used in main strategy - focusing on breakout/reversal strategy instead
            // Generate entry signals
            if use_position_tracking_parabola
                if position_parabola == 0
                    if parabola_direction == "up"
                        position_parabola := 1
                        entry_price_parabola := close
                        entry_bar_parabola := bar_index
                        if show_signals
                            label.new(bar_index, low, "LONG\\nParabola UP", color=long_color, style=label.style_label_up, textcolor=color.white)
                    else if parabola_direction == "down"
                        position_parabola := -1
                        entry_price_parabola := close
                        entry_bar_parabola := bar_index
                        if show_signals
                            label.new(bar_index, high, "SHORT\\nParabola DOWN", color=short_color, style=label.style_label_down, textcolor=color.white)
            else
                // Just show signals without position tracking
                if parabola_direction == "up" and show_signals
                    label.new(bar_index, low, "LONG\\nParabola UP", color=long_color, style=label.style_label_up, textcolor=color.white)
                else if parabola_direction == "down" and show_signals
                    label.new(bar_index, high, "SHORT\\nParabola DOWN", color=short_color, style=label.style_label_down, textcolor=color.white)

// Check for parabola break if in position - SIMPLIFIED (like v3)
// Calculate deviation for all cases (needed for persistence logic)
var float deviation_parabola = na
if in_parabola and not na(parabola_a)
    time_diff_parabola = bar_index - parabola_start_bar
    var float expected_price_parabola = na
    expected_price_parabola := parabolic_function(time_diff_parabola, parabola_a, parabola_b, parabola_c)
    deviation_parabola := math.abs(close - expected_price_parabola) / close
else
    deviation_parabola := na

// Check for parabola break if in position
if use_position_tracking_parabola and position_parabola != 0 and in_parabola and not na(parabola_a) and not na(deviation_parabola)
    // Simple exit condition (like v3)
    if deviation_parabola > deviation_threshold_parabola
        // Exit position
        if show_signals
            label.new(bar_index, position_parabola == 1 ? low : high, "EXIT\\nParabola Break", color=exit_color, style=label.style_label_up, textcolor=color.white)
        
        position_parabola := 0
        entry_price_parabola := na
        entry_bar_parabola := na
        in_parabola := false
        parabola_a := na
        parabola_b := na
        parabola_c := na
        parabola_confidence := na
        parabola_direction := na
if not use_position_tracking_parabola and in_parabola and not na(parabola_a) and not na(deviation_parabola)
    // Just show exit signals without position tracking
    if deviation_parabola > deviation_threshold_parabola and show_signals
        label.new(bar_index, parabola_direction == "up" ? low : high, "EXIT\\nParabola Break", color=exit_color, style=label.style_label_up, textcolor=color.white)

// ============================================================================
// PARABOLA PERSISTENCE LOGIC (only run if enable_parabola is true)
// ============================================================================
if enable_parabola
    // Update persistent signals based on current state
    if use_persistence_parabola
        if use_position_tracking_parabola
        // Bull parabola persistence with position tracking
        if in_parabola and parabola_direction == "up" and position_parabola == 1
            persistent_bull_parabola := true
            persistent_bear_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := na
            bear_parabola_end_bar := na
        else if position_parabola == 1 and not na(deviation_parabola) and deviation_parabola > deviation_threshold_parabola
            persistent_bull_parabola := false
            persistent_bear_parabola := false
            persistent_bull_parabola_end := true
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := bar_index
            bear_parabola_end_bar := na
        // Keep bull_parabola_end true until duration expires, EMA invalidation, or new parabola
        else if persistent_bull_parabola_end and position_parabola == 0
            // EMA invalidation: If price crosses above EMA, invalidate (5th wave continuation)
            if use_ema_invalidation_parabola and close > ema_parabola
                persistent_bull_parabola_end := false
                bull_parabola_end_bar := na
            // Check if duration has expired
            else if not na(bull_parabola_end_bar) and (bar_index - bull_parabola_end_bar) > persistence_duration_parabola
                persistent_bull_parabola_end := false
                bull_parabola_end_bar := na
            else
                // Keep persistent_bull_parabola_end = true (don't reset it)
                persistent_bull_parabola := false
                persistent_bear_parabola := false
                persistent_bear_parabola_end := false
        
        // Bear parabola persistence with position tracking
        if in_parabola and parabola_direction == "down" and position_parabola == -1
            persistent_bear_parabola := true
            persistent_bull_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := na
            bear_parabola_end_bar := na
        else if position_parabola == -1 and not na(deviation_parabola) and deviation_parabola > deviation_threshold_parabola
            persistent_bear_parabola := false
            persistent_bull_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := true
            bull_parabola_end_bar := na
            bear_parabola_end_bar := bar_index
        // Keep bear_parabola_end true until duration expires, EMA invalidation, or new parabola
        else if persistent_bear_parabola_end and position_parabola == 0
            // EMA invalidation: If price crosses below EMA, invalidate (5th wave continuation)
            if use_ema_invalidation_parabola and close < ema_parabola
                persistent_bear_parabola_end := false
                bear_parabola_end_bar := na
            // Check if duration has expired
            else if not na(bear_parabola_end_bar) and (bar_index - bear_parabola_end_bar) > persistence_duration_parabola
                persistent_bear_parabola_end := false
                bear_parabola_end_bar := na
            else
                // Keep persistent_bear_parabola_end = true (don't reset it)
                persistent_bear_parabola := false
                persistent_bull_parabola := false
                persistent_bull_parabola_end := false
        
        // Reset all signals only when a new parabola is detected (not just when position = 0)
        if not in_parabola and position_parabola == 0 and not persistent_bull_parabola_end and not persistent_bear_parabola_end
            persistent_bull_parabola := false
            persistent_bear_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := na
            bear_parabola_end_bar := na
    else
        // Persistence without position tracking - simpler logic
        if in_parabola and parabola_direction == "up"
            persistent_bull_parabola := true
            persistent_bear_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := na
            bear_parabola_end_bar := na
        else if in_parabola and parabola_direction == "down"
            persistent_bear_parabola := true
            persistent_bull_parabola := false
            persistent_bull_parabola_end := false
            persistent_bear_parabola_end := false
            bull_parabola_end_bar := na
            bear_parabola_end_bar := na
        else if not in_parabola and persistent_bull_parabola
            // Bull parabola ended
            persistent_bull_parabola := false
            persistent_bull_parabola_end := true
            bull_parabola_end_bar := bar_index
        else if not in_parabola and persistent_bear_parabola
            // Bear parabola ended
            persistent_bear_parabola := false
            persistent_bear_parabola_end := true
            bear_parabola_end_bar := bar_index
        else if persistent_bull_parabola_end
            // EMA invalidation: If price crosses above EMA, invalidate (5th wave continuation)
            if use_ema_invalidation_parabola and close > ema_parabola
                persistent_bull_parabola_end := false
                bull_parabola_end_bar := na
            // Check if duration has expired for bull end
            else if not na(bull_parabola_end_bar) and (bar_index - bull_parabola_end_bar) > persistence_duration_parabola
                persistent_bull_parabola_end := false
                bull_parabola_end_bar := na
        else if persistent_bear_parabola_end
            // EMA invalidation: If price crosses below EMA, invalidate (5th wave continuation)
            if use_ema_invalidation_parabola and close < ema_parabola
                persistent_bear_parabola_end := false
                bear_parabola_end_bar := na
            // Check if duration has expired for bear end
            else if not na(bear_parabola_end_bar) and (bar_index - bear_parabola_end_bar) > persistence_duration_parabola
                persistent_bear_parabola_end := false
                bear_parabola_end_bar := na
else
    // No persistence - reset all persistent signals
    persistent_bull_parabola := false
    persistent_bear_parabola := false
    persistent_bull_parabola_end := false
    persistent_bear_parabola_end := false
    bull_parabola_end_bar := na
    bear_parabola_end_bar := na

// ============================================================================
// PARABOLA INFO TABLE (only run if enable_parabola is true)
// ============================================================================
if enable_parabola
    if show_info
    var table info_table = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 80))
    
    table.cell(info_table, 0, 0, "Parabola", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, in_parabola ? "DETECTED" : "NONE", text_color=in_parabola ? color.green : color.red, text_size=size.small)
    
    table.cell(info_table, 0, 1, "Direction", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 1, parabola_direction, text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 2, "Confidence", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 2, str.tostring(parabola_confidence, "#.###"), text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 3, "Position", text_color=color.white, text_size=size.small)
    var string position_text_parabola = ""
    var color position_color_parabola = color.gray
    if use_position_tracking_parabola
        position_text_parabola := position_parabola == 1 ? "LONG" : position_parabola == -1 ? "SHORT" : "NONE"
        position_color_parabola := position_parabola == 1 ? color.green : position_parabola == -1 ? color.red : color.gray
    else
        position_text_parabola := "DISABLED"
        position_color_parabola := color.gray
    table.cell(info_table, 1, 3, position_text_parabola, text_color=position_color_parabola, text_size=size.small)
    
    table.cell(info_table, 0, 4, "Entry Price", text_color=color.white, text_size=size.small)
    if use_position_tracking_parabola
        table.cell(info_table, 1, 4, str.tostring(entry_price_parabola, "#.##"), text_color=color.white, text_size=size.small)
    else
        table.cell(info_table, 1, 4, "N/A", text_color=color.gray, text_size=size.small)
    
    table.cell(info_table, 0, 5, "ADX Filter", text_color=color.white, text_size=size.small)
    adx_status_parabola = use_adx_filter_parabola ? (adx_parabola > adx_threshold_parabola ? "ON ‚úì" : "ON ‚úó") : "OFF"
    adx_color_parabola = use_adx_filter_parabola ? (adx_parabola > adx_threshold_parabola ? color.green : color.red) : color.gray
    table.cell(info_table, 1, 5, adx_status_parabola, text_color=adx_color_parabola, text_size=size.small)
    
    table.cell(info_table, 0, 6, "ATR Filter", text_color=color.white, text_size=size.small)
    atr_status_parabola = use_atr_filter_parabola ? (atr_parabola > ta.sma(atr_parabola, 20) * atr_threshold_parabola ? "ON ‚úì" : "ON ‚úó") : "OFF"
    atr_color_parabola = use_atr_filter_parabola ? (atr_parabola > ta.sma(atr_parabola, 20) * atr_threshold_parabola ? color.green : color.red) : color.gray
    table.cell(info_table, 1, 6, atr_status_parabola, text_color=atr_color_parabola, text_size=size.small)
    
    table.cell(info_table, 0, 7, "ADX Value", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 7, str.tostring(adx_parabola, "#.#"), text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 8, "ATR Value", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 8, str.tostring(atr_parabola, "#.##"), text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 9, "Deviation", text_color=color.white, text_size=size.small)
    if in_parabola and not na(parabola_a)
        time_diff_parabola = bar_index - parabola_start_bar
        var float expected_price_parabola = na
        expected_price_parabola := parabolic_function(time_diff_parabola, parabola_a, parabola_b, parabola_c)
        current_deviation_parabola = math.abs(close - expected_price_parabola) / close
        table.cell(info_table, 1, 9, str.tostring(current_deviation_parabola * 100, "#.##") + "%", text_color=color.white, text_size=size.small)
    else
        table.cell(info_table, 1, 9, "N/A", text_color=color.gray, text_size=size.small)

// ============================================================================
// PARABOLA ALERTS (must be at global scope)
// ============================================================================
// Entry alerts
alertcondition(enable_parabola and position_parabola == 1 and position_parabola[1] == 0, title="Parabola Long Entry", message="Parabola UP detected - Long position entered at {{close}}")

alertcondition(enable_parabola and position_parabola == -1 and position_parabola[1] == 0, title="Parabola Short Entry", message="Parabola DOWN detected - Short position entered at {{close}}")

// Exit alerts
alertcondition(enable_parabola and position_parabola == 0 and position_parabola[1] != 0, title="Parabola Exit", message="Parabola break detected - Position closed at {{close}}")

// Parabola detection alerts
alertcondition(enable_parabola and in_parabola and not in_parabola[1], title="Parabola Detected", message="Parabola {{parabola_direction}} detected with confidence {{parabola_confidence}}")

// ============================================================================
// PARABOLA BACKGROUND COLOR (must be at global scope)
// ============================================================================
bgcolor(enable_parabola and in_parabola ? (parabola_direction == "up" ? color.new(color.green, 95) : color.new(color.red, 95)) : na) 

// ============================================================================
// PARABOLA BREAK PLOTS (must be at global scope)
// ============================================================================
// Plot when bullish parabola breaks (becomes persistent_bull_parabola_end)
bull_parabola_break = enable_parabola and persistent_bull_parabola_end and not persistent_bull_parabola_end[1]
plotshape(series=bull_parabola_break, title="Parabola Bull Break", location=location.abovebar, color=color.orange, style=shape.xcross, size=size.small, text="Bull Break")

// Plot when bearish parabola breaks (becomes persistent_bear_parabola_end)
bear_parabola_break = enable_parabola and persistent_bear_parabola_end and not persistent_bear_parabola_end[1]
plotshape(series=bear_parabola_break, title="Parabola Bear Break", location=location.belowbar, color=color.orange, style=shape.xcross, size=size.small, text="Bear Break")

// ============================================================================
// #TODO: TRADING STRATEGY EXECUTION - Parabola Breakout Strategy
// ============================================================================
// STRATEGY LOGIC:
// 1. SHORT/SELL when upward parabola breaks (reversal signal)
// 2. LONG/BUY when downward parabola breaks (reversal signal)
// 3. Avoid LONG if upward parabola just broke (cooldown protection)
// 4. Avoid SHORT if downward parabola just broke (cooldown protection)
//
// PERSISTENCE DURATION GUIDELINES (for 1-hour candles):
// - Current default: 10 bars = 10 hours
// - The persistent signal stays active for this duration after a parabola break
// - This acts as a "cooldown" to prevent entering trades in the wrong direction
//
// RECOMMENDED VALUES FOR CRYPTO (1h timeframe):
// - Aggressive: 3-6 bars (3-6 hours) - More signals, higher false signal risk
// - Balanced: 8-12 bars (8-12 hours) - Good middle ground
// - Current default: 16 bars (16 hours) - Conservative approach, needs backtesting
// - Very Conservative: 18-24 bars (18-24 hours) - Fewer but higher confidence signals
//
// HOW TO DETERMINE OPTIMAL VALUE:
// 1. Backtest different durations (3, 6, 10, 12, 16, 18, 24 hours)
// 2. Consider crypto volatility - more volatile pairs may need longer cooldowns
// 3. Check win rate vs signal frequency trade-off
// 4. Monitor how often price reverses back into the broken parabola (false breaks)
// 5. For high-volatility crypto: Consider 12-18 hours to avoid whipsaws
// 6. For stable crypto: 6-10 hours may be sufficient
//
// NOTE: This section uses strategy.* functions. Uncomment and integrate into your strategy script.
// Make sure use_position_tracking_parabola = false to avoid conflicts with strategy position management.
//
// if use_persistence_parabola
//     // SHORT entry: Upward parabola broke (reversal signal)
//     if persistent_bull_parabola_end and not persistent_bear_parabola_end
//         // Enter SHORT when upward parabola breaks
//         // strategy.entry("Parabola Short", strategy.short, comment="Upward Parabola Break")
//     
//     // LONG entry: Downward parabola broke (reversal signal)
//     if persistent_bear_parabola_end and not persistent_bull_parabola_end
//         // Enter LONG when downward parabola breaks
//         // strategy.entry("Parabola Long", strategy.long, comment="Downward Parabola Break")
//     
//     // LONG cooldown: Avoid longs if upward parabola just broke
//     if persistent_bull_parabola_end
//         // strategy.cancel("Parabola Long")  // Cancel any pending long orders
//         // Don't enter new long positions during upward parabola break cooldown
//     
//     // SHORT cooldown: Avoid shorts if downward parabola just broke
//     if persistent_bear_parabola_end
//         // strategy.cancel("Parabola Short")  // Cancel any pending short orders
//         // Don't enter new short positions during downward parabola break cooldown
//
// ALTERNATIVE: Entry on first bar of break signal (more aggressive)
// if use_persistence_parabola
//     // SHORT on upward parabola break (first bar only)
//     if persistent_bull_parabola_end and not persistent_bull_parabola_end[1] and not persistent_bear_parabola_end
//         // strategy.entry("Parabola Short", strategy.short, comment="Upward Break Entry")
//     
//     // LONG on downward parabola break (first bar only)
//     if persistent_bear_parabola_end and not persistent_bear_parabola_end[1] and not persistent_bull_parabola_end
//         // strategy.entry("Parabola Long", strategy.long, comment="Downward Break Entry")
//
// EXIT LOGIC (optional - close positions when opposite signal appears):
// if use_persistence_parabola
//     // Close LONG if upward parabola breaks (reversal)
//     if persistent_bull_parabola_end and strategy.position_size > 0
//         // strategy.close("Parabola Long", comment="Upward Break Exit")
//     
//     // Close SHORT if downward parabola breaks (reversal)
//     if persistent_bear_parabola_end and strategy.position_size < 0
//         // strategy.close("Parabola Short", comment="Downward Break Exit")
// ============================================================================

// ============================================================================
// PARABOLA TRADING EXECUTION SCENARIOS
// ============================================================================
// This section documents the four key scenarios for using parabola detection
// in actual trade execution within a larger strategy framework.
//
// SCENARIO 1: bull_parabola = true
// - Trigger: When a bullish parabola is first detected (parabola_direction == "up")
// - Action: Enter LONG position
// - Logic: Price is following a parabolic upward trajectory
// - Risk: Early entry, parabola might not be confirmed yet
// - Use Case: Aggressive long entry on parabola formation
//
// SCENARIO 2: bull_parabola_end = true  
// - Trigger: When a bullish parabola breaks down (deviation > deviation_threshold)
// - Action: Exit LONG position or enter SHORT position
// - Logic: Parabolic trend has ended, reversal likely
// - Risk: Late exit, might miss optimal exit point
// - Use Case: Exit long positions or enter short positions
//
// SCENARIO 3: bear_parabola = true
// - Trigger: When a bearish parabola is first detected (parabola_direction == "down")
// - Action: Enter SHORT position
// - Logic: Price is following a parabolic downward trajectory
// - Risk: Early entry, parabola might not be confirmed yet
// - Use Case: Aggressive short entry on parabola formation
//
// SCENARIO 4: bear_parabola_end = true
// - Trigger: When a bearish parabola breaks up (deviation > deviation_threshold)
// - Action: Exit SHORT position or enter LONG position
// - Logic: Parabolic downtrend has ended, reversal likely
// - Risk: Late exit, might miss optimal exit point
// - Use Case: Exit short positions or enter long positions
//
// IMPLEMENTATION NOTES:
// - These scenarios can be used as boolean conditions in strategy logic
// - Combine with other indicators for confirmation (ADX, ATR, volume)
// - Consider position sizing based on parabola confidence level
// - Use time-based filters to avoid false signals
// - Monitor deviation levels for early warning of parabola breaks
//
// EXAMPLE USAGE IN STRATEGY:
// if bull_parabola
//     strategy.entry("Parabola Long", strategy.long)
// if bull_parabola_end and position == 1
//     strategy.close("Parabola Long")
// if bear_parabola
//     strategy.entry("Parabola Short", strategy.short)
// if bear_parabola_end and position == -1
//     strategy.close("Parabola Short")
//
// VARIABLE MAPPING:
// #TODO: ORIGINAL (Single-bar signals - only true for one bar) - COULD be a strategy later
// These are momentum-following signals (enter when parabola detected, exit on break)
// Currently not used - focusing on breakout/reversal strategy instead
// bull_parabola = in_parabola and parabola_direction == "up" and position == 1
// bull_parabola_end = position == 1 and deviation > deviation_threshold
// bear_parabola = in_parabola and parabola_direction == "down" and position == -1
// bear_parabola_end = position == -1 and deviation > deviation_threshold
//
// PERSISTENT (Multi-bar signals - true throughout parabola duration):
// persistent_bull_parabola = true throughout entire bullish parabola until break
// persistent_bull_parabola_end = true when bullish parabola breaks (persists for persistence_duration bars)
// persistent_bear_parabola = true throughout entire bearish parabola until break
// persistent_bear_parabola_end = true when bearish parabola breaks (persists for persistence_duration bars)
//
// POSITION TRACKING:
// - Set use_position_tracking = false (default) to avoid conflicts with main strategy
// - When disabled: Parabola signals work independently of position management
// - When enabled: Parabola script manages its own position tracking
// - Benefits of disabling: No conflicts with manual trades or main strategy positions
//
// USAGE RECOMMENDATION:
// - Use persistent_* variables for ongoing position management
// - Use original variables for entry/exit timing precision
// - Set use_persistence = true to enable persistent signals (default: true)
// - Set persistence_duration to control how long end signals persist (default: 16 bars = 16 hours on 1h timeframe)
// - Set use_position_tracking = false to avoid conflicts with main strategy
// ============================================================================ `;

				// Store Kalman MA code in global object for download
				window.codeDownloads['kalman_ma'] = `//@version=5
indicator("Kalman Moving Average (Kalman MA)", overlay=true, max_lines_count=500, max_labels_count=500)

// A simple 1D Kalman filter used as a moving average alternative.
// It can respond faster than an EMA for similar smoothness, with tunable process/measurement noise.

// User inputs
src         = input.source(close, "Source")
base_q      = input.float(0.0001, "Base process noise (Q)", minval=0.0, step=0.0001)   // Higher Q ~ shorter EMA (more reactive)
base_r      = input.float(0.01,   "Base measurement noise (R)", minval=0.0, step=0.0001) // Higher R ~ longer EMA (more smoothing)

// Volatility-adaptive tuning (ATR + StdDev blend)
use_adapt   = input.bool(true, "Adaptive Q/R with volatility")
atr_len     = input.int(14, "ATR length", minval=1)
std_len     = input.int(20, "StdDev length", minval=1)
vol_blend   = input.float(0.5, "Blend ATR vs StdDev (0=ATR,1=Std)", minval=0.0, maxval=1.0, step=0.05)
q_scale     = input.float(2.0, "Q scale at high vol", minval=0.0, step=0.1)
r_scale     = input.float(2.0, "R scale at low vol", minval=0.0, step=0.1)
vol_floor   = input.float(0.0005, "Vol floor (avoid div/0)", minval=0.0, step=0.0001)

show_ema    = input.bool(true, "Show EMA comparison")
ema_length  = input.int(2, "EMA length", minval=1)

// Kalman filter state
var float kalman_estimate = na
var float kalman_error    = na

// Initialize
if na(kalman_estimate)
    kalman_estimate := src
    kalman_error    := 1.0

// Volatility measures
atr_val   = ta.atr(atr_len)
std_val   = ta.stdev(src, std_len)
atr_ratio = atr_val / math.max(math.abs(src), vol_floor)
std_ratio = std_val / math.max(math.abs(src), vol_floor)
vol_mix   = vol_blend * std_ratio + (1 - vol_blend) * atr_ratio

// Adaptive Q/R
q_eff = use_adapt ? base_q * (1 + q_scale * vol_mix) : base_q
r_eff = use_adapt ? base_r * (1 + r_scale * (1 - math.min(vol_mix, 1.0))) : base_r

// Predict
pred_estimate = kalman_estimate
pred_error    = kalman_error + q_eff

// Update
kalman_gain      = pred_error / (pred_error + r_eff)
kalman_estimate := pred_estimate + kalman_gain * (src - pred_estimate)
kalman_error    := (1.0 - kalman_gain) * pred_error

// EMA for reference
ema_val = ta.ema(src, ema_length)

// Plot
plot(kalman_estimate, title="Kalman MA", color=color.new(color.teal, 0), linewidth=2)
plot(show_ema ? ema_val : na, title="EMA", color=color.new(color.orange, 0), linewidth=1, style=plot.style_line)

// Quick guidance (tooltip)
// - Increase Q (process_noise) to make the line react faster (less smoothing).
// - Increase R (measurement_noise) to smooth more (slower, less noisy).
// - Future idea: tiny on-chart mini-sweep of a few Q/R presets over recent bars to pick the best combo (lightweight pseudo backtest).`;

				const dxyCode = window.codeDownloads['dxy_indicator'];
				const mfiObvCode = window.codeDownloads['normalized_mfi_obv'];
				const parabolaCode = window.codeDownloads['parabola_detector'];
				const kalmanCode = window.codeDownloads['kalman_ma'];
				// Escape code for HTML display
				const escapedDxyCode = dxyCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
				const escapedMfiObvCode = mfiObvCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
				const escapedParabolaCode = parabolaCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
				const escapedKalmanCode = kalmanCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
				
				container.innerHTML = '<div style="margin-bottom: 30px;">' +
					'<div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
					'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">' +
					'<div>' +
					'<h3 style="color: #ffc107; font-size: 20px; margin: 0 0 5px 0; font-weight: bold;">DXY Indicator (PineScript)</h3>' +
					'<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;"><strong style="color: #ffc107;">Very Unique & Rare</strong> - Favorable DXY Overlay that normalizes DXY data and provides hawkish/dovish alerts. This normalized dollar index indicator is not commonly found in TradingView&#39;s public library.</p>' +
					'</div>' +
					'<button onclick="downloadCode(\'DXY_indicator.pine\', \'dxy_indicator\')" ' +
					'style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); white-space: nowrap;" ' +
					'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 6px 20px rgba(76, 175, 80, 0.6)\';" ' +
					'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'0 4px 15px rgba(76, 175, 80, 0.4)\';">' +
					'üì• Download .pine' +
					'</button>' +
					'</div>' +
					'<details style="margin-top: 15px;">' +
					'<summary style="color: rgba(255, 255, 255, 0.9); cursor: pointer; font-weight: 500; font-size: 14px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">View Code Preview</summary>' +
					'<pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 10px; border: 1px solid rgba(255, 193, 7, 0.2); max-height: 400px; overflow-y: auto;"><code style="color: rgba(255, 255, 255, 0.9); font-family: \'Courier New\', monospace; font-size: 13px; line-height: 1.5; white-space: pre;">' + escapedDxyCode + '</code></pre>' +
					'</details>' +
					'</div>' +
					'</div>' +
					'<div style="margin-bottom: 30px;">' +
					'<div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
					'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">' +
					'<div>' +
					'<h3 style="color: #ffc107; font-size: 20px; margin: 0 0 5px 0; font-weight: bold;">Normalized Money Flow Index + Order Book Volume (PineScript)</h3>' +
					'<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;"><strong style="color: #ffc107;">Very Unique & Rare</strong> - Standardized OBV (0-100) and MFI combo indicator. This normalized volume analysis tool that combines OBV and MFI on a comparable scale is extremely rare and not available in standard TradingView indicators.</p>' +
					'</div>' +
					'<button onclick="downloadCode(\'normalized_MFI_OBV.pine\', \'normalized_mfi_obv\')" ' +
					'style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); white-space: nowrap;" ' +
					'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 6px 20px rgba(76, 175, 80, 0.6)\';" ' +
					'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'0 4px 15px rgba(76, 175, 80, 0.4)\';">' +
					'üì• Download .pine' +
					'</button>' +
					'</div>' +
					'<details style="margin-top: 15px;">' +
					'<summary style="color: rgba(255, 255, 255, 0.9); cursor: pointer; font-weight: 500; font-size: 14px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">View Code Preview</summary>' +
					'<pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 10px; border: 1px solid rgba(255, 193, 7, 0.2); max-height: 400px; overflow-y: auto;"><code style="color: rgba(255, 255, 255, 0.9); font-family: \'Courier New\', monospace; font-size: 13px; line-height: 1.5; white-space: pre;">' + escapedMfiObvCode + '</code></pre>' +
					'</details>' +
					'</div>' +
					'</div>' +
					'<div style="margin-bottom: 30px;">' +
					'<div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
					'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">' +
					'<div>' +
					'<h3 style="color: #ffc107; font-size: 20px; margin: 0 0 5px 0; font-weight: bold;">Parabola Detector (PineScript)</h3>' +
					'<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;"><strong style="color: #ffc107;">Very Unique & Rare</strong> - Advanced parabola detection using mathematical curve fitting (R-squared) to identify parabolic price patterns. Plots orange X crosses when parabolas break, indicating potential reversal points. This sophisticated pattern detection algorithm is extremely rare and not available elsewhere.</p>' +
					'</div>' +
					'<button onclick="downloadCode(\'parabola_pinescript7.pine\', \'parabola_detector\')" ' +
					'style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); white-space: nowrap;" ' +
					'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 6px 20px rgba(76, 175, 80, 0.6)\';" ' +
					'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'0 4px 15px rgba(76, 175, 80, 0.4)\';">' +
					'üì• Download .pine' +
					'</button>' +
					'</div>' +
					'<details style="margin-top: 15px;">' +
					'<summary style="color: rgba(255, 255, 255, 0.9); cursor: pointer; font-weight: 500; font-size: 14px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">View Code Preview</summary>' +
					'<pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 10px; border: 1px solid rgba(255, 193, 7, 0.2); max-height: 400px; overflow-y: auto;"><code style="color: rgba(255, 255, 255, 0.9); font-family: \'Courier New\', monospace; font-size: 13px; line-height: 1.5; white-space: pre;">' + escapedParabolaCode + '</code></pre>' +
					'</details>' +
					'</div>' +
					'</div>' +
					'<div style="margin-bottom: 30px;">' +
					'<div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
					'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">' +
					'<div>' +
					'<h3 style="color: #ffc107; font-size: 20px; margin: 0 0 5px 0; font-weight: bold;">Kalman Moving Average (PineScript)</h3>' +
					'<p style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin: 0;"><strong style="color: #ffc107;">Advanced Adaptive Filter</strong> - Superior to SMA, EMA, and Hull MA. Uses optimal Kalman filtering with volatility-adaptive Q/R parameters (process/measurement noise) that automatically adjust via ATR. Responds faster than EMA with similar smoothness, adapts to market volatility, and provides mathematically optimal noise filtering. This adaptive moving average outperforms traditional MAs by dynamically adjusting responsiveness based on market conditions.</p>' +
					'</div>' +
					'<button onclick="downloadCode(\'Kalman_MA.pine\', \'kalman_ma\')" ' +
					'style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); white-space: nowrap;" ' +
					'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 6px 20px rgba(76, 175, 80, 0.6)\';" ' +
					'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'0 4px 15px rgba(76, 175, 80, 0.4)\';">' +
					'üì• Download .pine' +
					'</button>' +
					'</div>' +
					'<details style="margin-top: 15px;">' +
					'<summary style="color: rgba(255, 255, 255, 0.9); cursor: pointer; font-weight: 500; font-size: 14px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">View Code Preview</summary>' +
					'<pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 10px; border: 1px solid rgba(255, 193, 7, 0.2); max-height: 400px; overflow-y: auto;"><code style="color: rgba(255, 255, 255, 0.9); font-family: \'Courier New\', monospace; font-size: 13px; line-height: 1.5; white-space: pre;">' + escapedKalmanCode + '</code></pre>' +
					'</details>' +
					'</div>' +
					'</div>' +
					'<div style="margin-bottom: 30px;">' +
					'<div style="background: rgba(33, 150, 243, 0.10); border: 1px solid rgba(33, 150, 243, 0.45); border-radius: 8px; padding: 20px; margin-bottom: 20px;">' +
					'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">' +
					'<div>' +
					'<h3 style="color: rgba(255, 255, 255, 0.95); font-size: 20px; margin: 0 0 5px 0; font-weight: bold;">YouTube API Manager (Python)</h3>' +
					'<p style="color: rgba(255, 255, 255, 0.75); font-size: 14px; margin: 0;"><strong style="color: rgba(33, 150, 243, 0.95);">Safe public version:</strong> no passwords/keys hardcoded. OAuth secrets/tokens are intentionally stored outside the code (do NOT upload those JSON files).</p>' +
					'</div>' +
					'<a href="youtube_api_public.py" download ' +
					'style="display: inline-block; background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.45); white-space: nowrap; text-decoration: none;" ' +
					'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 6px 20px rgba(33, 150, 243, 0.65)\';" ' +
					'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'0 4px 15px rgba(33, 150, 243, 0.45)\';">' +
					'üì• Download .py' +
					'</a>' +
					'</div>' +
					'<div style="color: rgba(255, 255, 255, 0.65); font-size: 13px; line-height: 1.5;">Includes tooling for descriptions, tags, thumbnails, playlists, chapters, and logging. Configure OAuth by providing your own <code style="color: rgba(255,255,255,0.9);">client_secrets.json</code> + <code style="color: rgba(255,255,255,0.9);">youtube_token.json</code> locally (never publish them).</div>' +
					'</div>' +
					'</div>' +
					'<p style="color: rgba(255, 255, 255, 0.6); font-size: 14px; text-align: center; margin-top: 20px; font-style: italic;">More code downloads coming soon...</p>';
				
				// Restore open state of details elements after a short delay
				setTimeout(() => {
					const newDetailsElements = container.querySelectorAll('details');
					openDetails.forEach(index => {
						if (newDetailsElements[index]) {
							newDetailsElements[index].open = true;
						}
					});
				}, 10);
			}
			
			// Track last access state to only update when it changes
			let lastAccessState = null;
			
			// Update code download section on page load
			document.addEventListener('DOMContentLoaded', function() {
				updateCodeDownloadSection();
				// Only update when subscription status actually changes, not every second
				setInterval(() => {
					const currentAccessState = hasAccess();
					if (currentAccessState !== lastAccessState) {
						lastAccessState = currentAccessState;
						updateCodeDownloadSection();
					}
				}, 1000);
			});
		</script>
		
		<!-- Footer with Copyright -->
		<footer style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-top: 40px; border-top: 1px solid rgba(255, 193, 7, 0.3);">
			<p style="margin: 0;">¬© 2024 All Rights Reserved</p>
		</footer>

		<!-- Trading Assistant Chat Widget -->
		<style>
			#chatFab {
				position: fixed;
				right: 20px;
				bottom: 20px;
				z-index: 9999;
				width: 60px;
				height: 60px;
				border-radius: 50%;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				border: none;
				color: #fff;
				font-size: 24px;
				cursor: pointer;
				box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
				transition: all 0.3s ease;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#chatFab:hover {
				transform: translateY(-2px);
				box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
			}
			#chatBox {
				position: fixed;
				right: 20px;
				bottom: 90px;
				z-index: 9998;
				width: 380px;
				max-width: calc(100vw - 40px);
				height: 500px;
				max-height: calc(100vh - 120px);
				background: rgba(0, 0, 0, 0.95);
				border: 1px solid rgba(255, 255, 255, 0.3);
				border-radius: 12px;
				display: none;
				flex-direction: column;
				overflow: hidden;
				box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
			}
			#chatBox.open {
				display: flex;
			}
			#chatHeader {
				padding: 15px 18px;
				border-bottom: 1px solid rgba(255, 255, 255, 0.2);
				display: flex;
				align-items: center;
				justify-content: space-between;
				background: rgba(102, 126, 234, 0.1);
			}
			#chatHeader h3 {
				margin: 0;
				color: #fff;
				font-size: 18px;
				font-weight: 600;
			}
			#chatClose {
				background: rgba(255, 255, 255, 0.15);
				border: 1px solid rgba(255, 255, 255, 0.3);
				border-radius: 6px;
				color: #fff;
				padding: 6px 12px;
				cursor: pointer;
				font-size: 14px;
				transition: all 0.3s ease;
			}
			#chatClose:hover {
				background: rgba(255, 255, 255, 0.25);
			}
			#chatMsgs {
				flex: 1;
				padding: 15px 18px;
				overflow-y: auto;
				overflow-x: hidden;
				font-size: 14px;
				line-height: 1.6;
			}
			#chatMsgs::-webkit-scrollbar {
				width: 6px;
			}
			#chatMsgs::-webkit-scrollbar-track {
				background: rgba(255, 255, 255, 0.05);
			}
			#chatMsgs::-webkit-scrollbar-thumb {
				background: rgba(255, 255, 255, 0.2);
				border-radius: 3px;
			}
			.chat-msg {
				margin: 12px 0;
				padding: 10px 12px;
				border-radius: 8px;
				word-wrap: break-word;
				white-space: pre-wrap;
			}
			.chat-msg.user {
				background: rgba(102, 126, 234, 0.2);
				border-left: 3px solid #667eea;
				color: rgba(255, 255, 255, 0.95);
				margin-left: 20px;
			}
			.chat-msg.assistant {
				background: rgba(255, 255, 255, 0.08);
				border-left: 3px solid rgba(255, 255, 255, 0.4);
				color: rgba(255, 255, 255, 0.9);
				margin-right: 20px;
			}
			.chat-msg.error {
				background: rgba(244, 67, 54, 0.2);
				border-left: 3px solid #f44336;
				color: rgba(255, 255, 255, 0.9);
			}
			.chat-msg.loading {
				color: rgba(255, 255, 255, 0.6);
				font-style: italic;
			}
			#chatForm {
				padding: 15px 18px;
				border-top: 1px solid rgba(255, 255, 255, 0.2);
				display: flex;
				gap: 10px;
				background: rgba(0, 0, 0, 0.3);
			}
			#chatInput {
				flex: 1;
				padding: 10px 14px;
				border: 1px solid rgba(255, 255, 255, 0.3);
				border-radius: 6px;
				background: rgba(255, 255, 255, 0.1);
				color: #fff;
				font-size: 14px;
				outline: none;
				transition: all 0.3s ease;
			}
			#chatInput:focus {
				border-color: rgba(255, 255, 255, 0.6);
				background: rgba(255, 255, 255, 0.15);
			}
			#chatInput::placeholder {
				color: rgba(255, 255, 255, 0.5);
			}
			#chatSend {
				padding: 10px 20px;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				border: none;
				border-radius: 6px;
				color: #fff;
				font-size: 14px;
				font-weight: 600;
				cursor: pointer;
				transition: all 0.3s ease;
				white-space: nowrap;
			}
			#chatSend:hover:not(:disabled) {
				transform: translateY(-1px);
				box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
			}
			#chatSend:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}
			#chatPrompts {
				padding: 10px 18px;
				border-bottom: 1px solid rgba(255, 255, 255, 0.1);
				display: flex;
				flex-direction: column;
				gap: 8px;
			}
			#chatPrompts.hidden {
				display: none;
			}
			.chat-prompt {
				padding: 10px 14px;
				background: rgba(102, 126, 234, 0.15);
				border: 1px solid rgba(102, 126, 234, 0.3);
				border-radius: 6px;
				color: rgba(255, 255, 255, 0.9);
				font-size: 13px;
				cursor: pointer;
				transition: all 0.3s ease;
				text-align: left;
			}
			.chat-prompt:hover {
				background: rgba(102, 126, 234, 0.25);
				border-color: rgba(102, 126, 234, 0.5);
				transform: translateX(4px);
			}
			@media (max-width: 480px) {
				#chatBox {
					width: calc(100vw - 20px);
					right: 10px;
					bottom: 80px;
					height: calc(100vh - 100px);
				}
				#chatFab {
					right: 10px;
					bottom: 10px;
				}
			}
		</style>

		<button id="chatFab" type="button" aria-label="Open Assistant Chat" title="Assistant">
			üí¨
		</button>

		<div id="chatBox" role="dialog" aria-label="Assistant Chat">
			<div id="chatHeader">
				<h3>üí¨ Assistant</h3>
				<button id="chatClose" type="button">Close</button>
			</div>
			<div id="chatMsgs">
				<div class="chat-msg assistant">
					Hello, I am your assistant on this website. I am programmed to be especially good at answering finance and music questions, using context from this website.
				</div>
			</div>
			<div id="chatPrompts">
				<div class="chat-prompt">What are today's top 3 buys and top sells?</div>
				<div class="chat-prompt">Do you have an arrangement of this song?</div>
				<div class="chat-prompt">What is a moving average crossover strategy?</div>
				<div class="chat-prompt">What guitar techniques are used in jazz?</div>
			</div>
			<form id="chatForm">
				<input id="chatInput" type="text" autocomplete="off" placeholder="Ask a question..." />
				<button id="chatSend" type="submit">Send</button>
			</form>
		</div>

		<script>
			(function() {
				const WORKER_ENDPOINT = 'https://trading-assistant.brianstreckfus.workers.dev/chat';
				const fab = document.getElementById('chatFab');
				const box = document.getElementById('chatBox');
				const closeBtn = document.getElementById('chatClose');
				const form = document.getElementById('chatForm');
				const input = document.getElementById('chatInput');
				const msgs = document.getElementById('chatMsgs');
				const sendBtn = document.getElementById('chatSend');
				const prompts = document.getElementById('chatPrompts');

				// Generate a session ID (persists for this browser session)
				let sessionId = sessionStorage.getItem('trading_assistant_session_id');
				if (!sessionId) {
					sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
					sessionStorage.setItem('trading_assistant_session_id', sessionId);
				}

				function addMsg(text, type = 'assistant') {
					const div = document.createElement('div');
					div.className = 'chat-msg ' + type;
					div.textContent = text;
					msgs.appendChild(div);
					msgs.scrollTop = msgs.scrollHeight;
				}

				function scrollToBottom() {
					msgs.scrollTop = msgs.scrollHeight;
				}

				fab.onclick = function() {
					box.classList.add('open');
					input.focus();
					scrollToBottom();
				};

				closeBtn.onclick = function() {
					box.classList.remove('open');
				};

				// Handle example prompt clicks
				const promptButtons = prompts.querySelectorAll('.chat-prompt');
				promptButtons.forEach(function(btn) {
					btn.onclick = function() {
						const promptText = btn.textContent.trim();
						input.value = promptText;
						input.focus();
						// Auto-submit the prompt
						form.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
					};
				});

				// Helper: Fetch top 3 buys and sells from signals.json
				async function fetchTopSignals() {
					try {
						const response = await fetch('signals/signals.json');
						if (!response.ok) throw new Error('Failed to fetch signals');
						const signals = await response.json();
						
						// Filter stock signals only
						const stockSignals = signals.filter(s => {
							const symbol = (s.symbol || '').toUpperCase();
							return !symbol.includes('/USD') && !symbol.includes('/USDT') && symbol.length <= 5;
						});
						
						// Calculate scores (same logic as signals.html)
						const BUY_THRESHOLD = 16;
						const SELL_THRESHOLD = 13;
						
						const signalsWithScores = stockSignals.map(s => {
							let buyScore = s.buy_score || 0;
							let sellScore = s.sell_score || 0;
							const note = s.note || '';
							const buyMatch = note.match(/buy\s+(\d+)\/(\d+)/i);
							const sellMatch = note.match(/sell\s+(\d+)\/(\d+)/i);
							if (buyMatch) buyScore = parseInt(buyMatch[1]);
							if (sellMatch) sellScore = parseInt(sellMatch[1]);
							
							return {
								...s,
								buyScore: buyScore,
								sellScore: sellScore,
								totalBuy: buyMatch ? parseInt(buyMatch[2]) : 38,
								totalSell: sellMatch ? parseInt(sellMatch[2]) : 37
							};
						});
						
						// Get top 3 buys
						const seenBuySymbols = new Set();
						const topBuy = signalsWithScores
							.filter(s => s.action === 'buy' || s.buyScore >= s.sellScore)
							.sort((a, b) => b.buyScore - a.buyScore)
							.filter(s => {
								if (seenBuySymbols.has(s.symbol)) return false;
								seenBuySymbols.add(s.symbol);
								return true;
							})
							.slice(0, 3);
						
						// Get top 3 sells
						const seenSellSymbols = new Set();
						const topSell = signalsWithScores
							.filter(s => s.action === 'sell' || s.sellScore >= s.buyScore)
							.sort((a, b) => b.sellScore - a.sellScore)
							.filter(s => {
								if (seenSellSymbols.has(s.symbol)) return false;
								seenSellSymbols.add(s.symbol);
								return true;
							})
							.slice(0, 3);
						
						return { topBuy, topSell };
					} catch (error) {
						console.error('Error fetching signals:', error);
						return null;
					}
				}
				
				// Helper: Fetch catalog data
				async function fetchCatalog() {
					try {
						const response = await fetch('catalog-data.json');
						if (!response.ok) throw new Error('Failed to fetch catalog');
						return await response.json();
					} catch (error) {
						console.error('Error fetching catalog:', error);
						return null;
					}
				}
				
				// Helper: Check if message is about signals
				function isSignalsQuery(text) {
					const t = text.toLowerCase();
					return t.includes('top') && (t.includes('buy') || t.includes('sell') || t.includes('signal'));
				}
				
				// Helper: Check if message is about catalog/songs
				function isCatalogQuery(text) {
					const t = text.toLowerCase();
					return t.includes('arrangement') || t.includes('song') || t.includes('catalog') || 
					       t.includes('do you have') || t.includes('available');
				}

				form.onsubmit = async function(e) {
					e.preventDefault();
					const message = (input.value || '').trim();
					if (!message) return;

					// Hide prompts after first message
					if (!prompts.classList.contains('hidden')) {
						prompts.classList.add('hidden');
					}

					input.value = '';
					sendBtn.disabled = true;
					sendBtn.textContent = 'Sending...';

					addMsg('You: ' + message, 'user');
					scrollToBottom();

					const loadingId = 'loading_' + Date.now();
					addMsg('Thinking...', 'loading');
					scrollToBottom();

					try {
						// Build context based on query type
						let contextData = null;
						const msgLower = message.toLowerCase();
						
						if (isSignalsQuery(message)) {
							const signalsData = await fetchTopSignals();
							if (signalsData) {
								contextData = {
									type: 'signals',
									topBuy: signalsData.topBuy.map(s => ({
										symbol: s.symbol,
										buyScore: s.buyScore,
										totalBuy: s.totalBuy,
										price: s.price,
										sector: s.sector,
										timestamp: s.timestamp
									})),
									topSell: signalsData.topSell.map(s => ({
										symbol: s.symbol,
										sellScore: s.sellScore,
										totalSell: s.totalSell,
										price: s.price,
										sector: s.sector,
										timestamp: s.timestamp
									}))
								};
							}
						} else if (isCatalogQuery(message)) {
							const catalog = await fetchCatalog();
							if (catalog) {
								contextData = {
									type: 'catalog',
									songs: catalog.map(item => ({
										title: item.title,
										composer: item.composer,
										difficulty: item.difficulty,
										category: item.category,
										price: item.price
									}))
								};
							}
						}
						
						const requestBody = {
							message: message,
							sessionId: sessionId
						};
						
						if (contextData) {
							requestBody.context = contextData;
						}

						const response = await fetch(WORKER_ENDPOINT, {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify(requestBody)
						});

						// Remove loading message
						const loadingMsg = msgs.querySelector('.chat-msg.loading');
						if (loadingMsg) loadingMsg.remove();

						if (!response.ok) {
							const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
							addMsg('Error: ' + (errorData.error || 'Failed to get response. Please try again.'), 'error');
							scrollToBottom();
							return;
						}

						const data = await response.json();
						let replyText = '';

						if (data.reply) {
							if (typeof data.reply === 'string') {
								replyText = data.reply;
							} else if (data.reply.answer_markdown) {
								replyText = data.reply.answer_markdown;
							} else if (data.reply.title) {
								replyText = data.reply.title + '\n\n' + (data.reply.answer_markdown || JSON.stringify(data.reply, null, 2));
							} else {
								replyText = JSON.stringify(data.reply, null, 2);
							}
						} else {
							replyText = 'No response received.';
						}

						addMsg(replyText, 'assistant');
						scrollToBottom();

					} catch (error) {
						const loadingMsg = msgs.querySelector('.chat-msg.loading');
						if (loadingMsg) loadingMsg.remove();

						console.error('Chat error:', error);
						addMsg('Error: Unable to connect to the assistant. Please check your connection and try again.', 'error');
						scrollToBottom();
					} finally {
						sendBtn.disabled = false;
						sendBtn.textContent = 'Send';
						input.focus();
					}
				};

				// Close on Escape key
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape' && box.classList.contains('open')) {
						box.classList.remove('open');
					}
				});
			})();
		</script>
	</body>
</html>

